var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/katex/dist/katex.js
var require_katex = __commonJS({
  "node_modules/katex/dist/katex.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root2, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["katex"] = factory();
      else
        root2["katex"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name2, getter) {
            if (!__webpack_require__.o(exports2, name2)) {
              Object.defineProperty(exports2, name2, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1) value = __webpack_require__(value);
            if (mode & 8) return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 1);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
          },
          /* 1 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            var katex2 = __webpack_require__(0);
            var SourceLocation = /* @__PURE__ */ function() {
              function SourceLocation2(lexer, start2, end) {
                this.lexer = void 0;
                this.start = void 0;
                this.end = void 0;
                this.lexer = lexer;
                this.start = start2;
                this.end = end;
              }
              SourceLocation2.range = function range3(first, second2) {
                if (!second2) {
                  return first && first.loc;
                } else if (!first || !first.loc || !second2.loc || first.loc.lexer !== second2.loc.lexer) {
                  return null;
                } else {
                  return new SourceLocation2(first.loc.lexer, first.loc.start, second2.loc.end);
                }
              };
              return SourceLocation2;
            }();
            var Token_Token = /* @__PURE__ */ function() {
              function Token(text, loc) {
                this.text = void 0;
                this.loc = void 0;
                this.text = text;
                this.loc = loc;
              }
              var _proto = Token.prototype;
              _proto.range = function range3(endToken, text) {
                return new Token(text, SourceLocation.range(this, endToken));
              };
              return Token;
            }();
            var ParseError = (
              // Error position based on passed-in Token or ParseNode.
              function ParseError2(message, token) {
                this.position = void 0;
                var error = "KaTeX parse error: " + message;
                var start2;
                var loc = token && token.loc;
                if (loc && loc.start <= loc.end) {
                  var input = loc.lexer.input;
                  start2 = loc.start;
                  var end = loc.end;
                  if (start2 === input.length) {
                    error += " at end of input: ";
                  } else {
                    error += " at position " + (start2 + 1) + ": ";
                  }
                  var underlined = input.slice(start2, end).replace(/[^]/g, "$&\u0332");
                  var left;
                  if (start2 > 15) {
                    left = "\u2026" + input.slice(start2 - 15, start2);
                  } else {
                    left = input.slice(0, start2);
                  }
                  var right;
                  if (end + 15 < input.length) {
                    right = input.slice(end, end + 15) + "\u2026";
                  } else {
                    right = input.slice(end);
                  }
                  error += left + underlined + right;
                }
                var self2 = new Error(error);
                self2.name = "ParseError";
                self2.__proto__ = ParseError2.prototype;
                self2.position = start2;
                return self2;
              }
            );
            ParseError.prototype.__proto__ = Error.prototype;
            var src_ParseError = ParseError;
            var contains = function contains2(list, elem) {
              return list.indexOf(elem) !== -1;
            };
            var deflt = function deflt2(setting, defaultIfUndefined) {
              return setting === void 0 ? defaultIfUndefined : setting;
            };
            var uppercase = /([A-Z])/g;
            var hyphenate = function hyphenate2(str) {
              return str.replace(uppercase, "-$1").toLowerCase();
            };
            var ESCAPE_LOOKUP = {
              "&": "&amp;",
              ">": "&gt;",
              "<": "&lt;",
              '"': "&quot;",
              "'": "&#x27;"
            };
            var ESCAPE_REGEX = /[&><"']/g;
            function utils_escape(text) {
              return String(text).replace(ESCAPE_REGEX, function(match) {
                return ESCAPE_LOOKUP[match];
              });
            }
            var getBaseElem = function getBaseElem2(group) {
              if (group.type === "ordgroup") {
                if (group.body.length === 1) {
                  return getBaseElem2(group.body[0]);
                } else {
                  return group;
                }
              } else if (group.type === "color") {
                if (group.body.length === 1) {
                  return getBaseElem2(group.body[0]);
                } else {
                  return group;
                }
              } else if (group.type === "font") {
                return getBaseElem2(group.body);
              } else {
                return group;
              }
            };
            var utils_isCharacterBox = function isCharacterBox(group) {
              var baseElem = getBaseElem(group);
              return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
            };
            var assert = function assert2(value) {
              if (!value) {
                throw new Error("Expected non-null, but got " + String(value));
              }
              return value;
            };
            var utils = {
              contains,
              deflt,
              escape: utils_escape,
              hyphenate,
              getBaseElem,
              isCharacterBox: utils_isCharacterBox
            };
            var Settings_Settings = /* @__PURE__ */ function() {
              function Settings(options) {
                this.displayMode = void 0;
                this.leqno = void 0;
                this.fleqn = void 0;
                this.throwOnError = void 0;
                this.errorColor = void 0;
                this.macros = void 0;
                this.colorIsTextColor = void 0;
                this.strict = void 0;
                this.maxSize = void 0;
                this.maxExpand = void 0;
                this.allowedProtocols = void 0;
                options = options || {};
                this.displayMode = utils.deflt(options.displayMode, false);
                this.leqno = utils.deflt(options.leqno, false);
                this.fleqn = utils.deflt(options.fleqn, false);
                this.throwOnError = utils.deflt(options.throwOnError, true);
                this.errorColor = utils.deflt(options.errorColor, "#cc0000");
                this.macros = options.macros || {};
                this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);
                this.strict = utils.deflt(options.strict, "warn");
                this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));
                this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1e3));
                this.allowedProtocols = utils.deflt(options.allowedProtocols, ["http", "https", "mailto", "_relative"]);
              }
              var _proto = Settings.prototype;
              _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {
                var strict = this.strict;
                if (typeof strict === "function") {
                  strict = strict(errorCode, errorMsg, token);
                }
                if (!strict || strict === "ignore") {
                  return;
                } else if (strict === true || strict === "error") {
                  throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
                } else if (strict === "warn") {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                } else {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                }
              };
              _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {
                var strict = this.strict;
                if (typeof strict === "function") {
                  try {
                    strict = strict(errorCode, errorMsg, token);
                  } catch (error) {
                    strict = "error";
                  }
                }
                if (!strict || strict === "ignore") {
                  return false;
                } else if (strict === true || strict === "error") {
                  return true;
                } else if (strict === "warn") {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                  return false;
                } else {
                  typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                  return false;
                }
              };
              return Settings;
            }();
            var src_Settings = Settings_Settings;
            var Style = /* @__PURE__ */ function() {
              function Style2(id2, size, cramped) {
                this.id = void 0;
                this.size = void 0;
                this.cramped = void 0;
                this.id = id2;
                this.size = size;
                this.cramped = cramped;
              }
              var _proto = Style2.prototype;
              _proto.sup = function sup() {
                return Style_styles[_sup[this.id]];
              };
              _proto.sub = function sub() {
                return Style_styles[_sub[this.id]];
              };
              _proto.fracNum = function fracNum() {
                return Style_styles[_fracNum[this.id]];
              };
              _proto.fracDen = function fracDen() {
                return Style_styles[_fracDen[this.id]];
              };
              _proto.cramp = function cramp() {
                return Style_styles[_cramp[this.id]];
              };
              _proto.text = function text() {
                return Style_styles[_text[this.id]];
              };
              _proto.isTight = function isTight() {
                return this.size >= 2;
              };
              return Style2;
            }();
            var D = 0;
            var Dc = 1;
            var T = 2;
            var Tc = 3;
            var S = 4;
            var Sc = 5;
            var SS = 6;
            var SSc = 7;
            var Style_styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
            var _sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
            var _sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
            var _fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
            var _fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
            var _cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
            var _text = [D, Dc, T, Tc, T, Tc, T, Tc];
            var src_Style = {
              DISPLAY: Style_styles[D],
              TEXT: Style_styles[T],
              SCRIPT: Style_styles[S],
              SCRIPTSCRIPT: Style_styles[SS]
            };
            var scriptData = [{
              // Latin characters beyond the Latin-1 characters we have metrics for.
              // Needed for Czech, Hungarian and Turkish text, for example.
              name: "latin",
              blocks: [
                [256, 591],
                // Latin Extended-A and Latin Extended-B
                [768, 879]
              ]
            }, {
              // The Cyrillic script used by Russian and related languages.
              // A Cyrillic subset used to be supported as explicitly defined
              // symbols in symbols.js
              name: "cyrillic",
              blocks: [[1024, 1279]]
            }, {
              // The Brahmic scripts of South and Southeast Asia
              // Devanagari (0900–097F)
              // Bengali (0980–09FF)
              // Gurmukhi (0A00–0A7F)
              // Gujarati (0A80–0AFF)
              // Oriya (0B00–0B7F)
              // Tamil (0B80–0BFF)
              // Telugu (0C00–0C7F)
              // Kannada (0C80–0CFF)
              // Malayalam (0D00–0D7F)
              // Sinhala (0D80–0DFF)
              // Thai (0E00–0E7F)
              // Lao (0E80–0EFF)
              // Tibetan (0F00–0FFF)
              // Myanmar (1000–109F)
              name: "brahmic",
              blocks: [[2304, 4255]]
            }, {
              name: "georgian",
              blocks: [[4256, 4351]]
            }, {
              // Chinese and Japanese.
              // The "k" in cjk is for Korean, but we've separated Korean out
              name: "cjk",
              blocks: [
                [12288, 12543],
                // CJK symbols and punctuation, Hiragana, Katakana
                [19968, 40879],
                // CJK ideograms
                [65280, 65376]
              ]
            }, {
              // Korean
              name: "hangul",
              blocks: [[44032, 55215]]
            }];
            function scriptFromCodepoint(codepoint) {
              for (var i = 0; i < scriptData.length; i++) {
                var script = scriptData[i];
                for (var _i = 0; _i < script.blocks.length; _i++) {
                  var block = script.blocks[_i];
                  if (codepoint >= block[0] && codepoint <= block[1]) {
                    return script.name;
                  }
                }
              }
              return null;
            }
            var allBlocks = [];
            scriptData.forEach(function(s) {
              return s.blocks.forEach(function(b) {
                return allBlocks.push.apply(allBlocks, b);
              });
            });
            function supportedCodepoint(codepoint) {
              for (var i = 0; i < allBlocks.length; i += 2) {
                if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {
                  return true;
                }
              }
              return false;
            }
            var hLinePad = 80;
            var svgGeometry_path = {
              // sqrtMain path geometry is from glyph U221A in the font KaTeX Main
              // All surds have 80 units padding above the viniculumn.
              sqrtMain: "M95," + (622 + hLinePad) + "c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,\n-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,\n-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,\n35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,\n-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467\ns-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422\ns-65,47,-65,47z M834 " + hLinePad + "H400000v40H845z",
              // size1 is from glyph U221A in the font KaTeX_Size1-Regular
              sqrtSize1: "M263," + (601 + hLinePad) + "c0.7,0,18,39.7,52,119c34,79.3,68.167,\n158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067\nc4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,\n175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71\nc-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,\n-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26\ns76,-59,76,-59s76,-60,76,-60z M1001 " + hLinePad + "H40000v40H1012z",
              // size2 is from glyph U221A in the font KaTeX_Size2-Regular
              // The 80 units padding is most obvious here. Note start node at M1001 80.
              sqrtSize2: "M1001," + hLinePad + "H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,\n572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,\n-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39\nc-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60\ns208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,\n-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z\nM1001 " + hLinePad + "H400000v40H1013z",
              // size3 is from glyph U221A in the font KaTeX_Size3-Regular
              sqrtSize3: "M424," + (2398 + hLinePad) + "c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,\n-342,-109.8,-513.3,-110.5,-514c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,\n25c-5.7,9.3,-9.8,16,-12.5,20s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,\n-13s76,-122,76,-122s77,-121,77,-121s209,968,209,968c0,-2,84.7,-361.7,254,-1079\nc169.3,-717.3,254.7,-1077.7,256,-1081c4,-6.7,10,-10,18,-10H400000v40H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M1001 " + hLinePad + "H400000v40H1014z",
              // size4 is from glyph U221A in the font KaTeX_Size4-Regular
              sqrtSize4: "M473," + (2713 + hLinePad) + "c339.3,-1799.3,509.3,-2700,510,-2702\nc3.3,-7.3,9.3,-11,18,-11H400000v40H1017.7s-90.5,478,-276.2,1466c-185.7,988,\n-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,\n-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200c0,-1.3,-5.3,8.7,-16,30c-10.7,\n21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26s76,-153,76,-153s77,-151,\n77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,606z\nM1001 " + hLinePad + "H400000v40H1017z",
              // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
              doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
              // doublerightarrow is from glyph U+21D2 in font KaTeX Main
              doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
              // leftarrow is from glyph U+2190 in font KaTeX Main
              leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
              // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
              leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
              leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
              // overgroup is from the MnSymbol package (public domain)
              leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
              leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
              // Harpoons are from glyph U+21BD in font KaTeX Main
              leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
              leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
              leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
              leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
              // hook is from glyph U+21A9 in font KaTeX Main
              lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
              leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
              leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
              // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
              leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
              longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
              midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
              midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
              oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
              oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
              oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
              oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
              rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
              rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
              rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
              rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
              rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
              rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
              rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
              rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
              rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
              righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
              rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
              rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
              // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
              twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
              twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
              // tilde1 is a modified version of a glyph from the MnSymbol package
              tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
              // ditto tilde2, tilde3, & tilde4
              tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
              tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
              tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
              // vec is from glyph U+20D7 in font KaTeX Main
              vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
              // widehat1 is a modified version of a glyph from the MnSymbol package
              widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
              // ditto widehat2, widehat3, & widehat4
              widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
              // widecheck paths are all inverted versions of widehat
              widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
              widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
              // The next ten paths support reaction arrows from the mhchem package.
              // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
              // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
              baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
              // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
              rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
              // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
              // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
              baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
              rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
              shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
              shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
            };
            var svgGeometry = {
              path: svgGeometry_path
            };
            var tree_DocumentFragment = /* @__PURE__ */ function() {
              function DocumentFragment(children) {
                this.children = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                this.children = children;
                this.classes = [];
                this.height = 0;
                this.depth = 0;
                this.maxFontSize = 0;
                this.style = {};
              }
              var _proto = DocumentFragment.prototype;
              _proto.hasClass = function hasClass(className) {
                return utils.contains(this.classes, className);
              };
              _proto.toNode = function toNode() {
                var frag = document.createDocumentFragment();
                for (var i = 0; i < this.children.length; i++) {
                  frag.appendChild(this.children[i].toNode());
                }
                return frag;
              };
              _proto.toMarkup = function toMarkup() {
                var markup = "";
                for (var i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                return markup;
              };
              _proto.toText = function toText() {
                var toText2 = function toText3(child) {
                  return child.toText();
                };
                return this.children.map(toText2).join("");
              };
              return DocumentFragment;
            }();
            var createClass = function createClass2(classes) {
              return classes.filter(function(cls) {
                return cls;
              }).join(" ");
            };
            var initNode = function initNode2(classes, options, style) {
              this.classes = classes || [];
              this.attributes = {};
              this.height = 0;
              this.depth = 0;
              this.maxFontSize = 0;
              this.style = style || {};
              if (options) {
                if (options.style.isTight()) {
                  this.classes.push("mtight");
                }
                var color3 = options.getColor();
                if (color3) {
                  this.style.color = color3;
                }
              }
            };
            var _toNode = function toNode(tagName) {
              var node = document.createElement(tagName);
              node.className = createClass(this.classes);
              for (var style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  node.style[style] = this.style[style];
                }
              }
              for (var attr in this.attributes) {
                if (this.attributes.hasOwnProperty(attr)) {
                  node.setAttribute(attr, this.attributes[attr]);
                }
              }
              for (var i = 0; i < this.children.length; i++) {
                node.appendChild(this.children[i].toNode());
              }
              return node;
            };
            var _toMarkup = function toMarkup(tagName) {
              var markup = "<" + tagName;
              if (this.classes.length) {
                markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
              }
              var styles = "";
              for (var style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles) {
                markup += ' style="' + utils.escape(styles) + '"';
              }
              for (var attr in this.attributes) {
                if (this.attributes.hasOwnProperty(attr)) {
                  markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
                }
              }
              markup += ">";
              for (var i = 0; i < this.children.length; i++) {
                markup += this.children[i].toMarkup();
              }
              markup += "</" + tagName + ">";
              return markup;
            };
            var domTree_Span = /* @__PURE__ */ function() {
              function Span(classes, children, options, style) {
                this.children = void 0;
                this.attributes = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.width = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                initNode.call(this, classes, options, style);
                this.children = children || [];
              }
              var _proto = Span.prototype;
              _proto.setAttribute = function setAttribute(attribute, value) {
                this.attributes[attribute] = value;
              };
              _proto.hasClass = function hasClass(className) {
                return utils.contains(this.classes, className);
              };
              _proto.toNode = function toNode() {
                return _toNode.call(this, "span");
              };
              _proto.toMarkup = function toMarkup() {
                return _toMarkup.call(this, "span");
              };
              return Span;
            }();
            var domTree_Anchor = /* @__PURE__ */ function() {
              function Anchor(href, classes, children, options) {
                this.children = void 0;
                this.attributes = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                initNode.call(this, classes, options);
                this.children = children || [];
                this.setAttribute("href", href);
              }
              var _proto2 = Anchor.prototype;
              _proto2.setAttribute = function setAttribute(attribute, value) {
                this.attributes[attribute] = value;
              };
              _proto2.hasClass = function hasClass(className) {
                return utils.contains(this.classes, className);
              };
              _proto2.toNode = function toNode() {
                return _toNode.call(this, "a");
              };
              _proto2.toMarkup = function toMarkup() {
                return _toMarkup.call(this, "a");
              };
              return Anchor;
            }();
            var domTree_Img = /* @__PURE__ */ function() {
              function Img(src, alt, style) {
                this.src = void 0;
                this.alt = void 0;
                this.classes = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.maxFontSize = void 0;
                this.style = void 0;
                this.alt = alt;
                this.src = src;
                this.classes = ["mord"];
                this.style = style;
              }
              var _proto3 = Img.prototype;
              _proto3.hasClass = function hasClass(className) {
                return utils.contains(this.classes, className);
              };
              _proto3.toNode = function toNode() {
                var node = document.createElement("img");
                node.src = this.src;
                node.alt = this.alt;
                node.className = "mord";
                for (var style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    node.style[style] = this.style[style];
                  }
                }
                return node;
              };
              _proto3.toMarkup = function toMarkup() {
                var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
                var styles = "";
                for (var style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
                  }
                }
                if (styles) {
                  markup += ' style="' + utils.escape(styles) + '"';
                }
                markup += "'/>";
                return markup;
              };
              return Img;
            }();
            var iCombinations = {
              "\xEE": "\u0131\u0302",
              "\xEF": "\u0131\u0308",
              "\xED": "\u0131\u0301",
              // 'ī': '\u0131\u0304', // enable when we add Extended Latin
              "\xEC": "\u0131\u0300"
            };
            var domTree_SymbolNode = /* @__PURE__ */ function() {
              function SymbolNode(text, height, depth, italic, skew, width, classes, style) {
                this.text = void 0;
                this.height = void 0;
                this.depth = void 0;
                this.italic = void 0;
                this.skew = void 0;
                this.width = void 0;
                this.maxFontSize = void 0;
                this.classes = void 0;
                this.style = void 0;
                this.text = text;
                this.height = height || 0;
                this.depth = depth || 0;
                this.italic = italic || 0;
                this.skew = skew || 0;
                this.width = width || 0;
                this.classes = classes || [];
                this.style = style || {};
                this.maxFontSize = 0;
                var script = scriptFromCodepoint(this.text.charCodeAt(0));
                if (script) {
                  this.classes.push(script + "_fallback");
                }
                if (/[îïíì]/.test(this.text)) {
                  this.text = iCombinations[this.text];
                }
              }
              var _proto4 = SymbolNode.prototype;
              _proto4.hasClass = function hasClass(className) {
                return utils.contains(this.classes, className);
              };
              _proto4.toNode = function toNode() {
                var node = document.createTextNode(this.text);
                var span = null;
                if (this.italic > 0) {
                  span = document.createElement("span");
                  span.style.marginRight = this.italic + "em";
                }
                if (this.classes.length > 0) {
                  span = span || document.createElement("span");
                  span.className = createClass(this.classes);
                }
                for (var style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    span = span || document.createElement("span");
                    span.style[style] = this.style[style];
                  }
                }
                if (span) {
                  span.appendChild(node);
                  return span;
                } else {
                  return node;
                }
              };
              _proto4.toMarkup = function toMarkup() {
                var needsSpan = false;
                var markup = "<span";
                if (this.classes.length) {
                  needsSpan = true;
                  markup += ' class="';
                  markup += utils.escape(createClass(this.classes));
                  markup += '"';
                }
                var styles = "";
                if (this.italic > 0) {
                  styles += "margin-right:" + this.italic + "em;";
                }
                for (var style in this.style) {
                  if (this.style.hasOwnProperty(style)) {
                    styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
                  }
                }
                if (styles) {
                  needsSpan = true;
                  markup += ' style="' + utils.escape(styles) + '"';
                }
                var escaped = utils.escape(this.text);
                if (needsSpan) {
                  markup += ">";
                  markup += escaped;
                  markup += "</span>";
                  return markup;
                } else {
                  return escaped;
                }
              };
              return SymbolNode;
            }();
            var SvgNode = /* @__PURE__ */ function() {
              function SvgNode2(children, attributes) {
                this.children = void 0;
                this.attributes = void 0;
                this.children = children || [];
                this.attributes = attributes || {};
              }
              var _proto5 = SvgNode2.prototype;
              _proto5.toNode = function toNode() {
                var svgNS = "http://www.w3.org/2000/svg";
                var node = document.createElementNS(svgNS, "svg");
                for (var attr in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                    node.setAttribute(attr, this.attributes[attr]);
                  }
                }
                for (var i = 0; i < this.children.length; i++) {
                  node.appendChild(this.children[i].toNode());
                }
                return node;
              };
              _proto5.toMarkup = function toMarkup() {
                var markup = "<svg";
                for (var attr in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                    markup += " " + attr + "='" + this.attributes[attr] + "'";
                  }
                }
                markup += ">";
                for (var i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                markup += "</svg>";
                return markup;
              };
              return SvgNode2;
            }();
            var domTree_PathNode = /* @__PURE__ */ function() {
              function PathNode(pathName, alternate) {
                this.pathName = void 0;
                this.alternate = void 0;
                this.pathName = pathName;
                this.alternate = alternate;
              }
              var _proto6 = PathNode.prototype;
              _proto6.toNode = function toNode() {
                var svgNS = "http://www.w3.org/2000/svg";
                var node = document.createElementNS(svgNS, "path");
                if (this.alternate) {
                  node.setAttribute("d", this.alternate);
                } else {
                  node.setAttribute("d", svgGeometry.path[this.pathName]);
                }
                return node;
              };
              _proto6.toMarkup = function toMarkup() {
                if (this.alternate) {
                  return "<path d='" + this.alternate + "'/>";
                } else {
                  return "<path d='" + svgGeometry.path[this.pathName] + "'/>";
                }
              };
              return PathNode;
            }();
            var LineNode = /* @__PURE__ */ function() {
              function LineNode2(attributes) {
                this.attributes = void 0;
                this.attributes = attributes || {};
              }
              var _proto7 = LineNode2.prototype;
              _proto7.toNode = function toNode() {
                var svgNS = "http://www.w3.org/2000/svg";
                var node = document.createElementNS(svgNS, "line");
                for (var attr in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                    node.setAttribute(attr, this.attributes[attr]);
                  }
                }
                return node;
              };
              _proto7.toMarkup = function toMarkup() {
                var markup = "<line";
                for (var attr in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                    markup += " " + attr + "='" + this.attributes[attr] + "'";
                  }
                }
                markup += "/>";
                return markup;
              };
              return LineNode2;
            }();
            function assertSymbolDomNode(group) {
              if (group instanceof domTree_SymbolNode) {
                return group;
              } else {
                throw new Error("Expected symbolNode but got " + String(group) + ".");
              }
            }
            function assertSpan(group) {
              if (group instanceof domTree_Span) {
                return group;
              } else {
                throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
              }
            }
            var fontMetricsData = {
              "AMS-Regular": {
                "65": [0, 0.68889, 0, 0, 0.72222],
                "66": [0, 0.68889, 0, 0, 0.66667],
                "67": [0, 0.68889, 0, 0, 0.72222],
                "68": [0, 0.68889, 0, 0, 0.72222],
                "69": [0, 0.68889, 0, 0, 0.66667],
                "70": [0, 0.68889, 0, 0, 0.61111],
                "71": [0, 0.68889, 0, 0, 0.77778],
                "72": [0, 0.68889, 0, 0, 0.77778],
                "73": [0, 0.68889, 0, 0, 0.38889],
                "74": [0.16667, 0.68889, 0, 0, 0.5],
                "75": [0, 0.68889, 0, 0, 0.77778],
                "76": [0, 0.68889, 0, 0, 0.66667],
                "77": [0, 0.68889, 0, 0, 0.94445],
                "78": [0, 0.68889, 0, 0, 0.72222],
                "79": [0.16667, 0.68889, 0, 0, 0.77778],
                "80": [0, 0.68889, 0, 0, 0.61111],
                "81": [0.16667, 0.68889, 0, 0, 0.77778],
                "82": [0, 0.68889, 0, 0, 0.72222],
                "83": [0, 0.68889, 0, 0, 0.55556],
                "84": [0, 0.68889, 0, 0, 0.66667],
                "85": [0, 0.68889, 0, 0, 0.72222],
                "86": [0, 0.68889, 0, 0, 0.72222],
                "87": [0, 0.68889, 0, 0, 1],
                "88": [0, 0.68889, 0, 0, 0.72222],
                "89": [0, 0.68889, 0, 0, 0.72222],
                "90": [0, 0.68889, 0, 0, 0.66667],
                "107": [0, 0.68889, 0, 0, 0.55556],
                "165": [0, 0.675, 0.025, 0, 0.75],
                "174": [0.15559, 0.69224, 0, 0, 0.94666],
                "240": [0, 0.68889, 0, 0, 0.55556],
                "295": [0, 0.68889, 0, 0, 0.54028],
                "710": [0, 0.825, 0, 0, 2.33334],
                "732": [0, 0.9, 0, 0, 2.33334],
                "770": [0, 0.825, 0, 0, 2.33334],
                "771": [0, 0.9, 0, 0, 2.33334],
                "989": [0.08167, 0.58167, 0, 0, 0.77778],
                "1008": [0, 0.43056, 0.04028, 0, 0.66667],
                "8245": [0, 0.54986, 0, 0, 0.275],
                "8463": [0, 0.68889, 0, 0, 0.54028],
                "8487": [0, 0.68889, 0, 0, 0.72222],
                "8498": [0, 0.68889, 0, 0, 0.55556],
                "8502": [0, 0.68889, 0, 0, 0.66667],
                "8503": [0, 0.68889, 0, 0, 0.44445],
                "8504": [0, 0.68889, 0, 0, 0.66667],
                "8513": [0, 0.68889, 0, 0, 0.63889],
                "8592": [-0.03598, 0.46402, 0, 0, 0.5],
                "8594": [-0.03598, 0.46402, 0, 0, 0.5],
                "8602": [-0.13313, 0.36687, 0, 0, 1],
                "8603": [-0.13313, 0.36687, 0, 0, 1],
                "8606": [0.01354, 0.52239, 0, 0, 1],
                "8608": [0.01354, 0.52239, 0, 0, 1],
                "8610": [0.01354, 0.52239, 0, 0, 1.11111],
                "8611": [0.01354, 0.52239, 0, 0, 1.11111],
                "8619": [0, 0.54986, 0, 0, 1],
                "8620": [0, 0.54986, 0, 0, 1],
                "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
                "8622": [-0.13313, 0.36687, 0, 0, 1],
                "8624": [0, 0.69224, 0, 0, 0.5],
                "8625": [0, 0.69224, 0, 0, 0.5],
                "8630": [0, 0.43056, 0, 0, 1],
                "8631": [0, 0.43056, 0, 0, 1],
                "8634": [0.08198, 0.58198, 0, 0, 0.77778],
                "8635": [0.08198, 0.58198, 0, 0, 0.77778],
                "8638": [0.19444, 0.69224, 0, 0, 0.41667],
                "8639": [0.19444, 0.69224, 0, 0, 0.41667],
                "8642": [0.19444, 0.69224, 0, 0, 0.41667],
                "8643": [0.19444, 0.69224, 0, 0, 0.41667],
                "8644": [0.1808, 0.675, 0, 0, 1],
                "8646": [0.1808, 0.675, 0, 0, 1],
                "8647": [0.1808, 0.675, 0, 0, 1],
                "8648": [0.19444, 0.69224, 0, 0, 0.83334],
                "8649": [0.1808, 0.675, 0, 0, 1],
                "8650": [0.19444, 0.69224, 0, 0, 0.83334],
                "8651": [0.01354, 0.52239, 0, 0, 1],
                "8652": [0.01354, 0.52239, 0, 0, 1],
                "8653": [-0.13313, 0.36687, 0, 0, 1],
                "8654": [-0.13313, 0.36687, 0, 0, 1],
                "8655": [-0.13313, 0.36687, 0, 0, 1],
                "8666": [0.13667, 0.63667, 0, 0, 1],
                "8667": [0.13667, 0.63667, 0, 0, 1],
                "8669": [-0.13313, 0.37788, 0, 0, 1],
                "8672": [-0.064, 0.437, 0, 0, 1.334],
                "8674": [-0.064, 0.437, 0, 0, 1.334],
                "8705": [0, 0.825, 0, 0, 0.5],
                "8708": [0, 0.68889, 0, 0, 0.55556],
                "8709": [0.08167, 0.58167, 0, 0, 0.77778],
                "8717": [0, 0.43056, 0, 0, 0.42917],
                "8722": [-0.03598, 0.46402, 0, 0, 0.5],
                "8724": [0.08198, 0.69224, 0, 0, 0.77778],
                "8726": [0.08167, 0.58167, 0, 0, 0.77778],
                "8733": [0, 0.69224, 0, 0, 0.77778],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8737": [0, 0.69224, 0, 0, 0.72222],
                "8738": [0.03517, 0.52239, 0, 0, 0.72222],
                "8739": [0.08167, 0.58167, 0, 0, 0.22222],
                "8740": [0.25142, 0.74111, 0, 0, 0.27778],
                "8741": [0.08167, 0.58167, 0, 0, 0.38889],
                "8742": [0.25142, 0.74111, 0, 0, 0.5],
                "8756": [0, 0.69224, 0, 0, 0.66667],
                "8757": [0, 0.69224, 0, 0, 0.66667],
                "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
                "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8774": [0.30274, 0.79383, 0, 0, 0.77778],
                "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
                "8778": [0.08167, 0.58167, 0, 0, 0.77778],
                "8782": [0.06062, 0.54986, 0, 0, 0.77778],
                "8783": [0.06062, 0.54986, 0, 0, 0.77778],
                "8785": [0.08198, 0.58198, 0, 0, 0.77778],
                "8786": [0.08198, 0.58198, 0, 0, 0.77778],
                "8787": [0.08198, 0.58198, 0, 0, 0.77778],
                "8790": [0, 0.69224, 0, 0, 0.77778],
                "8791": [0.22958, 0.72958, 0, 0, 0.77778],
                "8796": [0.08198, 0.91667, 0, 0, 0.77778],
                "8806": [0.25583, 0.75583, 0, 0, 0.77778],
                "8807": [0.25583, 0.75583, 0, 0, 0.77778],
                "8808": [0.25142, 0.75726, 0, 0, 0.77778],
                "8809": [0.25142, 0.75726, 0, 0, 0.77778],
                "8812": [0.25583, 0.75583, 0, 0, 0.5],
                "8814": [0.20576, 0.70576, 0, 0, 0.77778],
                "8815": [0.20576, 0.70576, 0, 0, 0.77778],
                "8816": [0.30274, 0.79383, 0, 0, 0.77778],
                "8817": [0.30274, 0.79383, 0, 0, 0.77778],
                "8818": [0.22958, 0.72958, 0, 0, 0.77778],
                "8819": [0.22958, 0.72958, 0, 0, 0.77778],
                "8822": [0.1808, 0.675, 0, 0, 0.77778],
                "8823": [0.1808, 0.675, 0, 0, 0.77778],
                "8828": [0.13667, 0.63667, 0, 0, 0.77778],
                "8829": [0.13667, 0.63667, 0, 0, 0.77778],
                "8830": [0.22958, 0.72958, 0, 0, 0.77778],
                "8831": [0.22958, 0.72958, 0, 0, 0.77778],
                "8832": [0.20576, 0.70576, 0, 0, 0.77778],
                "8833": [0.20576, 0.70576, 0, 0, 0.77778],
                "8840": [0.30274, 0.79383, 0, 0, 0.77778],
                "8841": [0.30274, 0.79383, 0, 0, 0.77778],
                "8842": [0.13597, 0.63597, 0, 0, 0.77778],
                "8843": [0.13597, 0.63597, 0, 0, 0.77778],
                "8847": [0.03517, 0.54986, 0, 0, 0.77778],
                "8848": [0.03517, 0.54986, 0, 0, 0.77778],
                "8858": [0.08198, 0.58198, 0, 0, 0.77778],
                "8859": [0.08198, 0.58198, 0, 0, 0.77778],
                "8861": [0.08198, 0.58198, 0, 0, 0.77778],
                "8862": [0, 0.675, 0, 0, 0.77778],
                "8863": [0, 0.675, 0, 0, 0.77778],
                "8864": [0, 0.675, 0, 0, 0.77778],
                "8865": [0, 0.675, 0, 0, 0.77778],
                "8872": [0, 0.69224, 0, 0, 0.61111],
                "8873": [0, 0.69224, 0, 0, 0.72222],
                "8874": [0, 0.69224, 0, 0, 0.88889],
                "8876": [0, 0.68889, 0, 0, 0.61111],
                "8877": [0, 0.68889, 0, 0, 0.61111],
                "8878": [0, 0.68889, 0, 0, 0.72222],
                "8879": [0, 0.68889, 0, 0, 0.72222],
                "8882": [0.03517, 0.54986, 0, 0, 0.77778],
                "8883": [0.03517, 0.54986, 0, 0, 0.77778],
                "8884": [0.13667, 0.63667, 0, 0, 0.77778],
                "8885": [0.13667, 0.63667, 0, 0, 0.77778],
                "8888": [0, 0.54986, 0, 0, 1.11111],
                "8890": [0.19444, 0.43056, 0, 0, 0.55556],
                "8891": [0.19444, 0.69224, 0, 0, 0.61111],
                "8892": [0.19444, 0.69224, 0, 0, 0.61111],
                "8901": [0, 0.54986, 0, 0, 0.27778],
                "8903": [0.08167, 0.58167, 0, 0, 0.77778],
                "8905": [0.08167, 0.58167, 0, 0, 0.77778],
                "8906": [0.08167, 0.58167, 0, 0, 0.77778],
                "8907": [0, 0.69224, 0, 0, 0.77778],
                "8908": [0, 0.69224, 0, 0, 0.77778],
                "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
                "8910": [0, 0.54986, 0, 0, 0.76042],
                "8911": [0, 0.54986, 0, 0, 0.76042],
                "8912": [0.03517, 0.54986, 0, 0, 0.77778],
                "8913": [0.03517, 0.54986, 0, 0, 0.77778],
                "8914": [0, 0.54986, 0, 0, 0.66667],
                "8915": [0, 0.54986, 0, 0, 0.66667],
                "8916": [0, 0.69224, 0, 0, 0.66667],
                "8918": [0.0391, 0.5391, 0, 0, 0.77778],
                "8919": [0.0391, 0.5391, 0, 0, 0.77778],
                "8920": [0.03517, 0.54986, 0, 0, 1.33334],
                "8921": [0.03517, 0.54986, 0, 0, 1.33334],
                "8922": [0.38569, 0.88569, 0, 0, 0.77778],
                "8923": [0.38569, 0.88569, 0, 0, 0.77778],
                "8926": [0.13667, 0.63667, 0, 0, 0.77778],
                "8927": [0.13667, 0.63667, 0, 0, 0.77778],
                "8928": [0.30274, 0.79383, 0, 0, 0.77778],
                "8929": [0.30274, 0.79383, 0, 0, 0.77778],
                "8934": [0.23222, 0.74111, 0, 0, 0.77778],
                "8935": [0.23222, 0.74111, 0, 0, 0.77778],
                "8936": [0.23222, 0.74111, 0, 0, 0.77778],
                "8937": [0.23222, 0.74111, 0, 0, 0.77778],
                "8938": [0.20576, 0.70576, 0, 0, 0.77778],
                "8939": [0.20576, 0.70576, 0, 0, 0.77778],
                "8940": [0.30274, 0.79383, 0, 0, 0.77778],
                "8941": [0.30274, 0.79383, 0, 0, 0.77778],
                "8994": [0.19444, 0.69224, 0, 0, 0.77778],
                "8995": [0.19444, 0.69224, 0, 0, 0.77778],
                "9416": [0.15559, 0.69224, 0, 0, 0.90222],
                "9484": [0, 0.69224, 0, 0, 0.5],
                "9488": [0, 0.69224, 0, 0, 0.5],
                "9492": [0, 0.37788, 0, 0, 0.5],
                "9496": [0, 0.37788, 0, 0, 0.5],
                "9585": [0.19444, 0.68889, 0, 0, 0.88889],
                "9586": [0.19444, 0.74111, 0, 0, 0.88889],
                "9632": [0, 0.675, 0, 0, 0.77778],
                "9633": [0, 0.675, 0, 0, 0.77778],
                "9650": [0, 0.54986, 0, 0, 0.72222],
                "9651": [0, 0.54986, 0, 0, 0.72222],
                "9654": [0.03517, 0.54986, 0, 0, 0.77778],
                "9660": [0, 0.54986, 0, 0, 0.72222],
                "9661": [0, 0.54986, 0, 0, 0.72222],
                "9664": [0.03517, 0.54986, 0, 0, 0.77778],
                "9674": [0.11111, 0.69224, 0, 0, 0.66667],
                "9733": [0.19444, 0.69224, 0, 0, 0.94445],
                "10003": [0, 0.69224, 0, 0, 0.83334],
                "10016": [0, 0.69224, 0, 0, 0.83334],
                "10731": [0.11111, 0.69224, 0, 0, 0.66667],
                "10846": [0.19444, 0.75583, 0, 0, 0.61111],
                "10877": [0.13667, 0.63667, 0, 0, 0.77778],
                "10878": [0.13667, 0.63667, 0, 0, 0.77778],
                "10885": [0.25583, 0.75583, 0, 0, 0.77778],
                "10886": [0.25583, 0.75583, 0, 0, 0.77778],
                "10887": [0.13597, 0.63597, 0, 0, 0.77778],
                "10888": [0.13597, 0.63597, 0, 0, 0.77778],
                "10889": [0.26167, 0.75726, 0, 0, 0.77778],
                "10890": [0.26167, 0.75726, 0, 0, 0.77778],
                "10891": [0.48256, 0.98256, 0, 0, 0.77778],
                "10892": [0.48256, 0.98256, 0, 0, 0.77778],
                "10901": [0.13667, 0.63667, 0, 0, 0.77778],
                "10902": [0.13667, 0.63667, 0, 0, 0.77778],
                "10933": [0.25142, 0.75726, 0, 0, 0.77778],
                "10934": [0.25142, 0.75726, 0, 0, 0.77778],
                "10935": [0.26167, 0.75726, 0, 0, 0.77778],
                "10936": [0.26167, 0.75726, 0, 0, 0.77778],
                "10937": [0.26167, 0.75726, 0, 0, 0.77778],
                "10938": [0.26167, 0.75726, 0, 0, 0.77778],
                "10949": [0.25583, 0.75583, 0, 0, 0.77778],
                "10950": [0.25583, 0.75583, 0, 0, 0.77778],
                "10955": [0.28481, 0.79383, 0, 0, 0.77778],
                "10956": [0.28481, 0.79383, 0, 0, 0.77778],
                "57350": [0.08167, 0.58167, 0, 0, 0.22222],
                "57351": [0.08167, 0.58167, 0, 0, 0.38889],
                "57352": [0.08167, 0.58167, 0, 0, 0.77778],
                "57353": [0, 0.43056, 0.04028, 0, 0.66667],
                "57356": [0.25142, 0.75726, 0, 0, 0.77778],
                "57357": [0.25142, 0.75726, 0, 0, 0.77778],
                "57358": [0.41951, 0.91951, 0, 0, 0.77778],
                "57359": [0.30274, 0.79383, 0, 0, 0.77778],
                "57360": [0.30274, 0.79383, 0, 0, 0.77778],
                "57361": [0.41951, 0.91951, 0, 0, 0.77778],
                "57366": [0.25142, 0.75726, 0, 0, 0.77778],
                "57367": [0.25142, 0.75726, 0, 0, 0.77778],
                "57368": [0.25142, 0.75726, 0, 0, 0.77778],
                "57369": [0.25142, 0.75726, 0, 0, 0.77778],
                "57370": [0.13597, 0.63597, 0, 0, 0.77778],
                "57371": [0.13597, 0.63597, 0, 0, 0.77778]
              },
              "Caligraphic-Regular": {
                "48": [0, 0.43056, 0, 0, 0.5],
                "49": [0, 0.43056, 0, 0, 0.5],
                "50": [0, 0.43056, 0, 0, 0.5],
                "51": [0.19444, 0.43056, 0, 0, 0.5],
                "52": [0.19444, 0.43056, 0, 0, 0.5],
                "53": [0.19444, 0.43056, 0, 0, 0.5],
                "54": [0, 0.64444, 0, 0, 0.5],
                "55": [0.19444, 0.43056, 0, 0, 0.5],
                "56": [0, 0.64444, 0, 0, 0.5],
                "57": [0.19444, 0.43056, 0, 0, 0.5],
                "65": [0, 0.68333, 0, 0.19445, 0.79847],
                "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
                "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
                "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
                "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
                "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
                "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
                "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
                "73": [0, 0.68333, 0.07382, 0, 0.54452],
                "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
                "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
                "76": [0, 0.68333, 0, 0.13889, 0.68972],
                "77": [0, 0.68333, 0, 0.13889, 1.2009],
                "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
                "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
                "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
                "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
                "82": [0, 0.68333, 0, 0.08334, 0.8475],
                "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
                "84": [0, 0.68333, 0.25417, 0, 0.54464],
                "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
                "86": [0, 0.68333, 0.08222, 0, 0.61278],
                "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
                "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
                "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
                "90": [0, 0.68333, 0.07944, 0.13889, 0.72473]
              },
              "Fraktur-Regular": {
                "33": [0, 0.69141, 0, 0, 0.29574],
                "34": [0, 0.69141, 0, 0, 0.21471],
                "38": [0, 0.69141, 0, 0, 0.73786],
                "39": [0, 0.69141, 0, 0, 0.21201],
                "40": [0.24982, 0.74947, 0, 0, 0.38865],
                "41": [0.24982, 0.74947, 0, 0, 0.38865],
                "42": [0, 0.62119, 0, 0, 0.27764],
                "43": [0.08319, 0.58283, 0, 0, 0.75623],
                "44": [0, 0.10803, 0, 0, 0.27764],
                "45": [0.08319, 0.58283, 0, 0, 0.75623],
                "46": [0, 0.10803, 0, 0, 0.27764],
                "47": [0.24982, 0.74947, 0, 0, 0.50181],
                "48": [0, 0.47534, 0, 0, 0.50181],
                "49": [0, 0.47534, 0, 0, 0.50181],
                "50": [0, 0.47534, 0, 0, 0.50181],
                "51": [0.18906, 0.47534, 0, 0, 0.50181],
                "52": [0.18906, 0.47534, 0, 0, 0.50181],
                "53": [0.18906, 0.47534, 0, 0, 0.50181],
                "54": [0, 0.69141, 0, 0, 0.50181],
                "55": [0.18906, 0.47534, 0, 0, 0.50181],
                "56": [0, 0.69141, 0, 0, 0.50181],
                "57": [0.18906, 0.47534, 0, 0, 0.50181],
                "58": [0, 0.47534, 0, 0, 0.21606],
                "59": [0.12604, 0.47534, 0, 0, 0.21606],
                "61": [-0.13099, 0.36866, 0, 0, 0.75623],
                "63": [0, 0.69141, 0, 0, 0.36245],
                "65": [0, 0.69141, 0, 0, 0.7176],
                "66": [0, 0.69141, 0, 0, 0.88397],
                "67": [0, 0.69141, 0, 0, 0.61254],
                "68": [0, 0.69141, 0, 0, 0.83158],
                "69": [0, 0.69141, 0, 0, 0.66278],
                "70": [0.12604, 0.69141, 0, 0, 0.61119],
                "71": [0, 0.69141, 0, 0, 0.78539],
                "72": [0.06302, 0.69141, 0, 0, 0.7203],
                "73": [0, 0.69141, 0, 0, 0.55448],
                "74": [0.12604, 0.69141, 0, 0, 0.55231],
                "75": [0, 0.69141, 0, 0, 0.66845],
                "76": [0, 0.69141, 0, 0, 0.66602],
                "77": [0, 0.69141, 0, 0, 1.04953],
                "78": [0, 0.69141, 0, 0, 0.83212],
                "79": [0, 0.69141, 0, 0, 0.82699],
                "80": [0.18906, 0.69141, 0, 0, 0.82753],
                "81": [0.03781, 0.69141, 0, 0, 0.82699],
                "82": [0, 0.69141, 0, 0, 0.82807],
                "83": [0, 0.69141, 0, 0, 0.82861],
                "84": [0, 0.69141, 0, 0, 0.66899],
                "85": [0, 0.69141, 0, 0, 0.64576],
                "86": [0, 0.69141, 0, 0, 0.83131],
                "87": [0, 0.69141, 0, 0, 1.04602],
                "88": [0, 0.69141, 0, 0, 0.71922],
                "89": [0.18906, 0.69141, 0, 0, 0.83293],
                "90": [0.12604, 0.69141, 0, 0, 0.60201],
                "91": [0.24982, 0.74947, 0, 0, 0.27764],
                "93": [0.24982, 0.74947, 0, 0, 0.27764],
                "94": [0, 0.69141, 0, 0, 0.49965],
                "97": [0, 0.47534, 0, 0, 0.50046],
                "98": [0, 0.69141, 0, 0, 0.51315],
                "99": [0, 0.47534, 0, 0, 0.38946],
                "100": [0, 0.62119, 0, 0, 0.49857],
                "101": [0, 0.47534, 0, 0, 0.40053],
                "102": [0.18906, 0.69141, 0, 0, 0.32626],
                "103": [0.18906, 0.47534, 0, 0, 0.5037],
                "104": [0.18906, 0.69141, 0, 0, 0.52126],
                "105": [0, 0.69141, 0, 0, 0.27899],
                "106": [0, 0.69141, 0, 0, 0.28088],
                "107": [0, 0.69141, 0, 0, 0.38946],
                "108": [0, 0.69141, 0, 0, 0.27953],
                "109": [0, 0.47534, 0, 0, 0.76676],
                "110": [0, 0.47534, 0, 0, 0.52666],
                "111": [0, 0.47534, 0, 0, 0.48885],
                "112": [0.18906, 0.52396, 0, 0, 0.50046],
                "113": [0.18906, 0.47534, 0, 0, 0.48912],
                "114": [0, 0.47534, 0, 0, 0.38919],
                "115": [0, 0.47534, 0, 0, 0.44266],
                "116": [0, 0.62119, 0, 0, 0.33301],
                "117": [0, 0.47534, 0, 0, 0.5172],
                "118": [0, 0.52396, 0, 0, 0.5118],
                "119": [0, 0.52396, 0, 0, 0.77351],
                "120": [0.18906, 0.47534, 0, 0, 0.38865],
                "121": [0.18906, 0.47534, 0, 0, 0.49884],
                "122": [0.18906, 0.47534, 0, 0, 0.39054],
                "8216": [0, 0.69141, 0, 0, 0.21471],
                "8217": [0, 0.69141, 0, 0, 0.21471],
                "58112": [0, 0.62119, 0, 0, 0.49749],
                "58113": [0, 0.62119, 0, 0, 0.4983],
                "58114": [0.18906, 0.69141, 0, 0, 0.33328],
                "58115": [0.18906, 0.69141, 0, 0, 0.32923],
                "58116": [0.18906, 0.47534, 0, 0, 0.50343],
                "58117": [0, 0.69141, 0, 0, 0.33301],
                "58118": [0, 0.62119, 0, 0, 0.33409],
                "58119": [0, 0.47534, 0, 0, 0.50073]
              },
              "Main-Bold": {
                "33": [0, 0.69444, 0, 0, 0.35],
                "34": [0, 0.69444, 0, 0, 0.60278],
                "35": [0.19444, 0.69444, 0, 0, 0.95833],
                "36": [0.05556, 0.75, 0, 0, 0.575],
                "37": [0.05556, 0.75, 0, 0, 0.95833],
                "38": [0, 0.69444, 0, 0, 0.89444],
                "39": [0, 0.69444, 0, 0, 0.31944],
                "40": [0.25, 0.75, 0, 0, 0.44722],
                "41": [0.25, 0.75, 0, 0, 0.44722],
                "42": [0, 0.75, 0, 0, 0.575],
                "43": [0.13333, 0.63333, 0, 0, 0.89444],
                "44": [0.19444, 0.15556, 0, 0, 0.31944],
                "45": [0, 0.44444, 0, 0, 0.38333],
                "46": [0, 0.15556, 0, 0, 0.31944],
                "47": [0.25, 0.75, 0, 0, 0.575],
                "48": [0, 0.64444, 0, 0, 0.575],
                "49": [0, 0.64444, 0, 0, 0.575],
                "50": [0, 0.64444, 0, 0, 0.575],
                "51": [0, 0.64444, 0, 0, 0.575],
                "52": [0, 0.64444, 0, 0, 0.575],
                "53": [0, 0.64444, 0, 0, 0.575],
                "54": [0, 0.64444, 0, 0, 0.575],
                "55": [0, 0.64444, 0, 0, 0.575],
                "56": [0, 0.64444, 0, 0, 0.575],
                "57": [0, 0.64444, 0, 0, 0.575],
                "58": [0, 0.44444, 0, 0, 0.31944],
                "59": [0.19444, 0.44444, 0, 0, 0.31944],
                "60": [0.08556, 0.58556, 0, 0, 0.89444],
                "61": [-0.10889, 0.39111, 0, 0, 0.89444],
                "62": [0.08556, 0.58556, 0, 0, 0.89444],
                "63": [0, 0.69444, 0, 0, 0.54305],
                "64": [0, 0.69444, 0, 0, 0.89444],
                "65": [0, 0.68611, 0, 0, 0.86944],
                "66": [0, 0.68611, 0, 0, 0.81805],
                "67": [0, 0.68611, 0, 0, 0.83055],
                "68": [0, 0.68611, 0, 0, 0.88194],
                "69": [0, 0.68611, 0, 0, 0.75555],
                "70": [0, 0.68611, 0, 0, 0.72361],
                "71": [0, 0.68611, 0, 0, 0.90416],
                "72": [0, 0.68611, 0, 0, 0.9],
                "73": [0, 0.68611, 0, 0, 0.43611],
                "74": [0, 0.68611, 0, 0, 0.59444],
                "75": [0, 0.68611, 0, 0, 0.90138],
                "76": [0, 0.68611, 0, 0, 0.69166],
                "77": [0, 0.68611, 0, 0, 1.09166],
                "78": [0, 0.68611, 0, 0, 0.9],
                "79": [0, 0.68611, 0, 0, 0.86388],
                "80": [0, 0.68611, 0, 0, 0.78611],
                "81": [0.19444, 0.68611, 0, 0, 0.86388],
                "82": [0, 0.68611, 0, 0, 0.8625],
                "83": [0, 0.68611, 0, 0, 0.63889],
                "84": [0, 0.68611, 0, 0, 0.8],
                "85": [0, 0.68611, 0, 0, 0.88472],
                "86": [0, 0.68611, 0.01597, 0, 0.86944],
                "87": [0, 0.68611, 0.01597, 0, 1.18888],
                "88": [0, 0.68611, 0, 0, 0.86944],
                "89": [0, 0.68611, 0.02875, 0, 0.86944],
                "90": [0, 0.68611, 0, 0, 0.70277],
                "91": [0.25, 0.75, 0, 0, 0.31944],
                "92": [0.25, 0.75, 0, 0, 0.575],
                "93": [0.25, 0.75, 0, 0, 0.31944],
                "94": [0, 0.69444, 0, 0, 0.575],
                "95": [0.31, 0.13444, 0.03194, 0, 0.575],
                "97": [0, 0.44444, 0, 0, 0.55902],
                "98": [0, 0.69444, 0, 0, 0.63889],
                "99": [0, 0.44444, 0, 0, 0.51111],
                "100": [0, 0.69444, 0, 0, 0.63889],
                "101": [0, 0.44444, 0, 0, 0.52708],
                "102": [0, 0.69444, 0.10903, 0, 0.35139],
                "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
                "104": [0, 0.69444, 0, 0, 0.63889],
                "105": [0, 0.69444, 0, 0, 0.31944],
                "106": [0.19444, 0.69444, 0, 0, 0.35139],
                "107": [0, 0.69444, 0, 0, 0.60694],
                "108": [0, 0.69444, 0, 0, 0.31944],
                "109": [0, 0.44444, 0, 0, 0.95833],
                "110": [0, 0.44444, 0, 0, 0.63889],
                "111": [0, 0.44444, 0, 0, 0.575],
                "112": [0.19444, 0.44444, 0, 0, 0.63889],
                "113": [0.19444, 0.44444, 0, 0, 0.60694],
                "114": [0, 0.44444, 0, 0, 0.47361],
                "115": [0, 0.44444, 0, 0, 0.45361],
                "116": [0, 0.63492, 0, 0, 0.44722],
                "117": [0, 0.44444, 0, 0, 0.63889],
                "118": [0, 0.44444, 0.01597, 0, 0.60694],
                "119": [0, 0.44444, 0.01597, 0, 0.83055],
                "120": [0, 0.44444, 0, 0, 0.60694],
                "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
                "122": [0, 0.44444, 0, 0, 0.51111],
                "123": [0.25, 0.75, 0, 0, 0.575],
                "124": [0.25, 0.75, 0, 0, 0.31944],
                "125": [0.25, 0.75, 0, 0, 0.575],
                "126": [0.35, 0.34444, 0, 0, 0.575],
                "168": [0, 0.69444, 0, 0, 0.575],
                "172": [0, 0.44444, 0, 0, 0.76666],
                "176": [0, 0.69444, 0, 0, 0.86944],
                "177": [0.13333, 0.63333, 0, 0, 0.89444],
                "184": [0.17014, 0, 0, 0, 0.51111],
                "198": [0, 0.68611, 0, 0, 1.04166],
                "215": [0.13333, 0.63333, 0, 0, 0.89444],
                "216": [0.04861, 0.73472, 0, 0, 0.89444],
                "223": [0, 0.69444, 0, 0, 0.59722],
                "230": [0, 0.44444, 0, 0, 0.83055],
                "247": [0.13333, 0.63333, 0, 0, 0.89444],
                "248": [0.09722, 0.54167, 0, 0, 0.575],
                "305": [0, 0.44444, 0, 0, 0.31944],
                "338": [0, 0.68611, 0, 0, 1.16944],
                "339": [0, 0.44444, 0, 0, 0.89444],
                "567": [0.19444, 0.44444, 0, 0, 0.35139],
                "710": [0, 0.69444, 0, 0, 0.575],
                "711": [0, 0.63194, 0, 0, 0.575],
                "713": [0, 0.59611, 0, 0, 0.575],
                "714": [0, 0.69444, 0, 0, 0.575],
                "715": [0, 0.69444, 0, 0, 0.575],
                "728": [0, 0.69444, 0, 0, 0.575],
                "729": [0, 0.69444, 0, 0, 0.31944],
                "730": [0, 0.69444, 0, 0, 0.86944],
                "732": [0, 0.69444, 0, 0, 0.575],
                "733": [0, 0.69444, 0, 0, 0.575],
                "915": [0, 0.68611, 0, 0, 0.69166],
                "916": [0, 0.68611, 0, 0, 0.95833],
                "920": [0, 0.68611, 0, 0, 0.89444],
                "923": [0, 0.68611, 0, 0, 0.80555],
                "926": [0, 0.68611, 0, 0, 0.76666],
                "928": [0, 0.68611, 0, 0, 0.9],
                "931": [0, 0.68611, 0, 0, 0.83055],
                "933": [0, 0.68611, 0, 0, 0.89444],
                "934": [0, 0.68611, 0, 0, 0.83055],
                "936": [0, 0.68611, 0, 0, 0.89444],
                "937": [0, 0.68611, 0, 0, 0.83055],
                "8211": [0, 0.44444, 0.03194, 0, 0.575],
                "8212": [0, 0.44444, 0.03194, 0, 1.14999],
                "8216": [0, 0.69444, 0, 0, 0.31944],
                "8217": [0, 0.69444, 0, 0, 0.31944],
                "8220": [0, 0.69444, 0, 0, 0.60278],
                "8221": [0, 0.69444, 0, 0, 0.60278],
                "8224": [0.19444, 0.69444, 0, 0, 0.51111],
                "8225": [0.19444, 0.69444, 0, 0, 0.51111],
                "8242": [0, 0.55556, 0, 0, 0.34444],
                "8407": [0, 0.72444, 0.15486, 0, 0.575],
                "8463": [0, 0.69444, 0, 0, 0.66759],
                "8465": [0, 0.69444, 0, 0, 0.83055],
                "8467": [0, 0.69444, 0, 0, 0.47361],
                "8472": [0.19444, 0.44444, 0, 0, 0.74027],
                "8476": [0, 0.69444, 0, 0, 0.83055],
                "8501": [0, 0.69444, 0, 0, 0.70277],
                "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8593": [0.19444, 0.69444, 0, 0, 0.575],
                "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8595": [0.19444, 0.69444, 0, 0, 0.575],
                "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8597": [0.25, 0.75, 0, 0, 0.575],
                "8598": [0.19444, 0.69444, 0, 0, 1.14999],
                "8599": [0.19444, 0.69444, 0, 0, 1.14999],
                "8600": [0.19444, 0.69444, 0, 0, 1.14999],
                "8601": [0.19444, 0.69444, 0, 0, 1.14999],
                "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8657": [0.19444, 0.69444, 0, 0, 0.70277],
                "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8659": [0.19444, 0.69444, 0, 0, 0.70277],
                "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
                "8661": [0.25, 0.75, 0, 0, 0.70277],
                "8704": [0, 0.69444, 0, 0, 0.63889],
                "8706": [0, 0.69444, 0.06389, 0, 0.62847],
                "8707": [0, 0.69444, 0, 0, 0.63889],
                "8709": [0.05556, 0.75, 0, 0, 0.575],
                "8711": [0, 0.68611, 0, 0, 0.95833],
                "8712": [0.08556, 0.58556, 0, 0, 0.76666],
                "8715": [0.08556, 0.58556, 0, 0, 0.76666],
                "8722": [0.13333, 0.63333, 0, 0, 0.89444],
                "8723": [0.13333, 0.63333, 0, 0, 0.89444],
                "8725": [0.25, 0.75, 0, 0, 0.575],
                "8726": [0.25, 0.75, 0, 0, 0.575],
                "8727": [-0.02778, 0.47222, 0, 0, 0.575],
                "8728": [-0.02639, 0.47361, 0, 0, 0.575],
                "8729": [-0.02639, 0.47361, 0, 0, 0.575],
                "8730": [0.18, 0.82, 0, 0, 0.95833],
                "8733": [0, 0.44444, 0, 0, 0.89444],
                "8734": [0, 0.44444, 0, 0, 1.14999],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8739": [0.25, 0.75, 0, 0, 0.31944],
                "8741": [0.25, 0.75, 0, 0, 0.575],
                "8743": [0, 0.55556, 0, 0, 0.76666],
                "8744": [0, 0.55556, 0, 0, 0.76666],
                "8745": [0, 0.55556, 0, 0, 0.76666],
                "8746": [0, 0.55556, 0, 0, 0.76666],
                "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
                "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
                "8768": [0.19444, 0.69444, 0, 0, 0.31944],
                "8771": [222e-5, 0.50222, 0, 0, 0.89444],
                "8776": [0.02444, 0.52444, 0, 0, 0.89444],
                "8781": [222e-5, 0.50222, 0, 0, 0.89444],
                "8801": [222e-5, 0.50222, 0, 0, 0.89444],
                "8804": [0.19667, 0.69667, 0, 0, 0.89444],
                "8805": [0.19667, 0.69667, 0, 0, 0.89444],
                "8810": [0.08556, 0.58556, 0, 0, 1.14999],
                "8811": [0.08556, 0.58556, 0, 0, 1.14999],
                "8826": [0.08556, 0.58556, 0, 0, 0.89444],
                "8827": [0.08556, 0.58556, 0, 0, 0.89444],
                "8834": [0.08556, 0.58556, 0, 0, 0.89444],
                "8835": [0.08556, 0.58556, 0, 0, 0.89444],
                "8838": [0.19667, 0.69667, 0, 0, 0.89444],
                "8839": [0.19667, 0.69667, 0, 0, 0.89444],
                "8846": [0, 0.55556, 0, 0, 0.76666],
                "8849": [0.19667, 0.69667, 0, 0, 0.89444],
                "8850": [0.19667, 0.69667, 0, 0, 0.89444],
                "8851": [0, 0.55556, 0, 0, 0.76666],
                "8852": [0, 0.55556, 0, 0, 0.76666],
                "8853": [0.13333, 0.63333, 0, 0, 0.89444],
                "8854": [0.13333, 0.63333, 0, 0, 0.89444],
                "8855": [0.13333, 0.63333, 0, 0, 0.89444],
                "8856": [0.13333, 0.63333, 0, 0, 0.89444],
                "8857": [0.13333, 0.63333, 0, 0, 0.89444],
                "8866": [0, 0.69444, 0, 0, 0.70277],
                "8867": [0, 0.69444, 0, 0, 0.70277],
                "8868": [0, 0.69444, 0, 0, 0.89444],
                "8869": [0, 0.69444, 0, 0, 0.89444],
                "8900": [-0.02639, 0.47361, 0, 0, 0.575],
                "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
                "8902": [-0.02778, 0.47222, 0, 0, 0.575],
                "8968": [0.25, 0.75, 0, 0, 0.51111],
                "8969": [0.25, 0.75, 0, 0, 0.51111],
                "8970": [0.25, 0.75, 0, 0, 0.51111],
                "8971": [0.25, 0.75, 0, 0, 0.51111],
                "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
                "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
                "9651": [0.19444, 0.69444, 0, 0, 1.02222],
                "9657": [-0.02778, 0.47222, 0, 0, 0.575],
                "9661": [0.19444, 0.69444, 0, 0, 1.02222],
                "9667": [-0.02778, 0.47222, 0, 0, 0.575],
                "9711": [0.19444, 0.69444, 0, 0, 1.14999],
                "9824": [0.12963, 0.69444, 0, 0, 0.89444],
                "9825": [0.12963, 0.69444, 0, 0, 0.89444],
                "9826": [0.12963, 0.69444, 0, 0, 0.89444],
                "9827": [0.12963, 0.69444, 0, 0, 0.89444],
                "9837": [0, 0.75, 0, 0, 0.44722],
                "9838": [0.19444, 0.69444, 0, 0, 0.44722],
                "9839": [0.19444, 0.69444, 0, 0, 0.44722],
                "10216": [0.25, 0.75, 0, 0, 0.44722],
                "10217": [0.25, 0.75, 0, 0, 0.44722],
                "10815": [0, 0.68611, 0, 0, 0.9],
                "10927": [0.19667, 0.69667, 0, 0, 0.89444],
                "10928": [0.19667, 0.69667, 0, 0, 0.89444],
                "57376": [0.19444, 0.69444, 0, 0, 0]
              },
              "Main-BoldItalic": {
                "33": [0, 0.69444, 0.11417, 0, 0.38611],
                "34": [0, 0.69444, 0.07939, 0, 0.62055],
                "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
                "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
                "38": [0, 0.69444, 0.08528, 0, 0.88555],
                "39": [0, 0.69444, 0.12945, 0, 0.35555],
                "40": [0.25, 0.75, 0.15806, 0, 0.47333],
                "41": [0.25, 0.75, 0.03306, 0, 0.47333],
                "42": [0, 0.75, 0.14333, 0, 0.59111],
                "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
                "44": [0.19444, 0.14722, 0, 0, 0.35555],
                "45": [0, 0.44444, 0.02611, 0, 0.41444],
                "46": [0, 0.14722, 0, 0, 0.35555],
                "47": [0.25, 0.75, 0.15806, 0, 0.59111],
                "48": [0, 0.64444, 0.13167, 0, 0.59111],
                "49": [0, 0.64444, 0.13167, 0, 0.59111],
                "50": [0, 0.64444, 0.13167, 0, 0.59111],
                "51": [0, 0.64444, 0.13167, 0, 0.59111],
                "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
                "53": [0, 0.64444, 0.13167, 0, 0.59111],
                "54": [0, 0.64444, 0.13167, 0, 0.59111],
                "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
                "56": [0, 0.64444, 0.13167, 0, 0.59111],
                "57": [0, 0.64444, 0.13167, 0, 0.59111],
                "58": [0, 0.44444, 0.06695, 0, 0.35555],
                "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
                "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
                "63": [0, 0.69444, 0.11472, 0, 0.59111],
                "64": [0, 0.69444, 0.09208, 0, 0.88555],
                "65": [0, 0.68611, 0, 0, 0.86555],
                "66": [0, 0.68611, 0.0992, 0, 0.81666],
                "67": [0, 0.68611, 0.14208, 0, 0.82666],
                "68": [0, 0.68611, 0.09062, 0, 0.87555],
                "69": [0, 0.68611, 0.11431, 0, 0.75666],
                "70": [0, 0.68611, 0.12903, 0, 0.72722],
                "71": [0, 0.68611, 0.07347, 0, 0.89527],
                "72": [0, 0.68611, 0.17208, 0, 0.8961],
                "73": [0, 0.68611, 0.15681, 0, 0.47166],
                "74": [0, 0.68611, 0.145, 0, 0.61055],
                "75": [0, 0.68611, 0.14208, 0, 0.89499],
                "76": [0, 0.68611, 0, 0, 0.69777],
                "77": [0, 0.68611, 0.17208, 0, 1.07277],
                "78": [0, 0.68611, 0.17208, 0, 0.8961],
                "79": [0, 0.68611, 0.09062, 0, 0.85499],
                "80": [0, 0.68611, 0.0992, 0, 0.78721],
                "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
                "82": [0, 0.68611, 0.02559, 0, 0.85944],
                "83": [0, 0.68611, 0.11264, 0, 0.64999],
                "84": [0, 0.68611, 0.12903, 0, 0.7961],
                "85": [0, 0.68611, 0.17208, 0, 0.88083],
                "86": [0, 0.68611, 0.18625, 0, 0.86555],
                "87": [0, 0.68611, 0.18625, 0, 1.15999],
                "88": [0, 0.68611, 0.15681, 0, 0.86555],
                "89": [0, 0.68611, 0.19803, 0, 0.86555],
                "90": [0, 0.68611, 0.14208, 0, 0.70888],
                "91": [0.25, 0.75, 0.1875, 0, 0.35611],
                "93": [0.25, 0.75, 0.09972, 0, 0.35611],
                "94": [0, 0.69444, 0.06709, 0, 0.59111],
                "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
                "97": [0, 0.44444, 0.09426, 0, 0.59111],
                "98": [0, 0.69444, 0.07861, 0, 0.53222],
                "99": [0, 0.44444, 0.05222, 0, 0.53222],
                "100": [0, 0.69444, 0.10861, 0, 0.59111],
                "101": [0, 0.44444, 0.085, 0, 0.53222],
                "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
                "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
                "104": [0, 0.69444, 0.09426, 0, 0.59111],
                "105": [0, 0.69326, 0.11387, 0, 0.35555],
                "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
                "107": [0, 0.69444, 0.11111, 0, 0.53222],
                "108": [0, 0.69444, 0.10861, 0, 0.29666],
                "109": [0, 0.44444, 0.09426, 0, 0.94444],
                "110": [0, 0.44444, 0.09426, 0, 0.64999],
                "111": [0, 0.44444, 0.07861, 0, 0.59111],
                "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
                "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
                "114": [0, 0.44444, 0.11111, 0, 0.50167],
                "115": [0, 0.44444, 0.08167, 0, 0.48694],
                "116": [0, 0.63492, 0.09639, 0, 0.385],
                "117": [0, 0.44444, 0.09426, 0, 0.62055],
                "118": [0, 0.44444, 0.11111, 0, 0.53222],
                "119": [0, 0.44444, 0.11111, 0, 0.76777],
                "120": [0, 0.44444, 0.12583, 0, 0.56055],
                "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
                "122": [0, 0.44444, 0.13889, 0, 0.49055],
                "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
                "163": [0, 0.69444, 0, 0, 0.86853],
                "168": [0, 0.69444, 0.11473, 0, 0.59111],
                "176": [0, 0.69444, 0, 0, 0.94888],
                "184": [0.17014, 0, 0, 0, 0.53222],
                "198": [0, 0.68611, 0.11431, 0, 1.02277],
                "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
                "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
                "230": [0, 0.44444, 0.085, 0, 0.82666],
                "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
                "305": [0, 0.44444, 0.09426, 0, 0.35555],
                "338": [0, 0.68611, 0.11431, 0, 1.14054],
                "339": [0, 0.44444, 0.085, 0, 0.82666],
                "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
                "710": [0, 0.69444, 0.06709, 0, 0.59111],
                "711": [0, 0.63194, 0.08271, 0, 0.59111],
                "713": [0, 0.59444, 0.10444, 0, 0.59111],
                "714": [0, 0.69444, 0.08528, 0, 0.59111],
                "715": [0, 0.69444, 0, 0, 0.59111],
                "728": [0, 0.69444, 0.10333, 0, 0.59111],
                "729": [0, 0.69444, 0.12945, 0, 0.35555],
                "730": [0, 0.69444, 0, 0, 0.94888],
                "732": [0, 0.69444, 0.11472, 0, 0.59111],
                "733": [0, 0.69444, 0.11472, 0, 0.59111],
                "915": [0, 0.68611, 0.12903, 0, 0.69777],
                "916": [0, 0.68611, 0, 0, 0.94444],
                "920": [0, 0.68611, 0.09062, 0, 0.88555],
                "923": [0, 0.68611, 0, 0, 0.80666],
                "926": [0, 0.68611, 0.15092, 0, 0.76777],
                "928": [0, 0.68611, 0.17208, 0, 0.8961],
                "931": [0, 0.68611, 0.11431, 0, 0.82666],
                "933": [0, 0.68611, 0.10778, 0, 0.88555],
                "934": [0, 0.68611, 0.05632, 0, 0.82666],
                "936": [0, 0.68611, 0.10778, 0, 0.88555],
                "937": [0, 0.68611, 0.0992, 0, 0.82666],
                "8211": [0, 0.44444, 0.09811, 0, 0.59111],
                "8212": [0, 0.44444, 0.09811, 0, 1.18221],
                "8216": [0, 0.69444, 0.12945, 0, 0.35555],
                "8217": [0, 0.69444, 0.12945, 0, 0.35555],
                "8220": [0, 0.69444, 0.16772, 0, 0.62055],
                "8221": [0, 0.69444, 0.07939, 0, 0.62055]
              },
              "Main-Italic": {
                "33": [0, 0.69444, 0.12417, 0, 0.30667],
                "34": [0, 0.69444, 0.06961, 0, 0.51444],
                "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
                "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
                "38": [0, 0.69444, 0.09694, 0, 0.76666],
                "39": [0, 0.69444, 0.12417, 0, 0.30667],
                "40": [0.25, 0.75, 0.16194, 0, 0.40889],
                "41": [0.25, 0.75, 0.03694, 0, 0.40889],
                "42": [0, 0.75, 0.14917, 0, 0.51111],
                "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
                "44": [0.19444, 0.10556, 0, 0, 0.30667],
                "45": [0, 0.43056, 0.02826, 0, 0.35778],
                "46": [0, 0.10556, 0, 0, 0.30667],
                "47": [0.25, 0.75, 0.16194, 0, 0.51111],
                "48": [0, 0.64444, 0.13556, 0, 0.51111],
                "49": [0, 0.64444, 0.13556, 0, 0.51111],
                "50": [0, 0.64444, 0.13556, 0, 0.51111],
                "51": [0, 0.64444, 0.13556, 0, 0.51111],
                "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
                "53": [0, 0.64444, 0.13556, 0, 0.51111],
                "54": [0, 0.64444, 0.13556, 0, 0.51111],
                "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
                "56": [0, 0.64444, 0.13556, 0, 0.51111],
                "57": [0, 0.64444, 0.13556, 0, 0.51111],
                "58": [0, 0.43056, 0.0582, 0, 0.30667],
                "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
                "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
                "63": [0, 0.69444, 0.1225, 0, 0.51111],
                "64": [0, 0.69444, 0.09597, 0, 0.76666],
                "65": [0, 0.68333, 0, 0, 0.74333],
                "66": [0, 0.68333, 0.10257, 0, 0.70389],
                "67": [0, 0.68333, 0.14528, 0, 0.71555],
                "68": [0, 0.68333, 0.09403, 0, 0.755],
                "69": [0, 0.68333, 0.12028, 0, 0.67833],
                "70": [0, 0.68333, 0.13305, 0, 0.65277],
                "71": [0, 0.68333, 0.08722, 0, 0.77361],
                "72": [0, 0.68333, 0.16389, 0, 0.74333],
                "73": [0, 0.68333, 0.15806, 0, 0.38555],
                "74": [0, 0.68333, 0.14028, 0, 0.525],
                "75": [0, 0.68333, 0.14528, 0, 0.76888],
                "76": [0, 0.68333, 0, 0, 0.62722],
                "77": [0, 0.68333, 0.16389, 0, 0.89666],
                "78": [0, 0.68333, 0.16389, 0, 0.74333],
                "79": [0, 0.68333, 0.09403, 0, 0.76666],
                "80": [0, 0.68333, 0.10257, 0, 0.67833],
                "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
                "82": [0, 0.68333, 0.03868, 0, 0.72944],
                "83": [0, 0.68333, 0.11972, 0, 0.56222],
                "84": [0, 0.68333, 0.13305, 0, 0.71555],
                "85": [0, 0.68333, 0.16389, 0, 0.74333],
                "86": [0, 0.68333, 0.18361, 0, 0.74333],
                "87": [0, 0.68333, 0.18361, 0, 0.99888],
                "88": [0, 0.68333, 0.15806, 0, 0.74333],
                "89": [0, 0.68333, 0.19383, 0, 0.74333],
                "90": [0, 0.68333, 0.14528, 0, 0.61333],
                "91": [0.25, 0.75, 0.1875, 0, 0.30667],
                "93": [0.25, 0.75, 0.10528, 0, 0.30667],
                "94": [0, 0.69444, 0.06646, 0, 0.51111],
                "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
                "97": [0, 0.43056, 0.07671, 0, 0.51111],
                "98": [0, 0.69444, 0.06312, 0, 0.46],
                "99": [0, 0.43056, 0.05653, 0, 0.46],
                "100": [0, 0.69444, 0.10333, 0, 0.51111],
                "101": [0, 0.43056, 0.07514, 0, 0.46],
                "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
                "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
                "104": [0, 0.69444, 0.07671, 0, 0.51111],
                "105": [0, 0.65536, 0.1019, 0, 0.30667],
                "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
                "107": [0, 0.69444, 0.10764, 0, 0.46],
                "108": [0, 0.69444, 0.10333, 0, 0.25555],
                "109": [0, 0.43056, 0.07671, 0, 0.81777],
                "110": [0, 0.43056, 0.07671, 0, 0.56222],
                "111": [0, 0.43056, 0.06312, 0, 0.51111],
                "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
                "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
                "114": [0, 0.43056, 0.10764, 0, 0.42166],
                "115": [0, 0.43056, 0.08208, 0, 0.40889],
                "116": [0, 0.61508, 0.09486, 0, 0.33222],
                "117": [0, 0.43056, 0.07671, 0, 0.53666],
                "118": [0, 0.43056, 0.10764, 0, 0.46],
                "119": [0, 0.43056, 0.10764, 0, 0.66444],
                "120": [0, 0.43056, 0.12042, 0, 0.46389],
                "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
                "122": [0, 0.43056, 0.12292, 0, 0.40889],
                "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
                "163": [0, 0.69444, 0, 0, 0.76909],
                "168": [0, 0.66786, 0.10474, 0, 0.51111],
                "176": [0, 0.69444, 0, 0, 0.83129],
                "184": [0.17014, 0, 0, 0, 0.46],
                "198": [0, 0.68333, 0.12028, 0, 0.88277],
                "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
                "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
                "230": [0, 0.43056, 0.07514, 0, 0.71555],
                "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
                "305": [0, 0.43056, 0, 0.02778, 0.32246],
                "338": [0, 0.68333, 0.12028, 0, 0.98499],
                "339": [0, 0.43056, 0.07514, 0, 0.71555],
                "567": [0.19444, 0.43056, 0, 0.08334, 0.38403],
                "710": [0, 0.69444, 0.06646, 0, 0.51111],
                "711": [0, 0.62847, 0.08295, 0, 0.51111],
                "713": [0, 0.56167, 0.10333, 0, 0.51111],
                "714": [0, 0.69444, 0.09694, 0, 0.51111],
                "715": [0, 0.69444, 0, 0, 0.51111],
                "728": [0, 0.69444, 0.10806, 0, 0.51111],
                "729": [0, 0.66786, 0.11752, 0, 0.30667],
                "730": [0, 0.69444, 0, 0, 0.83129],
                "732": [0, 0.66786, 0.11585, 0, 0.51111],
                "733": [0, 0.69444, 0.1225, 0, 0.51111],
                "915": [0, 0.68333, 0.13305, 0, 0.62722],
                "916": [0, 0.68333, 0, 0, 0.81777],
                "920": [0, 0.68333, 0.09403, 0, 0.76666],
                "923": [0, 0.68333, 0, 0, 0.69222],
                "926": [0, 0.68333, 0.15294, 0, 0.66444],
                "928": [0, 0.68333, 0.16389, 0, 0.74333],
                "931": [0, 0.68333, 0.12028, 0, 0.71555],
                "933": [0, 0.68333, 0.11111, 0, 0.76666],
                "934": [0, 0.68333, 0.05986, 0, 0.71555],
                "936": [0, 0.68333, 0.11111, 0, 0.76666],
                "937": [0, 0.68333, 0.10257, 0, 0.71555],
                "8211": [0, 0.43056, 0.09208, 0, 0.51111],
                "8212": [0, 0.43056, 0.09208, 0, 1.02222],
                "8216": [0, 0.69444, 0.12417, 0, 0.30667],
                "8217": [0, 0.69444, 0.12417, 0, 0.30667],
                "8220": [0, 0.69444, 0.1685, 0, 0.51444],
                "8221": [0, 0.69444, 0.06961, 0, 0.51444],
                "8463": [0, 0.68889, 0, 0, 0.54028]
              },
              "Main-Regular": {
                "32": [0, 0, 0, 0, 0.25],
                "33": [0, 0.69444, 0, 0, 0.27778],
                "34": [0, 0.69444, 0, 0, 0.5],
                "35": [0.19444, 0.69444, 0, 0, 0.83334],
                "36": [0.05556, 0.75, 0, 0, 0.5],
                "37": [0.05556, 0.75, 0, 0, 0.83334],
                "38": [0, 0.69444, 0, 0, 0.77778],
                "39": [0, 0.69444, 0, 0, 0.27778],
                "40": [0.25, 0.75, 0, 0, 0.38889],
                "41": [0.25, 0.75, 0, 0, 0.38889],
                "42": [0, 0.75, 0, 0, 0.5],
                "43": [0.08333, 0.58333, 0, 0, 0.77778],
                "44": [0.19444, 0.10556, 0, 0, 0.27778],
                "45": [0, 0.43056, 0, 0, 0.33333],
                "46": [0, 0.10556, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0, 0, 0.5],
                "48": [0, 0.64444, 0, 0, 0.5],
                "49": [0, 0.64444, 0, 0, 0.5],
                "50": [0, 0.64444, 0, 0, 0.5],
                "51": [0, 0.64444, 0, 0, 0.5],
                "52": [0, 0.64444, 0, 0, 0.5],
                "53": [0, 0.64444, 0, 0, 0.5],
                "54": [0, 0.64444, 0, 0, 0.5],
                "55": [0, 0.64444, 0, 0, 0.5],
                "56": [0, 0.64444, 0, 0, 0.5],
                "57": [0, 0.64444, 0, 0, 0.5],
                "58": [0, 0.43056, 0, 0, 0.27778],
                "59": [0.19444, 0.43056, 0, 0, 0.27778],
                "60": [0.0391, 0.5391, 0, 0, 0.77778],
                "61": [-0.13313, 0.36687, 0, 0, 0.77778],
                "62": [0.0391, 0.5391, 0, 0, 0.77778],
                "63": [0, 0.69444, 0, 0, 0.47222],
                "64": [0, 0.69444, 0, 0, 0.77778],
                "65": [0, 0.68333, 0, 0, 0.75],
                "66": [0, 0.68333, 0, 0, 0.70834],
                "67": [0, 0.68333, 0, 0, 0.72222],
                "68": [0, 0.68333, 0, 0, 0.76389],
                "69": [0, 0.68333, 0, 0, 0.68056],
                "70": [0, 0.68333, 0, 0, 0.65278],
                "71": [0, 0.68333, 0, 0, 0.78472],
                "72": [0, 0.68333, 0, 0, 0.75],
                "73": [0, 0.68333, 0, 0, 0.36111],
                "74": [0, 0.68333, 0, 0, 0.51389],
                "75": [0, 0.68333, 0, 0, 0.77778],
                "76": [0, 0.68333, 0, 0, 0.625],
                "77": [0, 0.68333, 0, 0, 0.91667],
                "78": [0, 0.68333, 0, 0, 0.75],
                "79": [0, 0.68333, 0, 0, 0.77778],
                "80": [0, 0.68333, 0, 0, 0.68056],
                "81": [0.19444, 0.68333, 0, 0, 0.77778],
                "82": [0, 0.68333, 0, 0, 0.73611],
                "83": [0, 0.68333, 0, 0, 0.55556],
                "84": [0, 0.68333, 0, 0, 0.72222],
                "85": [0, 0.68333, 0, 0, 0.75],
                "86": [0, 0.68333, 0.01389, 0, 0.75],
                "87": [0, 0.68333, 0.01389, 0, 1.02778],
                "88": [0, 0.68333, 0, 0, 0.75],
                "89": [0, 0.68333, 0.025, 0, 0.75],
                "90": [0, 0.68333, 0, 0, 0.61111],
                "91": [0.25, 0.75, 0, 0, 0.27778],
                "92": [0.25, 0.75, 0, 0, 0.5],
                "93": [0.25, 0.75, 0, 0, 0.27778],
                "94": [0, 0.69444, 0, 0, 0.5],
                "95": [0.31, 0.12056, 0.02778, 0, 0.5],
                "97": [0, 0.43056, 0, 0, 0.5],
                "98": [0, 0.69444, 0, 0, 0.55556],
                "99": [0, 0.43056, 0, 0, 0.44445],
                "100": [0, 0.69444, 0, 0, 0.55556],
                "101": [0, 0.43056, 0, 0, 0.44445],
                "102": [0, 0.69444, 0.07778, 0, 0.30556],
                "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
                "104": [0, 0.69444, 0, 0, 0.55556],
                "105": [0, 0.66786, 0, 0, 0.27778],
                "106": [0.19444, 0.66786, 0, 0, 0.30556],
                "107": [0, 0.69444, 0, 0, 0.52778],
                "108": [0, 0.69444, 0, 0, 0.27778],
                "109": [0, 0.43056, 0, 0, 0.83334],
                "110": [0, 0.43056, 0, 0, 0.55556],
                "111": [0, 0.43056, 0, 0, 0.5],
                "112": [0.19444, 0.43056, 0, 0, 0.55556],
                "113": [0.19444, 0.43056, 0, 0, 0.52778],
                "114": [0, 0.43056, 0, 0, 0.39167],
                "115": [0, 0.43056, 0, 0, 0.39445],
                "116": [0, 0.61508, 0, 0, 0.38889],
                "117": [0, 0.43056, 0, 0, 0.55556],
                "118": [0, 0.43056, 0.01389, 0, 0.52778],
                "119": [0, 0.43056, 0.01389, 0, 0.72222],
                "120": [0, 0.43056, 0, 0, 0.52778],
                "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
                "122": [0, 0.43056, 0, 0, 0.44445],
                "123": [0.25, 0.75, 0, 0, 0.5],
                "124": [0.25, 0.75, 0, 0, 0.27778],
                "125": [0.25, 0.75, 0, 0, 0.5],
                "126": [0.35, 0.31786, 0, 0, 0.5],
                "160": [0, 0, 0, 0, 0.25],
                "167": [0.19444, 0.69444, 0, 0, 0.44445],
                "168": [0, 0.66786, 0, 0, 0.5],
                "172": [0, 0.43056, 0, 0, 0.66667],
                "176": [0, 0.69444, 0, 0, 0.75],
                "177": [0.08333, 0.58333, 0, 0, 0.77778],
                "182": [0.19444, 0.69444, 0, 0, 0.61111],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "198": [0, 0.68333, 0, 0, 0.90278],
                "215": [0.08333, 0.58333, 0, 0, 0.77778],
                "216": [0.04861, 0.73194, 0, 0, 0.77778],
                "223": [0, 0.69444, 0, 0, 0.5],
                "230": [0, 0.43056, 0, 0, 0.72222],
                "247": [0.08333, 0.58333, 0, 0, 0.77778],
                "248": [0.09722, 0.52778, 0, 0, 0.5],
                "305": [0, 0.43056, 0, 0, 0.27778],
                "338": [0, 0.68333, 0, 0, 1.01389],
                "339": [0, 0.43056, 0, 0, 0.77778],
                "567": [0.19444, 0.43056, 0, 0, 0.30556],
                "710": [0, 0.69444, 0, 0, 0.5],
                "711": [0, 0.62847, 0, 0, 0.5],
                "713": [0, 0.56778, 0, 0, 0.5],
                "714": [0, 0.69444, 0, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0, 0, 0.5],
                "729": [0, 0.66786, 0, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.75],
                "732": [0, 0.66786, 0, 0, 0.5],
                "733": [0, 0.69444, 0, 0, 0.5],
                "915": [0, 0.68333, 0, 0, 0.625],
                "916": [0, 0.68333, 0, 0, 0.83334],
                "920": [0, 0.68333, 0, 0, 0.77778],
                "923": [0, 0.68333, 0, 0, 0.69445],
                "926": [0, 0.68333, 0, 0, 0.66667],
                "928": [0, 0.68333, 0, 0, 0.75],
                "931": [0, 0.68333, 0, 0, 0.72222],
                "933": [0, 0.68333, 0, 0, 0.77778],
                "934": [0, 0.68333, 0, 0, 0.72222],
                "936": [0, 0.68333, 0, 0, 0.77778],
                "937": [0, 0.68333, 0, 0, 0.72222],
                "8211": [0, 0.43056, 0.02778, 0, 0.5],
                "8212": [0, 0.43056, 0.02778, 0, 1],
                "8216": [0, 0.69444, 0, 0, 0.27778],
                "8217": [0, 0.69444, 0, 0, 0.27778],
                "8220": [0, 0.69444, 0, 0, 0.5],
                "8221": [0, 0.69444, 0, 0, 0.5],
                "8224": [0.19444, 0.69444, 0, 0, 0.44445],
                "8225": [0.19444, 0.69444, 0, 0, 0.44445],
                "8230": [0, 0.12, 0, 0, 1.172],
                "8242": [0, 0.55556, 0, 0, 0.275],
                "8407": [0, 0.71444, 0.15382, 0, 0.5],
                "8463": [0, 0.68889, 0, 0, 0.54028],
                "8465": [0, 0.69444, 0, 0, 0.72222],
                "8467": [0, 0.69444, 0, 0.11111, 0.41667],
                "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
                "8476": [0, 0.69444, 0, 0, 0.72222],
                "8501": [0, 0.69444, 0, 0, 0.61111],
                "8592": [-0.13313, 0.36687, 0, 0, 1],
                "8593": [0.19444, 0.69444, 0, 0, 0.5],
                "8594": [-0.13313, 0.36687, 0, 0, 1],
                "8595": [0.19444, 0.69444, 0, 0, 0.5],
                "8596": [-0.13313, 0.36687, 0, 0, 1],
                "8597": [0.25, 0.75, 0, 0, 0.5],
                "8598": [0.19444, 0.69444, 0, 0, 1],
                "8599": [0.19444, 0.69444, 0, 0, 1],
                "8600": [0.19444, 0.69444, 0, 0, 1],
                "8601": [0.19444, 0.69444, 0, 0, 1],
                "8614": [0.011, 0.511, 0, 0, 1],
                "8617": [0.011, 0.511, 0, 0, 1.126],
                "8618": [0.011, 0.511, 0, 0, 1.126],
                "8636": [-0.13313, 0.36687, 0, 0, 1],
                "8637": [-0.13313, 0.36687, 0, 0, 1],
                "8640": [-0.13313, 0.36687, 0, 0, 1],
                "8641": [-0.13313, 0.36687, 0, 0, 1],
                "8652": [0.011, 0.671, 0, 0, 1],
                "8656": [-0.13313, 0.36687, 0, 0, 1],
                "8657": [0.19444, 0.69444, 0, 0, 0.61111],
                "8658": [-0.13313, 0.36687, 0, 0, 1],
                "8659": [0.19444, 0.69444, 0, 0, 0.61111],
                "8660": [-0.13313, 0.36687, 0, 0, 1],
                "8661": [0.25, 0.75, 0, 0, 0.61111],
                "8704": [0, 0.69444, 0, 0, 0.55556],
                "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
                "8707": [0, 0.69444, 0, 0, 0.55556],
                "8709": [0.05556, 0.75, 0, 0, 0.5],
                "8711": [0, 0.68333, 0, 0, 0.83334],
                "8712": [0.0391, 0.5391, 0, 0, 0.66667],
                "8715": [0.0391, 0.5391, 0, 0, 0.66667],
                "8722": [0.08333, 0.58333, 0, 0, 0.77778],
                "8723": [0.08333, 0.58333, 0, 0, 0.77778],
                "8725": [0.25, 0.75, 0, 0, 0.5],
                "8726": [0.25, 0.75, 0, 0, 0.5],
                "8727": [-0.03472, 0.46528, 0, 0, 0.5],
                "8728": [-0.05555, 0.44445, 0, 0, 0.5],
                "8729": [-0.05555, 0.44445, 0, 0, 0.5],
                "8730": [0.2, 0.8, 0, 0, 0.83334],
                "8733": [0, 0.43056, 0, 0, 0.77778],
                "8734": [0, 0.43056, 0, 0, 1],
                "8736": [0, 0.69224, 0, 0, 0.72222],
                "8739": [0.25, 0.75, 0, 0, 0.27778],
                "8741": [0.25, 0.75, 0, 0, 0.5],
                "8743": [0, 0.55556, 0, 0, 0.66667],
                "8744": [0, 0.55556, 0, 0, 0.66667],
                "8745": [0, 0.55556, 0, 0, 0.66667],
                "8746": [0, 0.55556, 0, 0, 0.66667],
                "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
                "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
                "8768": [0.19444, 0.69444, 0, 0, 0.27778],
                "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8773": [-0.022, 0.589, 0, 0, 1],
                "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
                "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8784": [-0.133, 0.67, 0, 0, 0.778],
                "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
                "8804": [0.13597, 0.63597, 0, 0, 0.77778],
                "8805": [0.13597, 0.63597, 0, 0, 0.77778],
                "8810": [0.0391, 0.5391, 0, 0, 1],
                "8811": [0.0391, 0.5391, 0, 0, 1],
                "8826": [0.0391, 0.5391, 0, 0, 0.77778],
                "8827": [0.0391, 0.5391, 0, 0, 0.77778],
                "8834": [0.0391, 0.5391, 0, 0, 0.77778],
                "8835": [0.0391, 0.5391, 0, 0, 0.77778],
                "8838": [0.13597, 0.63597, 0, 0, 0.77778],
                "8839": [0.13597, 0.63597, 0, 0, 0.77778],
                "8846": [0, 0.55556, 0, 0, 0.66667],
                "8849": [0.13597, 0.63597, 0, 0, 0.77778],
                "8850": [0.13597, 0.63597, 0, 0, 0.77778],
                "8851": [0, 0.55556, 0, 0, 0.66667],
                "8852": [0, 0.55556, 0, 0, 0.66667],
                "8853": [0.08333, 0.58333, 0, 0, 0.77778],
                "8854": [0.08333, 0.58333, 0, 0, 0.77778],
                "8855": [0.08333, 0.58333, 0, 0, 0.77778],
                "8856": [0.08333, 0.58333, 0, 0, 0.77778],
                "8857": [0.08333, 0.58333, 0, 0, 0.77778],
                "8866": [0, 0.69444, 0, 0, 0.61111],
                "8867": [0, 0.69444, 0, 0, 0.61111],
                "8868": [0, 0.69444, 0, 0, 0.77778],
                "8869": [0, 0.69444, 0, 0, 0.77778],
                "8872": [0.249, 0.75, 0, 0, 0.867],
                "8900": [-0.05555, 0.44445, 0, 0, 0.5],
                "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
                "8902": [-0.03472, 0.46528, 0, 0, 0.5],
                "8904": [5e-3, 0.505, 0, 0, 0.9],
                "8942": [0.03, 0.9, 0, 0, 0.278],
                "8943": [-0.19, 0.31, 0, 0, 1.172],
                "8945": [-0.1, 0.82, 0, 0, 1.282],
                "8968": [0.25, 0.75, 0, 0, 0.44445],
                "8969": [0.25, 0.75, 0, 0, 0.44445],
                "8970": [0.25, 0.75, 0, 0, 0.44445],
                "8971": [0.25, 0.75, 0, 0, 0.44445],
                "8994": [-0.14236, 0.35764, 0, 0, 1],
                "8995": [-0.14236, 0.35764, 0, 0, 1],
                "9136": [0.244, 0.744, 0, 0, 0.412],
                "9137": [0.244, 0.744, 0, 0, 0.412],
                "9651": [0.19444, 0.69444, 0, 0, 0.88889],
                "9657": [-0.03472, 0.46528, 0, 0, 0.5],
                "9661": [0.19444, 0.69444, 0, 0, 0.88889],
                "9667": [-0.03472, 0.46528, 0, 0, 0.5],
                "9711": [0.19444, 0.69444, 0, 0, 1],
                "9824": [0.12963, 0.69444, 0, 0, 0.77778],
                "9825": [0.12963, 0.69444, 0, 0, 0.77778],
                "9826": [0.12963, 0.69444, 0, 0, 0.77778],
                "9827": [0.12963, 0.69444, 0, 0, 0.77778],
                "9837": [0, 0.75, 0, 0, 0.38889],
                "9838": [0.19444, 0.69444, 0, 0, 0.38889],
                "9839": [0.19444, 0.69444, 0, 0, 0.38889],
                "10216": [0.25, 0.75, 0, 0, 0.38889],
                "10217": [0.25, 0.75, 0, 0, 0.38889],
                "10222": [0.244, 0.744, 0, 0, 0.412],
                "10223": [0.244, 0.744, 0, 0, 0.412],
                "10229": [0.011, 0.511, 0, 0, 1.609],
                "10230": [0.011, 0.511, 0, 0, 1.638],
                "10231": [0.011, 0.511, 0, 0, 1.859],
                "10232": [0.024, 0.525, 0, 0, 1.609],
                "10233": [0.024, 0.525, 0, 0, 1.638],
                "10234": [0.024, 0.525, 0, 0, 1.858],
                "10236": [0.011, 0.511, 0, 0, 1.638],
                "10815": [0, 0.68333, 0, 0, 0.75],
                "10927": [0.13597, 0.63597, 0, 0, 0.77778],
                "10928": [0.13597, 0.63597, 0, 0, 0.77778],
                "57376": [0.19444, 0.69444, 0, 0, 0]
              },
              "Math-BoldItalic": {
                "65": [0, 0.68611, 0, 0, 0.86944],
                "66": [0, 0.68611, 0.04835, 0, 0.8664],
                "67": [0, 0.68611, 0.06979, 0, 0.81694],
                "68": [0, 0.68611, 0.03194, 0, 0.93812],
                "69": [0, 0.68611, 0.05451, 0, 0.81007],
                "70": [0, 0.68611, 0.15972, 0, 0.68889],
                "71": [0, 0.68611, 0, 0, 0.88673],
                "72": [0, 0.68611, 0.08229, 0, 0.98229],
                "73": [0, 0.68611, 0.07778, 0, 0.51111],
                "74": [0, 0.68611, 0.10069, 0, 0.63125],
                "75": [0, 0.68611, 0.06979, 0, 0.97118],
                "76": [0, 0.68611, 0, 0, 0.75555],
                "77": [0, 0.68611, 0.11424, 0, 1.14201],
                "78": [0, 0.68611, 0.11424, 0, 0.95034],
                "79": [0, 0.68611, 0.03194, 0, 0.83666],
                "80": [0, 0.68611, 0.15972, 0, 0.72309],
                "81": [0.19444, 0.68611, 0, 0, 0.86861],
                "82": [0, 0.68611, 421e-5, 0, 0.87235],
                "83": [0, 0.68611, 0.05382, 0, 0.69271],
                "84": [0, 0.68611, 0.15972, 0, 0.63663],
                "85": [0, 0.68611, 0.11424, 0, 0.80027],
                "86": [0, 0.68611, 0.25555, 0, 0.67778],
                "87": [0, 0.68611, 0.15972, 0, 1.09305],
                "88": [0, 0.68611, 0.07778, 0, 0.94722],
                "89": [0, 0.68611, 0.25555, 0, 0.67458],
                "90": [0, 0.68611, 0.06979, 0, 0.77257],
                "97": [0, 0.44444, 0, 0, 0.63287],
                "98": [0, 0.69444, 0, 0, 0.52083],
                "99": [0, 0.44444, 0, 0, 0.51342],
                "100": [0, 0.69444, 0, 0, 0.60972],
                "101": [0, 0.44444, 0, 0, 0.55361],
                "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
                "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
                "104": [0, 0.69444, 0, 0, 0.66759],
                "105": [0, 0.69326, 0, 0, 0.4048],
                "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
                "107": [0, 0.69444, 0.01852, 0, 0.6037],
                "108": [0, 0.69444, 88e-4, 0, 0.34815],
                "109": [0, 0.44444, 0, 0, 1.0324],
                "110": [0, 0.44444, 0, 0, 0.71296],
                "111": [0, 0.44444, 0, 0, 0.58472],
                "112": [0.19444, 0.44444, 0, 0, 0.60092],
                "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
                "114": [0, 0.44444, 0.03194, 0, 0.5287],
                "115": [0, 0.44444, 0, 0, 0.53125],
                "116": [0, 0.63492, 0, 0, 0.41528],
                "117": [0, 0.44444, 0, 0, 0.68102],
                "118": [0, 0.44444, 0.03704, 0, 0.56666],
                "119": [0, 0.44444, 0.02778, 0, 0.83148],
                "120": [0, 0.44444, 0, 0, 0.65903],
                "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
                "122": [0, 0.44444, 0.04213, 0, 0.55509],
                "915": [0, 0.68611, 0.15972, 0, 0.65694],
                "916": [0, 0.68611, 0, 0, 0.95833],
                "920": [0, 0.68611, 0.03194, 0, 0.86722],
                "923": [0, 0.68611, 0, 0, 0.80555],
                "926": [0, 0.68611, 0.07458, 0, 0.84125],
                "928": [0, 0.68611, 0.08229, 0, 0.98229],
                "931": [0, 0.68611, 0.05451, 0, 0.88507],
                "933": [0, 0.68611, 0.15972, 0, 0.67083],
                "934": [0, 0.68611, 0, 0, 0.76666],
                "936": [0, 0.68611, 0.11653, 0, 0.71402],
                "937": [0, 0.68611, 0.04835, 0, 0.8789],
                "945": [0, 0.44444, 0, 0, 0.76064],
                "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
                "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
                "948": [0, 0.69444, 0.03819, 0, 0.52222],
                "949": [0, 0.44444, 0, 0, 0.52882],
                "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
                "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
                "952": [0, 0.69444, 0.03194, 0, 0.5618],
                "953": [0, 0.44444, 0, 0, 0.41204],
                "954": [0, 0.44444, 0, 0, 0.66759],
                "955": [0, 0.69444, 0, 0, 0.67083],
                "956": [0.19444, 0.44444, 0, 0, 0.70787],
                "957": [0, 0.44444, 0.06898, 0, 0.57685],
                "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
                "959": [0, 0.44444, 0, 0, 0.58472],
                "960": [0, 0.44444, 0.03704, 0, 0.68241],
                "961": [0.19444, 0.44444, 0, 0, 0.6118],
                "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
                "963": [0, 0.44444, 0.03704, 0, 0.68588],
                "964": [0, 0.44444, 0.13472, 0, 0.52083],
                "965": [0, 0.44444, 0.03704, 0, 0.63055],
                "966": [0.19444, 0.44444, 0, 0, 0.74722],
                "967": [0.19444, 0.44444, 0, 0, 0.71805],
                "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
                "969": [0, 0.44444, 0.03704, 0, 0.71782],
                "977": [0, 0.69444, 0, 0, 0.69155],
                "981": [0.19444, 0.69444, 0, 0, 0.7125],
                "982": [0, 0.44444, 0.03194, 0, 0.975],
                "1009": [0.19444, 0.44444, 0, 0, 0.6118],
                "1013": [0, 0.44444, 0, 0, 0.48333]
              },
              "Math-Italic": {
                "65": [0, 0.68333, 0, 0.13889, 0.75],
                "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
                "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
                "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
                "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
                "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
                "71": [0, 0.68333, 0, 0.08334, 0.78625],
                "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
                "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
                "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
                "76": [0, 0.68333, 0, 0.02778, 0.68056],
                "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
                "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
                "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
                "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
                "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
                "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
                "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
                "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
                "86": [0, 0.68333, 0.22222, 0, 0.58333],
                "87": [0, 0.68333, 0.13889, 0, 0.94445],
                "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
                "89": [0, 0.68333, 0.22222, 0, 0.58056],
                "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
                "97": [0, 0.43056, 0, 0, 0.52859],
                "98": [0, 0.69444, 0, 0, 0.42917],
                "99": [0, 0.43056, 0, 0.05556, 0.43276],
                "100": [0, 0.69444, 0, 0.16667, 0.52049],
                "101": [0, 0.43056, 0, 0.05556, 0.46563],
                "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
                "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
                "104": [0, 0.69444, 0, 0, 0.57616],
                "105": [0, 0.65952, 0, 0, 0.34451],
                "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
                "107": [0, 0.69444, 0.03148, 0, 0.5206],
                "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
                "109": [0, 0.43056, 0, 0, 0.87801],
                "110": [0, 0.43056, 0, 0, 0.60023],
                "111": [0, 0.43056, 0, 0.05556, 0.48472],
                "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
                "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
                "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
                "115": [0, 0.43056, 0, 0.05556, 0.46875],
                "116": [0, 0.61508, 0, 0.08334, 0.36111],
                "117": [0, 0.43056, 0, 0.02778, 0.57246],
                "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
                "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
                "120": [0, 0.43056, 0, 0.02778, 0.57153],
                "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
                "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
                "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
                "916": [0, 0.68333, 0, 0.16667, 0.83334],
                "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                "923": [0, 0.68333, 0, 0.16667, 0.69445],
                "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
                "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
                "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
                "934": [0, 0.68333, 0, 0.08334, 0.66667],
                "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
                "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
                "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
                "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
                "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
                "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
                "949": [0, 0.43056, 0, 0.08334, 0.46632],
                "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
                "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
                "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
                "953": [0, 0.43056, 0, 0.05556, 0.35394],
                "954": [0, 0.43056, 0, 0, 0.57616],
                "955": [0, 0.69444, 0, 0, 0.58334],
                "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
                "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
                "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
                "959": [0, 0.43056, 0, 0.05556, 0.48472],
                "960": [0, 0.43056, 0.03588, 0, 0.57003],
                "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
                "963": [0, 0.43056, 0.03588, 0, 0.57141],
                "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
                "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
                "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
                "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
                "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
                "969": [0, 0.43056, 0.03588, 0, 0.62245],
                "977": [0, 0.69444, 0, 0.08334, 0.59144],
                "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
                "982": [0, 0.43056, 0.02778, 0, 0.82813],
                "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                "1013": [0, 0.43056, 0, 0.05556, 0.4059]
              },
              "Math-Regular": {
                "65": [0, 0.68333, 0, 0.13889, 0.75],
                "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
                "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
                "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
                "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
                "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
                "71": [0, 0.68333, 0, 0.08334, 0.78625],
                "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
                "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
                "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
                "76": [0, 0.68333, 0, 0.02778, 0.68056],
                "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
                "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
                "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
                "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
                "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
                "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
                "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
                "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
                "86": [0, 0.68333, 0.22222, 0, 0.58333],
                "87": [0, 0.68333, 0.13889, 0, 0.94445],
                "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
                "89": [0, 0.68333, 0.22222, 0, 0.58056],
                "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
                "97": [0, 0.43056, 0, 0, 0.52859],
                "98": [0, 0.69444, 0, 0, 0.42917],
                "99": [0, 0.43056, 0, 0.05556, 0.43276],
                "100": [0, 0.69444, 0, 0.16667, 0.52049],
                "101": [0, 0.43056, 0, 0.05556, 0.46563],
                "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
                "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
                "104": [0, 0.69444, 0, 0, 0.57616],
                "105": [0, 0.65952, 0, 0, 0.34451],
                "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
                "107": [0, 0.69444, 0.03148, 0, 0.5206],
                "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
                "109": [0, 0.43056, 0, 0, 0.87801],
                "110": [0, 0.43056, 0, 0, 0.60023],
                "111": [0, 0.43056, 0, 0.05556, 0.48472],
                "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
                "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
                "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
                "115": [0, 0.43056, 0, 0.05556, 0.46875],
                "116": [0, 0.61508, 0, 0.08334, 0.36111],
                "117": [0, 0.43056, 0, 0.02778, 0.57246],
                "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
                "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
                "120": [0, 0.43056, 0, 0.02778, 0.57153],
                "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
                "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
                "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
                "916": [0, 0.68333, 0, 0.16667, 0.83334],
                "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
                "923": [0, 0.68333, 0, 0.16667, 0.69445],
                "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
                "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
                "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
                "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
                "934": [0, 0.68333, 0, 0.08334, 0.66667],
                "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
                "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
                "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
                "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
                "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
                "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
                "949": [0, 0.43056, 0, 0.08334, 0.46632],
                "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
                "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
                "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
                "953": [0, 0.43056, 0, 0.05556, 0.35394],
                "954": [0, 0.43056, 0, 0, 0.57616],
                "955": [0, 0.69444, 0, 0, 0.58334],
                "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
                "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
                "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
                "959": [0, 0.43056, 0, 0.05556, 0.48472],
                "960": [0, 0.43056, 0.03588, 0, 0.57003],
                "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
                "963": [0, 0.43056, 0.03588, 0, 0.57141],
                "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
                "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
                "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
                "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
                "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
                "969": [0, 0.43056, 0.03588, 0, 0.62245],
                "977": [0, 0.69444, 0, 0.08334, 0.59144],
                "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
                "982": [0, 0.43056, 0.02778, 0, 0.82813],
                "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
                "1013": [0, 0.43056, 0, 0.05556, 0.4059]
              },
              "SansSerif-Bold": {
                "33": [0, 0.69444, 0, 0, 0.36667],
                "34": [0, 0.69444, 0, 0, 0.55834],
                "35": [0.19444, 0.69444, 0, 0, 0.91667],
                "36": [0.05556, 0.75, 0, 0, 0.55],
                "37": [0.05556, 0.75, 0, 0, 1.02912],
                "38": [0, 0.69444, 0, 0, 0.83056],
                "39": [0, 0.69444, 0, 0, 0.30556],
                "40": [0.25, 0.75, 0, 0, 0.42778],
                "41": [0.25, 0.75, 0, 0, 0.42778],
                "42": [0, 0.75, 0, 0, 0.55],
                "43": [0.11667, 0.61667, 0, 0, 0.85556],
                "44": [0.10556, 0.13056, 0, 0, 0.30556],
                "45": [0, 0.45833, 0, 0, 0.36667],
                "46": [0, 0.13056, 0, 0, 0.30556],
                "47": [0.25, 0.75, 0, 0, 0.55],
                "48": [0, 0.69444, 0, 0, 0.55],
                "49": [0, 0.69444, 0, 0, 0.55],
                "50": [0, 0.69444, 0, 0, 0.55],
                "51": [0, 0.69444, 0, 0, 0.55],
                "52": [0, 0.69444, 0, 0, 0.55],
                "53": [0, 0.69444, 0, 0, 0.55],
                "54": [0, 0.69444, 0, 0, 0.55],
                "55": [0, 0.69444, 0, 0, 0.55],
                "56": [0, 0.69444, 0, 0, 0.55],
                "57": [0, 0.69444, 0, 0, 0.55],
                "58": [0, 0.45833, 0, 0, 0.30556],
                "59": [0.10556, 0.45833, 0, 0, 0.30556],
                "61": [-0.09375, 0.40625, 0, 0, 0.85556],
                "63": [0, 0.69444, 0, 0, 0.51945],
                "64": [0, 0.69444, 0, 0, 0.73334],
                "65": [0, 0.69444, 0, 0, 0.73334],
                "66": [0, 0.69444, 0, 0, 0.73334],
                "67": [0, 0.69444, 0, 0, 0.70278],
                "68": [0, 0.69444, 0, 0, 0.79445],
                "69": [0, 0.69444, 0, 0, 0.64167],
                "70": [0, 0.69444, 0, 0, 0.61111],
                "71": [0, 0.69444, 0, 0, 0.73334],
                "72": [0, 0.69444, 0, 0, 0.79445],
                "73": [0, 0.69444, 0, 0, 0.33056],
                "74": [0, 0.69444, 0, 0, 0.51945],
                "75": [0, 0.69444, 0, 0, 0.76389],
                "76": [0, 0.69444, 0, 0, 0.58056],
                "77": [0, 0.69444, 0, 0, 0.97778],
                "78": [0, 0.69444, 0, 0, 0.79445],
                "79": [0, 0.69444, 0, 0, 0.79445],
                "80": [0, 0.69444, 0, 0, 0.70278],
                "81": [0.10556, 0.69444, 0, 0, 0.79445],
                "82": [0, 0.69444, 0, 0, 0.70278],
                "83": [0, 0.69444, 0, 0, 0.61111],
                "84": [0, 0.69444, 0, 0, 0.73334],
                "85": [0, 0.69444, 0, 0, 0.76389],
                "86": [0, 0.69444, 0.01528, 0, 0.73334],
                "87": [0, 0.69444, 0.01528, 0, 1.03889],
                "88": [0, 0.69444, 0, 0, 0.73334],
                "89": [0, 0.69444, 0.0275, 0, 0.73334],
                "90": [0, 0.69444, 0, 0, 0.67223],
                "91": [0.25, 0.75, 0, 0, 0.34306],
                "93": [0.25, 0.75, 0, 0, 0.34306],
                "94": [0, 0.69444, 0, 0, 0.55],
                "95": [0.35, 0.10833, 0.03056, 0, 0.55],
                "97": [0, 0.45833, 0, 0, 0.525],
                "98": [0, 0.69444, 0, 0, 0.56111],
                "99": [0, 0.45833, 0, 0, 0.48889],
                "100": [0, 0.69444, 0, 0, 0.56111],
                "101": [0, 0.45833, 0, 0, 0.51111],
                "102": [0, 0.69444, 0.07639, 0, 0.33611],
                "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
                "104": [0, 0.69444, 0, 0, 0.56111],
                "105": [0, 0.69444, 0, 0, 0.25556],
                "106": [0.19444, 0.69444, 0, 0, 0.28611],
                "107": [0, 0.69444, 0, 0, 0.53056],
                "108": [0, 0.69444, 0, 0, 0.25556],
                "109": [0, 0.45833, 0, 0, 0.86667],
                "110": [0, 0.45833, 0, 0, 0.56111],
                "111": [0, 0.45833, 0, 0, 0.55],
                "112": [0.19444, 0.45833, 0, 0, 0.56111],
                "113": [0.19444, 0.45833, 0, 0, 0.56111],
                "114": [0, 0.45833, 0.01528, 0, 0.37222],
                "115": [0, 0.45833, 0, 0, 0.42167],
                "116": [0, 0.58929, 0, 0, 0.40417],
                "117": [0, 0.45833, 0, 0, 0.56111],
                "118": [0, 0.45833, 0.01528, 0, 0.5],
                "119": [0, 0.45833, 0.01528, 0, 0.74445],
                "120": [0, 0.45833, 0, 0, 0.5],
                "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
                "122": [0, 0.45833, 0, 0, 0.47639],
                "126": [0.35, 0.34444, 0, 0, 0.55],
                "168": [0, 0.69444, 0, 0, 0.55],
                "176": [0, 0.69444, 0, 0, 0.73334],
                "180": [0, 0.69444, 0, 0, 0.55],
                "184": [0.17014, 0, 0, 0, 0.48889],
                "305": [0, 0.45833, 0, 0, 0.25556],
                "567": [0.19444, 0.45833, 0, 0, 0.28611],
                "710": [0, 0.69444, 0, 0, 0.55],
                "711": [0, 0.63542, 0, 0, 0.55],
                "713": [0, 0.63778, 0, 0, 0.55],
                "728": [0, 0.69444, 0, 0, 0.55],
                "729": [0, 0.69444, 0, 0, 0.30556],
                "730": [0, 0.69444, 0, 0, 0.73334],
                "732": [0, 0.69444, 0, 0, 0.55],
                "733": [0, 0.69444, 0, 0, 0.55],
                "915": [0, 0.69444, 0, 0, 0.58056],
                "916": [0, 0.69444, 0, 0, 0.91667],
                "920": [0, 0.69444, 0, 0, 0.85556],
                "923": [0, 0.69444, 0, 0, 0.67223],
                "926": [0, 0.69444, 0, 0, 0.73334],
                "928": [0, 0.69444, 0, 0, 0.79445],
                "931": [0, 0.69444, 0, 0, 0.79445],
                "933": [0, 0.69444, 0, 0, 0.85556],
                "934": [0, 0.69444, 0, 0, 0.79445],
                "936": [0, 0.69444, 0, 0, 0.85556],
                "937": [0, 0.69444, 0, 0, 0.79445],
                "8211": [0, 0.45833, 0.03056, 0, 0.55],
                "8212": [0, 0.45833, 0.03056, 0, 1.10001],
                "8216": [0, 0.69444, 0, 0, 0.30556],
                "8217": [0, 0.69444, 0, 0, 0.30556],
                "8220": [0, 0.69444, 0, 0, 0.55834],
                "8221": [0, 0.69444, 0, 0, 0.55834]
              },
              "SansSerif-Italic": {
                "33": [0, 0.69444, 0.05733, 0, 0.31945],
                "34": [0, 0.69444, 316e-5, 0, 0.5],
                "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
                "36": [0.05556, 0.75, 0.11156, 0, 0.5],
                "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
                "38": [0, 0.69444, 0.03058, 0, 0.75834],
                "39": [0, 0.69444, 0.07816, 0, 0.27778],
                "40": [0.25, 0.75, 0.13164, 0, 0.38889],
                "41": [0.25, 0.75, 0.02536, 0, 0.38889],
                "42": [0, 0.75, 0.11775, 0, 0.5],
                "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
                "44": [0.125, 0.08333, 0, 0, 0.27778],
                "45": [0, 0.44444, 0.01946, 0, 0.33333],
                "46": [0, 0.08333, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0.13164, 0, 0.5],
                "48": [0, 0.65556, 0.11156, 0, 0.5],
                "49": [0, 0.65556, 0.11156, 0, 0.5],
                "50": [0, 0.65556, 0.11156, 0, 0.5],
                "51": [0, 0.65556, 0.11156, 0, 0.5],
                "52": [0, 0.65556, 0.11156, 0, 0.5],
                "53": [0, 0.65556, 0.11156, 0, 0.5],
                "54": [0, 0.65556, 0.11156, 0, 0.5],
                "55": [0, 0.65556, 0.11156, 0, 0.5],
                "56": [0, 0.65556, 0.11156, 0, 0.5],
                "57": [0, 0.65556, 0.11156, 0, 0.5],
                "58": [0, 0.44444, 0.02502, 0, 0.27778],
                "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
                "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
                "63": [0, 0.69444, 0.11809, 0, 0.47222],
                "64": [0, 0.69444, 0.07555, 0, 0.66667],
                "65": [0, 0.69444, 0, 0, 0.66667],
                "66": [0, 0.69444, 0.08293, 0, 0.66667],
                "67": [0, 0.69444, 0.11983, 0, 0.63889],
                "68": [0, 0.69444, 0.07555, 0, 0.72223],
                "69": [0, 0.69444, 0.11983, 0, 0.59722],
                "70": [0, 0.69444, 0.13372, 0, 0.56945],
                "71": [0, 0.69444, 0.11983, 0, 0.66667],
                "72": [0, 0.69444, 0.08094, 0, 0.70834],
                "73": [0, 0.69444, 0.13372, 0, 0.27778],
                "74": [0, 0.69444, 0.08094, 0, 0.47222],
                "75": [0, 0.69444, 0.11983, 0, 0.69445],
                "76": [0, 0.69444, 0, 0, 0.54167],
                "77": [0, 0.69444, 0.08094, 0, 0.875],
                "78": [0, 0.69444, 0.08094, 0, 0.70834],
                "79": [0, 0.69444, 0.07555, 0, 0.73611],
                "80": [0, 0.69444, 0.08293, 0, 0.63889],
                "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
                "82": [0, 0.69444, 0.08293, 0, 0.64584],
                "83": [0, 0.69444, 0.09205, 0, 0.55556],
                "84": [0, 0.69444, 0.13372, 0, 0.68056],
                "85": [0, 0.69444, 0.08094, 0, 0.6875],
                "86": [0, 0.69444, 0.1615, 0, 0.66667],
                "87": [0, 0.69444, 0.1615, 0, 0.94445],
                "88": [0, 0.69444, 0.13372, 0, 0.66667],
                "89": [0, 0.69444, 0.17261, 0, 0.66667],
                "90": [0, 0.69444, 0.11983, 0, 0.61111],
                "91": [0.25, 0.75, 0.15942, 0, 0.28889],
                "93": [0.25, 0.75, 0.08719, 0, 0.28889],
                "94": [0, 0.69444, 0.0799, 0, 0.5],
                "95": [0.35, 0.09444, 0.08616, 0, 0.5],
                "97": [0, 0.44444, 981e-5, 0, 0.48056],
                "98": [0, 0.69444, 0.03057, 0, 0.51667],
                "99": [0, 0.44444, 0.08336, 0, 0.44445],
                "100": [0, 0.69444, 0.09483, 0, 0.51667],
                "101": [0, 0.44444, 0.06778, 0, 0.44445],
                "102": [0, 0.69444, 0.21705, 0, 0.30556],
                "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
                "104": [0, 0.69444, 0.01778, 0, 0.51667],
                "105": [0, 0.67937, 0.09718, 0, 0.23889],
                "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
                "107": [0, 0.69444, 0.08336, 0, 0.48889],
                "108": [0, 0.69444, 0.09483, 0, 0.23889],
                "109": [0, 0.44444, 0.01778, 0, 0.79445],
                "110": [0, 0.44444, 0.01778, 0, 0.51667],
                "111": [0, 0.44444, 0.06613, 0, 0.5],
                "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
                "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
                "114": [0, 0.44444, 0.10836, 0, 0.34167],
                "115": [0, 0.44444, 0.0778, 0, 0.38333],
                "116": [0, 0.57143, 0.07225, 0, 0.36111],
                "117": [0, 0.44444, 0.04169, 0, 0.51667],
                "118": [0, 0.44444, 0.10836, 0, 0.46111],
                "119": [0, 0.44444, 0.10836, 0, 0.68334],
                "120": [0, 0.44444, 0.09169, 0, 0.46111],
                "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
                "122": [0, 0.44444, 0.08752, 0, 0.43472],
                "126": [0.35, 0.32659, 0.08826, 0, 0.5],
                "168": [0, 0.67937, 0.06385, 0, 0.5],
                "176": [0, 0.69444, 0, 0, 0.73752],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "305": [0, 0.44444, 0.04169, 0, 0.23889],
                "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
                "710": [0, 0.69444, 0.0799, 0, 0.5],
                "711": [0, 0.63194, 0.08432, 0, 0.5],
                "713": [0, 0.60889, 0.08776, 0, 0.5],
                "714": [0, 0.69444, 0.09205, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0.09483, 0, 0.5],
                "729": [0, 0.67937, 0.07774, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.73752],
                "732": [0, 0.67659, 0.08826, 0, 0.5],
                "733": [0, 0.69444, 0.09205, 0, 0.5],
                "915": [0, 0.69444, 0.13372, 0, 0.54167],
                "916": [0, 0.69444, 0, 0, 0.83334],
                "920": [0, 0.69444, 0.07555, 0, 0.77778],
                "923": [0, 0.69444, 0, 0, 0.61111],
                "926": [0, 0.69444, 0.12816, 0, 0.66667],
                "928": [0, 0.69444, 0.08094, 0, 0.70834],
                "931": [0, 0.69444, 0.11983, 0, 0.72222],
                "933": [0, 0.69444, 0.09031, 0, 0.77778],
                "934": [0, 0.69444, 0.04603, 0, 0.72222],
                "936": [0, 0.69444, 0.09031, 0, 0.77778],
                "937": [0, 0.69444, 0.08293, 0, 0.72222],
                "8211": [0, 0.44444, 0.08616, 0, 0.5],
                "8212": [0, 0.44444, 0.08616, 0, 1],
                "8216": [0, 0.69444, 0.07816, 0, 0.27778],
                "8217": [0, 0.69444, 0.07816, 0, 0.27778],
                "8220": [0, 0.69444, 0.14205, 0, 0.5],
                "8221": [0, 0.69444, 316e-5, 0, 0.5]
              },
              "SansSerif-Regular": {
                "33": [0, 0.69444, 0, 0, 0.31945],
                "34": [0, 0.69444, 0, 0, 0.5],
                "35": [0.19444, 0.69444, 0, 0, 0.83334],
                "36": [0.05556, 0.75, 0, 0, 0.5],
                "37": [0.05556, 0.75, 0, 0, 0.83334],
                "38": [0, 0.69444, 0, 0, 0.75834],
                "39": [0, 0.69444, 0, 0, 0.27778],
                "40": [0.25, 0.75, 0, 0, 0.38889],
                "41": [0.25, 0.75, 0, 0, 0.38889],
                "42": [0, 0.75, 0, 0, 0.5],
                "43": [0.08333, 0.58333, 0, 0, 0.77778],
                "44": [0.125, 0.08333, 0, 0, 0.27778],
                "45": [0, 0.44444, 0, 0, 0.33333],
                "46": [0, 0.08333, 0, 0, 0.27778],
                "47": [0.25, 0.75, 0, 0, 0.5],
                "48": [0, 0.65556, 0, 0, 0.5],
                "49": [0, 0.65556, 0, 0, 0.5],
                "50": [0, 0.65556, 0, 0, 0.5],
                "51": [0, 0.65556, 0, 0, 0.5],
                "52": [0, 0.65556, 0, 0, 0.5],
                "53": [0, 0.65556, 0, 0, 0.5],
                "54": [0, 0.65556, 0, 0, 0.5],
                "55": [0, 0.65556, 0, 0, 0.5],
                "56": [0, 0.65556, 0, 0, 0.5],
                "57": [0, 0.65556, 0, 0, 0.5],
                "58": [0, 0.44444, 0, 0, 0.27778],
                "59": [0.125, 0.44444, 0, 0, 0.27778],
                "61": [-0.13, 0.37, 0, 0, 0.77778],
                "63": [0, 0.69444, 0, 0, 0.47222],
                "64": [0, 0.69444, 0, 0, 0.66667],
                "65": [0, 0.69444, 0, 0, 0.66667],
                "66": [0, 0.69444, 0, 0, 0.66667],
                "67": [0, 0.69444, 0, 0, 0.63889],
                "68": [0, 0.69444, 0, 0, 0.72223],
                "69": [0, 0.69444, 0, 0, 0.59722],
                "70": [0, 0.69444, 0, 0, 0.56945],
                "71": [0, 0.69444, 0, 0, 0.66667],
                "72": [0, 0.69444, 0, 0, 0.70834],
                "73": [0, 0.69444, 0, 0, 0.27778],
                "74": [0, 0.69444, 0, 0, 0.47222],
                "75": [0, 0.69444, 0, 0, 0.69445],
                "76": [0, 0.69444, 0, 0, 0.54167],
                "77": [0, 0.69444, 0, 0, 0.875],
                "78": [0, 0.69444, 0, 0, 0.70834],
                "79": [0, 0.69444, 0, 0, 0.73611],
                "80": [0, 0.69444, 0, 0, 0.63889],
                "81": [0.125, 0.69444, 0, 0, 0.73611],
                "82": [0, 0.69444, 0, 0, 0.64584],
                "83": [0, 0.69444, 0, 0, 0.55556],
                "84": [0, 0.69444, 0, 0, 0.68056],
                "85": [0, 0.69444, 0, 0, 0.6875],
                "86": [0, 0.69444, 0.01389, 0, 0.66667],
                "87": [0, 0.69444, 0.01389, 0, 0.94445],
                "88": [0, 0.69444, 0, 0, 0.66667],
                "89": [0, 0.69444, 0.025, 0, 0.66667],
                "90": [0, 0.69444, 0, 0, 0.61111],
                "91": [0.25, 0.75, 0, 0, 0.28889],
                "93": [0.25, 0.75, 0, 0, 0.28889],
                "94": [0, 0.69444, 0, 0, 0.5],
                "95": [0.35, 0.09444, 0.02778, 0, 0.5],
                "97": [0, 0.44444, 0, 0, 0.48056],
                "98": [0, 0.69444, 0, 0, 0.51667],
                "99": [0, 0.44444, 0, 0, 0.44445],
                "100": [0, 0.69444, 0, 0, 0.51667],
                "101": [0, 0.44444, 0, 0, 0.44445],
                "102": [0, 0.69444, 0.06944, 0, 0.30556],
                "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
                "104": [0, 0.69444, 0, 0, 0.51667],
                "105": [0, 0.67937, 0, 0, 0.23889],
                "106": [0.19444, 0.67937, 0, 0, 0.26667],
                "107": [0, 0.69444, 0, 0, 0.48889],
                "108": [0, 0.69444, 0, 0, 0.23889],
                "109": [0, 0.44444, 0, 0, 0.79445],
                "110": [0, 0.44444, 0, 0, 0.51667],
                "111": [0, 0.44444, 0, 0, 0.5],
                "112": [0.19444, 0.44444, 0, 0, 0.51667],
                "113": [0.19444, 0.44444, 0, 0, 0.51667],
                "114": [0, 0.44444, 0.01389, 0, 0.34167],
                "115": [0, 0.44444, 0, 0, 0.38333],
                "116": [0, 0.57143, 0, 0, 0.36111],
                "117": [0, 0.44444, 0, 0, 0.51667],
                "118": [0, 0.44444, 0.01389, 0, 0.46111],
                "119": [0, 0.44444, 0.01389, 0, 0.68334],
                "120": [0, 0.44444, 0, 0, 0.46111],
                "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
                "122": [0, 0.44444, 0, 0, 0.43472],
                "126": [0.35, 0.32659, 0, 0, 0.5],
                "168": [0, 0.67937, 0, 0, 0.5],
                "176": [0, 0.69444, 0, 0, 0.66667],
                "184": [0.17014, 0, 0, 0, 0.44445],
                "305": [0, 0.44444, 0, 0, 0.23889],
                "567": [0.19444, 0.44444, 0, 0, 0.26667],
                "710": [0, 0.69444, 0, 0, 0.5],
                "711": [0, 0.63194, 0, 0, 0.5],
                "713": [0, 0.60889, 0, 0, 0.5],
                "714": [0, 0.69444, 0, 0, 0.5],
                "715": [0, 0.69444, 0, 0, 0.5],
                "728": [0, 0.69444, 0, 0, 0.5],
                "729": [0, 0.67937, 0, 0, 0.27778],
                "730": [0, 0.69444, 0, 0, 0.66667],
                "732": [0, 0.67659, 0, 0, 0.5],
                "733": [0, 0.69444, 0, 0, 0.5],
                "915": [0, 0.69444, 0, 0, 0.54167],
                "916": [0, 0.69444, 0, 0, 0.83334],
                "920": [0, 0.69444, 0, 0, 0.77778],
                "923": [0, 0.69444, 0, 0, 0.61111],
                "926": [0, 0.69444, 0, 0, 0.66667],
                "928": [0, 0.69444, 0, 0, 0.70834],
                "931": [0, 0.69444, 0, 0, 0.72222],
                "933": [0, 0.69444, 0, 0, 0.77778],
                "934": [0, 0.69444, 0, 0, 0.72222],
                "936": [0, 0.69444, 0, 0, 0.77778],
                "937": [0, 0.69444, 0, 0, 0.72222],
                "8211": [0, 0.44444, 0.02778, 0, 0.5],
                "8212": [0, 0.44444, 0.02778, 0, 1],
                "8216": [0, 0.69444, 0, 0, 0.27778],
                "8217": [0, 0.69444, 0, 0, 0.27778],
                "8220": [0, 0.69444, 0, 0, 0.5],
                "8221": [0, 0.69444, 0, 0, 0.5]
              },
              "Script-Regular": {
                "65": [0, 0.7, 0.22925, 0, 0.80253],
                "66": [0, 0.7, 0.04087, 0, 0.90757],
                "67": [0, 0.7, 0.1689, 0, 0.66619],
                "68": [0, 0.7, 0.09371, 0, 0.77443],
                "69": [0, 0.7, 0.18583, 0, 0.56162],
                "70": [0, 0.7, 0.13634, 0, 0.89544],
                "71": [0, 0.7, 0.17322, 0, 0.60961],
                "72": [0, 0.7, 0.29694, 0, 0.96919],
                "73": [0, 0.7, 0.19189, 0, 0.80907],
                "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
                "75": [0, 0.7, 0.31259, 0, 0.91364],
                "76": [0, 0.7, 0.19189, 0, 0.87373],
                "77": [0, 0.7, 0.15981, 0, 1.08031],
                "78": [0, 0.7, 0.3525, 0, 0.9015],
                "79": [0, 0.7, 0.08078, 0, 0.73787],
                "80": [0, 0.7, 0.08078, 0, 1.01262],
                "81": [0, 0.7, 0.03305, 0, 0.88282],
                "82": [0, 0.7, 0.06259, 0, 0.85],
                "83": [0, 0.7, 0.19189, 0, 0.86767],
                "84": [0, 0.7, 0.29087, 0, 0.74697],
                "85": [0, 0.7, 0.25815, 0, 0.79996],
                "86": [0, 0.7, 0.27523, 0, 0.62204],
                "87": [0, 0.7, 0.27523, 0, 0.80532],
                "88": [0, 0.7, 0.26006, 0, 0.94445],
                "89": [0, 0.7, 0.2939, 0, 0.70961],
                "90": [0, 0.7, 0.24037, 0, 0.8212]
              },
              "Size1-Regular": {
                "40": [0.35001, 0.85, 0, 0, 0.45834],
                "41": [0.35001, 0.85, 0, 0, 0.45834],
                "47": [0.35001, 0.85, 0, 0, 0.57778],
                "91": [0.35001, 0.85, 0, 0, 0.41667],
                "92": [0.35001, 0.85, 0, 0, 0.57778],
                "93": [0.35001, 0.85, 0, 0, 0.41667],
                "123": [0.35001, 0.85, 0, 0, 0.58334],
                "125": [0.35001, 0.85, 0, 0, 0.58334],
                "710": [0, 0.72222, 0, 0, 0.55556],
                "732": [0, 0.72222, 0, 0, 0.55556],
                "770": [0, 0.72222, 0, 0, 0.55556],
                "771": [0, 0.72222, 0, 0, 0.55556],
                "8214": [-99e-5, 0.601, 0, 0, 0.77778],
                "8593": [1e-5, 0.6, 0, 0, 0.66667],
                "8595": [1e-5, 0.6, 0, 0, 0.66667],
                "8657": [1e-5, 0.6, 0, 0, 0.77778],
                "8659": [1e-5, 0.6, 0, 0, 0.77778],
                "8719": [0.25001, 0.75, 0, 0, 0.94445],
                "8720": [0.25001, 0.75, 0, 0, 0.94445],
                "8721": [0.25001, 0.75, 0, 0, 1.05556],
                "8730": [0.35001, 0.85, 0, 0, 1],
                "8739": [-599e-5, 0.606, 0, 0, 0.33333],
                "8741": [-599e-5, 0.606, 0, 0, 0.55556],
                "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
                "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
                "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
                "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
                "8896": [0.25001, 0.75, 0, 0, 0.83334],
                "8897": [0.25001, 0.75, 0, 0, 0.83334],
                "8898": [0.25001, 0.75, 0, 0, 0.83334],
                "8899": [0.25001, 0.75, 0, 0, 0.83334],
                "8968": [0.35001, 0.85, 0, 0, 0.47222],
                "8969": [0.35001, 0.85, 0, 0, 0.47222],
                "8970": [0.35001, 0.85, 0, 0, 0.47222],
                "8971": [0.35001, 0.85, 0, 0, 0.47222],
                "9168": [-99e-5, 0.601, 0, 0, 0.66667],
                "10216": [0.35001, 0.85, 0, 0, 0.47222],
                "10217": [0.35001, 0.85, 0, 0, 0.47222],
                "10752": [0.25001, 0.75, 0, 0, 1.11111],
                "10753": [0.25001, 0.75, 0, 0, 1.11111],
                "10754": [0.25001, 0.75, 0, 0, 1.11111],
                "10756": [0.25001, 0.75, 0, 0, 0.83334],
                "10758": [0.25001, 0.75, 0, 0, 0.83334]
              },
              "Size2-Regular": {
                "40": [0.65002, 1.15, 0, 0, 0.59722],
                "41": [0.65002, 1.15, 0, 0, 0.59722],
                "47": [0.65002, 1.15, 0, 0, 0.81111],
                "91": [0.65002, 1.15, 0, 0, 0.47222],
                "92": [0.65002, 1.15, 0, 0, 0.81111],
                "93": [0.65002, 1.15, 0, 0, 0.47222],
                "123": [0.65002, 1.15, 0, 0, 0.66667],
                "125": [0.65002, 1.15, 0, 0, 0.66667],
                "710": [0, 0.75, 0, 0, 1],
                "732": [0, 0.75, 0, 0, 1],
                "770": [0, 0.75, 0, 0, 1],
                "771": [0, 0.75, 0, 0, 1],
                "8719": [0.55001, 1.05, 0, 0, 1.27778],
                "8720": [0.55001, 1.05, 0, 0, 1.27778],
                "8721": [0.55001, 1.05, 0, 0, 1.44445],
                "8730": [0.65002, 1.15, 0, 0, 1],
                "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
                "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
                "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
                "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
                "8896": [0.55001, 1.05, 0, 0, 1.11111],
                "8897": [0.55001, 1.05, 0, 0, 1.11111],
                "8898": [0.55001, 1.05, 0, 0, 1.11111],
                "8899": [0.55001, 1.05, 0, 0, 1.11111],
                "8968": [0.65002, 1.15, 0, 0, 0.52778],
                "8969": [0.65002, 1.15, 0, 0, 0.52778],
                "8970": [0.65002, 1.15, 0, 0, 0.52778],
                "8971": [0.65002, 1.15, 0, 0, 0.52778],
                "10216": [0.65002, 1.15, 0, 0, 0.61111],
                "10217": [0.65002, 1.15, 0, 0, 0.61111],
                "10752": [0.55001, 1.05, 0, 0, 1.51112],
                "10753": [0.55001, 1.05, 0, 0, 1.51112],
                "10754": [0.55001, 1.05, 0, 0, 1.51112],
                "10756": [0.55001, 1.05, 0, 0, 1.11111],
                "10758": [0.55001, 1.05, 0, 0, 1.11111]
              },
              "Size3-Regular": {
                "40": [0.95003, 1.45, 0, 0, 0.73611],
                "41": [0.95003, 1.45, 0, 0, 0.73611],
                "47": [0.95003, 1.45, 0, 0, 1.04445],
                "91": [0.95003, 1.45, 0, 0, 0.52778],
                "92": [0.95003, 1.45, 0, 0, 1.04445],
                "93": [0.95003, 1.45, 0, 0, 0.52778],
                "123": [0.95003, 1.45, 0, 0, 0.75],
                "125": [0.95003, 1.45, 0, 0, 0.75],
                "710": [0, 0.75, 0, 0, 1.44445],
                "732": [0, 0.75, 0, 0, 1.44445],
                "770": [0, 0.75, 0, 0, 1.44445],
                "771": [0, 0.75, 0, 0, 1.44445],
                "8730": [0.95003, 1.45, 0, 0, 1],
                "8968": [0.95003, 1.45, 0, 0, 0.58334],
                "8969": [0.95003, 1.45, 0, 0, 0.58334],
                "8970": [0.95003, 1.45, 0, 0, 0.58334],
                "8971": [0.95003, 1.45, 0, 0, 0.58334],
                "10216": [0.95003, 1.45, 0, 0, 0.75],
                "10217": [0.95003, 1.45, 0, 0, 0.75]
              },
              "Size4-Regular": {
                "40": [1.25003, 1.75, 0, 0, 0.79167],
                "41": [1.25003, 1.75, 0, 0, 0.79167],
                "47": [1.25003, 1.75, 0, 0, 1.27778],
                "91": [1.25003, 1.75, 0, 0, 0.58334],
                "92": [1.25003, 1.75, 0, 0, 1.27778],
                "93": [1.25003, 1.75, 0, 0, 0.58334],
                "123": [1.25003, 1.75, 0, 0, 0.80556],
                "125": [1.25003, 1.75, 0, 0, 0.80556],
                "710": [0, 0.825, 0, 0, 1.8889],
                "732": [0, 0.825, 0, 0, 1.8889],
                "770": [0, 0.825, 0, 0, 1.8889],
                "771": [0, 0.825, 0, 0, 1.8889],
                "8730": [1.25003, 1.75, 0, 0, 1],
                "8968": [1.25003, 1.75, 0, 0, 0.63889],
                "8969": [1.25003, 1.75, 0, 0, 0.63889],
                "8970": [1.25003, 1.75, 0, 0, 0.63889],
                "8971": [1.25003, 1.75, 0, 0, 0.63889],
                "9115": [0.64502, 1.155, 0, 0, 0.875],
                "9116": [1e-5, 0.6, 0, 0, 0.875],
                "9117": [0.64502, 1.155, 0, 0, 0.875],
                "9118": [0.64502, 1.155, 0, 0, 0.875],
                "9119": [1e-5, 0.6, 0, 0, 0.875],
                "9120": [0.64502, 1.155, 0, 0, 0.875],
                "9121": [0.64502, 1.155, 0, 0, 0.66667],
                "9122": [-99e-5, 0.601, 0, 0, 0.66667],
                "9123": [0.64502, 1.155, 0, 0, 0.66667],
                "9124": [0.64502, 1.155, 0, 0, 0.66667],
                "9125": [-99e-5, 0.601, 0, 0, 0.66667],
                "9126": [0.64502, 1.155, 0, 0, 0.66667],
                "9127": [1e-5, 0.9, 0, 0, 0.88889],
                "9128": [0.65002, 1.15, 0, 0, 0.88889],
                "9129": [0.90001, 0, 0, 0, 0.88889],
                "9130": [0, 0.3, 0, 0, 0.88889],
                "9131": [1e-5, 0.9, 0, 0, 0.88889],
                "9132": [0.65002, 1.15, 0, 0, 0.88889],
                "9133": [0.90001, 0, 0, 0, 0.88889],
                "9143": [0.88502, 0.915, 0, 0, 1.05556],
                "10216": [1.25003, 1.75, 0, 0, 0.80556],
                "10217": [1.25003, 1.75, 0, 0, 0.80556],
                "57344": [-499e-5, 0.605, 0, 0, 1.05556],
                "57345": [-499e-5, 0.605, 0, 0, 1.05556],
                "57680": [0, 0.12, 0, 0, 0.45],
                "57681": [0, 0.12, 0, 0, 0.45],
                "57682": [0, 0.12, 0, 0, 0.45],
                "57683": [0, 0.12, 0, 0, 0.45]
              },
              "Typewriter-Regular": {
                "32": [0, 0, 0, 0, 0.525],
                "33": [0, 0.61111, 0, 0, 0.525],
                "34": [0, 0.61111, 0, 0, 0.525],
                "35": [0, 0.61111, 0, 0, 0.525],
                "36": [0.08333, 0.69444, 0, 0, 0.525],
                "37": [0.08333, 0.69444, 0, 0, 0.525],
                "38": [0, 0.61111, 0, 0, 0.525],
                "39": [0, 0.61111, 0, 0, 0.525],
                "40": [0.08333, 0.69444, 0, 0, 0.525],
                "41": [0.08333, 0.69444, 0, 0, 0.525],
                "42": [0, 0.52083, 0, 0, 0.525],
                "43": [-0.08056, 0.53055, 0, 0, 0.525],
                "44": [0.13889, 0.125, 0, 0, 0.525],
                "45": [-0.08056, 0.53055, 0, 0, 0.525],
                "46": [0, 0.125, 0, 0, 0.525],
                "47": [0.08333, 0.69444, 0, 0, 0.525],
                "48": [0, 0.61111, 0, 0, 0.525],
                "49": [0, 0.61111, 0, 0, 0.525],
                "50": [0, 0.61111, 0, 0, 0.525],
                "51": [0, 0.61111, 0, 0, 0.525],
                "52": [0, 0.61111, 0, 0, 0.525],
                "53": [0, 0.61111, 0, 0, 0.525],
                "54": [0, 0.61111, 0, 0, 0.525],
                "55": [0, 0.61111, 0, 0, 0.525],
                "56": [0, 0.61111, 0, 0, 0.525],
                "57": [0, 0.61111, 0, 0, 0.525],
                "58": [0, 0.43056, 0, 0, 0.525],
                "59": [0.13889, 0.43056, 0, 0, 0.525],
                "60": [-0.05556, 0.55556, 0, 0, 0.525],
                "61": [-0.19549, 0.41562, 0, 0, 0.525],
                "62": [-0.05556, 0.55556, 0, 0, 0.525],
                "63": [0, 0.61111, 0, 0, 0.525],
                "64": [0, 0.61111, 0, 0, 0.525],
                "65": [0, 0.61111, 0, 0, 0.525],
                "66": [0, 0.61111, 0, 0, 0.525],
                "67": [0, 0.61111, 0, 0, 0.525],
                "68": [0, 0.61111, 0, 0, 0.525],
                "69": [0, 0.61111, 0, 0, 0.525],
                "70": [0, 0.61111, 0, 0, 0.525],
                "71": [0, 0.61111, 0, 0, 0.525],
                "72": [0, 0.61111, 0, 0, 0.525],
                "73": [0, 0.61111, 0, 0, 0.525],
                "74": [0, 0.61111, 0, 0, 0.525],
                "75": [0, 0.61111, 0, 0, 0.525],
                "76": [0, 0.61111, 0, 0, 0.525],
                "77": [0, 0.61111, 0, 0, 0.525],
                "78": [0, 0.61111, 0, 0, 0.525],
                "79": [0, 0.61111, 0, 0, 0.525],
                "80": [0, 0.61111, 0, 0, 0.525],
                "81": [0.13889, 0.61111, 0, 0, 0.525],
                "82": [0, 0.61111, 0, 0, 0.525],
                "83": [0, 0.61111, 0, 0, 0.525],
                "84": [0, 0.61111, 0, 0, 0.525],
                "85": [0, 0.61111, 0, 0, 0.525],
                "86": [0, 0.61111, 0, 0, 0.525],
                "87": [0, 0.61111, 0, 0, 0.525],
                "88": [0, 0.61111, 0, 0, 0.525],
                "89": [0, 0.61111, 0, 0, 0.525],
                "90": [0, 0.61111, 0, 0, 0.525],
                "91": [0.08333, 0.69444, 0, 0, 0.525],
                "92": [0.08333, 0.69444, 0, 0, 0.525],
                "93": [0.08333, 0.69444, 0, 0, 0.525],
                "94": [0, 0.61111, 0, 0, 0.525],
                "95": [0.09514, 0, 0, 0, 0.525],
                "96": [0, 0.61111, 0, 0, 0.525],
                "97": [0, 0.43056, 0, 0, 0.525],
                "98": [0, 0.61111, 0, 0, 0.525],
                "99": [0, 0.43056, 0, 0, 0.525],
                "100": [0, 0.61111, 0, 0, 0.525],
                "101": [0, 0.43056, 0, 0, 0.525],
                "102": [0, 0.61111, 0, 0, 0.525],
                "103": [0.22222, 0.43056, 0, 0, 0.525],
                "104": [0, 0.61111, 0, 0, 0.525],
                "105": [0, 0.61111, 0, 0, 0.525],
                "106": [0.22222, 0.61111, 0, 0, 0.525],
                "107": [0, 0.61111, 0, 0, 0.525],
                "108": [0, 0.61111, 0, 0, 0.525],
                "109": [0, 0.43056, 0, 0, 0.525],
                "110": [0, 0.43056, 0, 0, 0.525],
                "111": [0, 0.43056, 0, 0, 0.525],
                "112": [0.22222, 0.43056, 0, 0, 0.525],
                "113": [0.22222, 0.43056, 0, 0, 0.525],
                "114": [0, 0.43056, 0, 0, 0.525],
                "115": [0, 0.43056, 0, 0, 0.525],
                "116": [0, 0.55358, 0, 0, 0.525],
                "117": [0, 0.43056, 0, 0, 0.525],
                "118": [0, 0.43056, 0, 0, 0.525],
                "119": [0, 0.43056, 0, 0, 0.525],
                "120": [0, 0.43056, 0, 0, 0.525],
                "121": [0.22222, 0.43056, 0, 0, 0.525],
                "122": [0, 0.43056, 0, 0, 0.525],
                "123": [0.08333, 0.69444, 0, 0, 0.525],
                "124": [0.08333, 0.69444, 0, 0, 0.525],
                "125": [0.08333, 0.69444, 0, 0, 0.525],
                "126": [0, 0.61111, 0, 0, 0.525],
                "127": [0, 0.61111, 0, 0, 0.525],
                "160": [0, 0, 0, 0, 0.525],
                "176": [0, 0.61111, 0, 0, 0.525],
                "184": [0.19445, 0, 0, 0, 0.525],
                "305": [0, 0.43056, 0, 0, 0.525],
                "567": [0.22222, 0.43056, 0, 0, 0.525],
                "711": [0, 0.56597, 0, 0, 0.525],
                "713": [0, 0.56555, 0, 0, 0.525],
                "714": [0, 0.61111, 0, 0, 0.525],
                "715": [0, 0.61111, 0, 0, 0.525],
                "728": [0, 0.61111, 0, 0, 0.525],
                "730": [0, 0.61111, 0, 0, 0.525],
                "770": [0, 0.61111, 0, 0, 0.525],
                "771": [0, 0.61111, 0, 0, 0.525],
                "776": [0, 0.61111, 0, 0, 0.525],
                "915": [0, 0.61111, 0, 0, 0.525],
                "916": [0, 0.61111, 0, 0, 0.525],
                "920": [0, 0.61111, 0, 0, 0.525],
                "923": [0, 0.61111, 0, 0, 0.525],
                "926": [0, 0.61111, 0, 0, 0.525],
                "928": [0, 0.61111, 0, 0, 0.525],
                "931": [0, 0.61111, 0, 0, 0.525],
                "933": [0, 0.61111, 0, 0, 0.525],
                "934": [0, 0.61111, 0, 0, 0.525],
                "936": [0, 0.61111, 0, 0, 0.525],
                "937": [0, 0.61111, 0, 0, 0.525],
                "8216": [0, 0.61111, 0, 0, 0.525],
                "8217": [0, 0.61111, 0, 0, 0.525],
                "8242": [0, 0.61111, 0, 0, 0.525],
                "9251": [0.11111, 0.21944, 0, 0, 0.525]
              }
            };
            var sigmasAndXis = {
              slant: [0.25, 0.25, 0.25],
              // sigma1
              space: [0, 0, 0],
              // sigma2
              stretch: [0, 0, 0],
              // sigma3
              shrink: [0, 0, 0],
              // sigma4
              xHeight: [0.431, 0.431, 0.431],
              // sigma5
              quad: [1, 1.171, 1.472],
              // sigma6
              extraSpace: [0, 0, 0],
              // sigma7
              num1: [0.677, 0.732, 0.925],
              // sigma8
              num2: [0.394, 0.384, 0.387],
              // sigma9
              num3: [0.444, 0.471, 0.504],
              // sigma10
              denom1: [0.686, 0.752, 1.025],
              // sigma11
              denom2: [0.345, 0.344, 0.532],
              // sigma12
              sup1: [0.413, 0.503, 0.504],
              // sigma13
              sup2: [0.363, 0.431, 0.404],
              // sigma14
              sup3: [0.289, 0.286, 0.294],
              // sigma15
              sub1: [0.15, 0.143, 0.2],
              // sigma16
              sub2: [0.247, 0.286, 0.4],
              // sigma17
              supDrop: [0.386, 0.353, 0.494],
              // sigma18
              subDrop: [0.05, 0.071, 0.1],
              // sigma19
              delim1: [2.39, 1.7, 1.98],
              // sigma20
              delim2: [1.01, 1.157, 1.42],
              // sigma21
              axisHeight: [0.25, 0.25, 0.25],
              // sigma22
              // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
              // they correspond to the font parameters of the extension fonts (family 3).
              // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
              // match cmex7, we'd use cmex7.tfm values for script and scriptscript
              // values.
              defaultRuleThickness: [0.04, 0.049, 0.049],
              // xi8; cmex7: 0.049
              bigOpSpacing1: [0.111, 0.111, 0.111],
              // xi9
              bigOpSpacing2: [0.166, 0.166, 0.166],
              // xi10
              bigOpSpacing3: [0.2, 0.2, 0.2],
              // xi11
              bigOpSpacing4: [0.6, 0.611, 0.611],
              // xi12; cmex7: 0.611
              bigOpSpacing5: [0.1, 0.143, 0.143],
              // xi13; cmex7: 0.143
              // The \sqrt rule width is taken from the height of the surd character.
              // Since we use the same font at all sizes, this thickness doesn't scale.
              sqrtRuleThickness: [0.04, 0.04, 0.04],
              // This value determines how large a pt is, for metrics which are defined
              // in terms of pts.
              // This value is also used in katex.less; if you change it make sure the
              // values match.
              ptPerEm: [10, 10, 10],
              // The space between adjacent `|` columns in an array definition. From
              // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
              doubleRuleSep: [0.2, 0.2, 0.2]
            };
            var extraCharacterMap = {
              // Latin-1
              "\xC5": "A",
              "\xC7": "C",
              "\xD0": "D",
              "\xDE": "o",
              "\xE5": "a",
              "\xE7": "c",
              "\xF0": "d",
              "\xFE": "o",
              // Cyrillic
              "\u0410": "A",
              "\u0411": "B",
              "\u0412": "B",
              "\u0413": "F",
              "\u0414": "A",
              "\u0415": "E",
              "\u0416": "K",
              "\u0417": "3",
              "\u0418": "N",
              "\u0419": "N",
              "\u041A": "K",
              "\u041B": "N",
              "\u041C": "M",
              "\u041D": "H",
              "\u041E": "O",
              "\u041F": "N",
              "\u0420": "P",
              "\u0421": "C",
              "\u0422": "T",
              "\u0423": "y",
              "\u0424": "O",
              "\u0425": "X",
              "\u0426": "U",
              "\u0427": "h",
              "\u0428": "W",
              "\u0429": "W",
              "\u042A": "B",
              "\u042B": "X",
              "\u042C": "B",
              "\u042D": "3",
              "\u042E": "X",
              "\u042F": "R",
              "\u0430": "a",
              "\u0431": "b",
              "\u0432": "a",
              "\u0433": "r",
              "\u0434": "y",
              "\u0435": "e",
              "\u0436": "m",
              "\u0437": "e",
              "\u0438": "n",
              "\u0439": "n",
              "\u043A": "n",
              "\u043B": "n",
              "\u043C": "m",
              "\u043D": "n",
              "\u043E": "o",
              "\u043F": "n",
              "\u0440": "p",
              "\u0441": "c",
              "\u0442": "o",
              "\u0443": "y",
              "\u0444": "b",
              "\u0445": "x",
              "\u0446": "n",
              "\u0447": "n",
              "\u0448": "w",
              "\u0449": "w",
              "\u044A": "a",
              "\u044B": "m",
              "\u044C": "a",
              "\u044D": "e",
              "\u044E": "m",
              "\u044F": "r"
            };
            function setFontMetrics(fontName, metrics) {
              fontMetricsData[fontName] = metrics;
            }
            function getCharacterMetrics(character, font, mode) {
              if (!fontMetricsData[font]) {
                throw new Error("Font metrics not found for font: " + font + ".");
              }
              var ch = character.charCodeAt(0);
              var metrics = fontMetricsData[font][ch];
              if (!metrics && character[0] in extraCharacterMap) {
                ch = extraCharacterMap[character[0]].charCodeAt(0);
                metrics = fontMetricsData[font][ch];
              }
              if (!metrics && mode === "text") {
                if (supportedCodepoint(ch)) {
                  metrics = fontMetricsData[font][77];
                }
              }
              if (metrics) {
                return {
                  depth: metrics[0],
                  height: metrics[1],
                  italic: metrics[2],
                  skew: metrics[3],
                  width: metrics[4]
                };
              }
            }
            var fontMetricsBySizeIndex = {};
            function getGlobalMetrics(size) {
              var sizeIndex;
              if (size >= 5) {
                sizeIndex = 0;
              } else if (size >= 3) {
                sizeIndex = 1;
              } else {
                sizeIndex = 2;
              }
              if (!fontMetricsBySizeIndex[sizeIndex]) {
                var metrics = fontMetricsBySizeIndex[sizeIndex] = {
                  cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
                };
                for (var key in sigmasAndXis) {
                  if (sigmasAndXis.hasOwnProperty(key)) {
                    metrics[key] = sigmasAndXis[key][sizeIndex];
                  }
                }
              }
              return fontMetricsBySizeIndex[sizeIndex];
            }
            var ATOMS = {
              "bin": 1,
              "close": 1,
              "inner": 1,
              "open": 1,
              "punct": 1,
              "rel": 1
            };
            var NON_ATOMS = {
              "accent-token": 1,
              "mathord": 1,
              "op-token": 1,
              "spacing": 1,
              "textord": 1
            };
            var symbols = {
              "math": {},
              "text": {}
            };
            var src_symbols = symbols;
            function defineSymbol(mode, font, group, replace, name2, acceptUnicodeChar) {
              symbols[mode][name2] = {
                font,
                group,
                replace
              };
              if (acceptUnicodeChar && replace) {
                symbols[mode][replace] = symbols[mode][name2];
              }
            }
            var symbols_math = "math";
            var symbols_text = "text";
            var main = "main";
            var ams = "ams";
            var symbols_accent = "accent-token";
            var bin = "bin";
            var symbols_close = "close";
            var symbols_inner = "inner";
            var mathord = "mathord";
            var op = "op-token";
            var symbols_open = "open";
            var punct = "punct";
            var rel = "rel";
            var symbols_spacing = "spacing";
            var symbols_textord = "textord";
            defineSymbol(symbols_math, main, rel, "\u2261", "\\equiv", true);
            defineSymbol(symbols_math, main, rel, "\u227A", "\\prec", true);
            defineSymbol(symbols_math, main, rel, "\u227B", "\\succ", true);
            defineSymbol(symbols_math, main, rel, "\u223C", "\\sim", true);
            defineSymbol(symbols_math, main, rel, "\u22A5", "\\perp");
            defineSymbol(symbols_math, main, rel, "\u2AAF", "\\preceq", true);
            defineSymbol(symbols_math, main, rel, "\u2AB0", "\\succeq", true);
            defineSymbol(symbols_math, main, rel, "\u2243", "\\simeq", true);
            defineSymbol(symbols_math, main, rel, "\u2223", "\\mid", true);
            defineSymbol(symbols_math, main, rel, "\u226A", "\\ll", true);
            defineSymbol(symbols_math, main, rel, "\u226B", "\\gg", true);
            defineSymbol(symbols_math, main, rel, "\u224D", "\\asymp", true);
            defineSymbol(symbols_math, main, rel, "\u2225", "\\parallel");
            defineSymbol(symbols_math, main, rel, "\u22C8", "\\bowtie", true);
            defineSymbol(symbols_math, main, rel, "\u2323", "\\smile", true);
            defineSymbol(symbols_math, main, rel, "\u2291", "\\sqsubseteq", true);
            defineSymbol(symbols_math, main, rel, "\u2292", "\\sqsupseteq", true);
            defineSymbol(symbols_math, main, rel, "\u2250", "\\doteq", true);
            defineSymbol(symbols_math, main, rel, "\u2322", "\\frown", true);
            defineSymbol(symbols_math, main, rel, "\u220B", "\\ni", true);
            defineSymbol(symbols_math, main, rel, "\u221D", "\\propto", true);
            defineSymbol(symbols_math, main, rel, "\u22A2", "\\vdash", true);
            defineSymbol(symbols_math, main, rel, "\u22A3", "\\dashv", true);
            defineSymbol(symbols_math, main, rel, "\u220B", "\\owns");
            defineSymbol(symbols_math, main, punct, ".", "\\ldotp");
            defineSymbol(symbols_math, main, punct, "\u22C5", "\\cdotp");
            defineSymbol(symbols_math, main, symbols_textord, "#", "\\#");
            defineSymbol(symbols_text, main, symbols_textord, "#", "\\#");
            defineSymbol(symbols_math, main, symbols_textord, "&", "\\&");
            defineSymbol(symbols_text, main, symbols_textord, "&", "\\&");
            defineSymbol(symbols_math, main, symbols_textord, "\u2135", "\\aleph", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2200", "\\forall", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u210F", "\\hbar", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2203", "\\exists", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2207", "\\nabla", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u266D", "\\flat", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2113", "\\ell", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u266E", "\\natural", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2663", "\\clubsuit", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2118", "\\wp", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u266F", "\\sharp", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2662", "\\diamondsuit", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u211C", "\\Re", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2661", "\\heartsuit", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2111", "\\Im", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2660", "\\spadesuit", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xA7", "\\S", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xB6", "\\P", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2020", "\\dag");
            defineSymbol(symbols_text, main, symbols_textord, "\u2020", "\\dag");
            defineSymbol(symbols_text, main, symbols_textord, "\u2020", "\\textdagger");
            defineSymbol(symbols_math, main, symbols_textord, "\u2021", "\\ddag");
            defineSymbol(symbols_text, main, symbols_textord, "\u2021", "\\ddag");
            defineSymbol(symbols_text, main, symbols_textord, "\u2021", "\\textdaggerdbl");
            defineSymbol(symbols_math, main, symbols_close, "\u23B1", "\\rmoustache", true);
            defineSymbol(symbols_math, main, symbols_open, "\u23B0", "\\lmoustache", true);
            defineSymbol(symbols_math, main, symbols_close, "\u27EF", "\\rgroup", true);
            defineSymbol(symbols_math, main, symbols_open, "\u27EE", "\\lgroup", true);
            defineSymbol(symbols_math, main, bin, "\u2213", "\\mp", true);
            defineSymbol(symbols_math, main, bin, "\u2296", "\\ominus", true);
            defineSymbol(symbols_math, main, bin, "\u228E", "\\uplus", true);
            defineSymbol(symbols_math, main, bin, "\u2293", "\\sqcap", true);
            defineSymbol(symbols_math, main, bin, "\u2217", "\\ast");
            defineSymbol(symbols_math, main, bin, "\u2294", "\\sqcup", true);
            defineSymbol(symbols_math, main, bin, "\u25EF", "\\bigcirc");
            defineSymbol(symbols_math, main, bin, "\u2219", "\\bullet");
            defineSymbol(symbols_math, main, bin, "\u2021", "\\ddagger");
            defineSymbol(symbols_math, main, bin, "\u2240", "\\wr", true);
            defineSymbol(symbols_math, main, bin, "\u2A3F", "\\amalg");
            defineSymbol(symbols_math, main, bin, "&", "\\And");
            defineSymbol(symbols_math, main, rel, "\u27F5", "\\longleftarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21D0", "\\Leftarrow", true);
            defineSymbol(symbols_math, main, rel, "\u27F8", "\\Longleftarrow", true);
            defineSymbol(symbols_math, main, rel, "\u27F6", "\\longrightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21D2", "\\Rightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u27F9", "\\Longrightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u2194", "\\leftrightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u27F7", "\\longleftrightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21D4", "\\Leftrightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21A6", "\\mapsto", true);
            defineSymbol(symbols_math, main, rel, "\u27FC", "\\longmapsto", true);
            defineSymbol(symbols_math, main, rel, "\u2197", "\\nearrow", true);
            defineSymbol(symbols_math, main, rel, "\u21A9", "\\hookleftarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21AA", "\\hookrightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u2198", "\\searrow", true);
            defineSymbol(symbols_math, main, rel, "\u21BC", "\\leftharpoonup", true);
            defineSymbol(symbols_math, main, rel, "\u21C0", "\\rightharpoonup", true);
            defineSymbol(symbols_math, main, rel, "\u2199", "\\swarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21BD", "\\leftharpoondown", true);
            defineSymbol(symbols_math, main, rel, "\u21C1", "\\rightharpoondown", true);
            defineSymbol(symbols_math, main, rel, "\u2196", "\\nwarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21CC", "\\rightleftharpoons", true);
            defineSymbol(symbols_math, ams, rel, "\u226E", "\\nless", true);
            defineSymbol(symbols_math, ams, rel, "\uE010", "\\@nleqslant");
            defineSymbol(symbols_math, ams, rel, "\uE011", "\\@nleqq");
            defineSymbol(symbols_math, ams, rel, "\u2A87", "\\lneq", true);
            defineSymbol(symbols_math, ams, rel, "\u2268", "\\lneqq", true);
            defineSymbol(symbols_math, ams, rel, "\uE00C", "\\@lvertneqq");
            defineSymbol(symbols_math, ams, rel, "\u22E6", "\\lnsim", true);
            defineSymbol(symbols_math, ams, rel, "\u2A89", "\\lnapprox", true);
            defineSymbol(symbols_math, ams, rel, "\u2280", "\\nprec", true);
            defineSymbol(symbols_math, ams, rel, "\u22E0", "\\npreceq", true);
            defineSymbol(symbols_math, ams, rel, "\u22E8", "\\precnsim", true);
            defineSymbol(symbols_math, ams, rel, "\u2AB9", "\\precnapprox", true);
            defineSymbol(symbols_math, ams, rel, "\u2241", "\\nsim", true);
            defineSymbol(symbols_math, ams, rel, "\uE006", "\\@nshortmid");
            defineSymbol(symbols_math, ams, rel, "\u2224", "\\nmid", true);
            defineSymbol(symbols_math, ams, rel, "\u22AC", "\\nvdash", true);
            defineSymbol(symbols_math, ams, rel, "\u22AD", "\\nvDash", true);
            defineSymbol(symbols_math, ams, rel, "\u22EA", "\\ntriangleleft");
            defineSymbol(symbols_math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
            defineSymbol(symbols_math, ams, rel, "\u228A", "\\subsetneq", true);
            defineSymbol(symbols_math, ams, rel, "\uE01A", "\\@varsubsetneq");
            defineSymbol(symbols_math, ams, rel, "\u2ACB", "\\subsetneqq", true);
            defineSymbol(symbols_math, ams, rel, "\uE017", "\\@varsubsetneqq");
            defineSymbol(symbols_math, ams, rel, "\u226F", "\\ngtr", true);
            defineSymbol(symbols_math, ams, rel, "\uE00F", "\\@ngeqslant");
            defineSymbol(symbols_math, ams, rel, "\uE00E", "\\@ngeqq");
            defineSymbol(symbols_math, ams, rel, "\u2A88", "\\gneq", true);
            defineSymbol(symbols_math, ams, rel, "\u2269", "\\gneqq", true);
            defineSymbol(symbols_math, ams, rel, "\uE00D", "\\@gvertneqq");
            defineSymbol(symbols_math, ams, rel, "\u22E7", "\\gnsim", true);
            defineSymbol(symbols_math, ams, rel, "\u2A8A", "\\gnapprox", true);
            defineSymbol(symbols_math, ams, rel, "\u2281", "\\nsucc", true);
            defineSymbol(symbols_math, ams, rel, "\u22E1", "\\nsucceq", true);
            defineSymbol(symbols_math, ams, rel, "\u22E9", "\\succnsim", true);
            defineSymbol(symbols_math, ams, rel, "\u2ABA", "\\succnapprox", true);
            defineSymbol(symbols_math, ams, rel, "\u2246", "\\ncong", true);
            defineSymbol(symbols_math, ams, rel, "\uE007", "\\@nshortparallel");
            defineSymbol(symbols_math, ams, rel, "\u2226", "\\nparallel", true);
            defineSymbol(symbols_math, ams, rel, "\u22AF", "\\nVDash", true);
            defineSymbol(symbols_math, ams, rel, "\u22EB", "\\ntriangleright");
            defineSymbol(symbols_math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
            defineSymbol(symbols_math, ams, rel, "\uE018", "\\@nsupseteqq");
            defineSymbol(symbols_math, ams, rel, "\u228B", "\\supsetneq", true);
            defineSymbol(symbols_math, ams, rel, "\uE01B", "\\@varsupsetneq");
            defineSymbol(symbols_math, ams, rel, "\u2ACC", "\\supsetneqq", true);
            defineSymbol(symbols_math, ams, rel, "\uE019", "\\@varsupsetneqq");
            defineSymbol(symbols_math, ams, rel, "\u22AE", "\\nVdash", true);
            defineSymbol(symbols_math, ams, rel, "\u2AB5", "\\precneqq", true);
            defineSymbol(symbols_math, ams, rel, "\u2AB6", "\\succneqq", true);
            defineSymbol(symbols_math, ams, rel, "\uE016", "\\@nsubseteqq");
            defineSymbol(symbols_math, ams, bin, "\u22B4", "\\unlhd");
            defineSymbol(symbols_math, ams, bin, "\u22B5", "\\unrhd");
            defineSymbol(symbols_math, ams, rel, "\u219A", "\\nleftarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u219B", "\\nrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21CD", "\\nLeftarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21CF", "\\nRightarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u25B3", "\\vartriangle");
            defineSymbol(symbols_math, ams, symbols_textord, "\u210F", "\\hslash");
            defineSymbol(symbols_math, ams, symbols_textord, "\u25BD", "\\triangledown");
            defineSymbol(symbols_math, ams, symbols_textord, "\u25CA", "\\lozenge");
            defineSymbol(symbols_math, ams, symbols_textord, "\u24C8", "\\circledS");
            defineSymbol(symbols_math, ams, symbols_textord, "\xAE", "\\circledR");
            defineSymbol(symbols_text, ams, symbols_textord, "\xAE", "\\circledR");
            defineSymbol(symbols_math, ams, symbols_textord, "\u2221", "\\measuredangle", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2204", "\\nexists");
            defineSymbol(symbols_math, ams, symbols_textord, "\u2127", "\\mho");
            defineSymbol(symbols_math, ams, symbols_textord, "\u2132", "\\Finv", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2141", "\\Game", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2035", "\\backprime");
            defineSymbol(symbols_math, ams, symbols_textord, "\u25B2", "\\blacktriangle");
            defineSymbol(symbols_math, ams, symbols_textord, "\u25BC", "\\blacktriangledown");
            defineSymbol(symbols_math, ams, symbols_textord, "\u25A0", "\\blacksquare");
            defineSymbol(symbols_math, ams, symbols_textord, "\u29EB", "\\blacklozenge");
            defineSymbol(symbols_math, ams, symbols_textord, "\u2605", "\\bigstar");
            defineSymbol(symbols_math, ams, symbols_textord, "\u2222", "\\sphericalangle", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2201", "\\complement", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\xF0", "\\eth", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2571", "\\diagup");
            defineSymbol(symbols_math, ams, symbols_textord, "\u2572", "\\diagdown");
            defineSymbol(symbols_math, ams, symbols_textord, "\u25A1", "\\square");
            defineSymbol(symbols_math, ams, symbols_textord, "\u25A1", "\\Box");
            defineSymbol(symbols_math, ams, symbols_textord, "\u25CA", "\\Diamond");
            defineSymbol(symbols_math, ams, symbols_textord, "\xA5", "\\yen", true);
            defineSymbol(symbols_text, ams, symbols_textord, "\xA5", "\\yen", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2713", "\\checkmark", true);
            defineSymbol(symbols_text, ams, symbols_textord, "\u2713", "\\checkmark");
            defineSymbol(symbols_math, ams, symbols_textord, "\u2136", "\\beth", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2138", "\\daleth", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2137", "\\gimel", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u03DD", "\\digamma");
            defineSymbol(symbols_math, ams, symbols_textord, "\u03F0", "\\varkappa");
            defineSymbol(symbols_math, ams, symbols_open, "\u250C", "\\ulcorner", true);
            defineSymbol(symbols_math, ams, symbols_close, "\u2510", "\\urcorner", true);
            defineSymbol(symbols_math, ams, symbols_open, "\u2514", "\\llcorner", true);
            defineSymbol(symbols_math, ams, symbols_close, "\u2518", "\\lrcorner", true);
            defineSymbol(symbols_math, ams, rel, "\u2266", "\\leqq", true);
            defineSymbol(symbols_math, ams, rel, "\u2A7D", "\\leqslant", true);
            defineSymbol(symbols_math, ams, rel, "\u2A95", "\\eqslantless", true);
            defineSymbol(symbols_math, ams, rel, "\u2272", "\\lesssim", true);
            defineSymbol(symbols_math, ams, rel, "\u2A85", "\\lessapprox", true);
            defineSymbol(symbols_math, ams, rel, "\u224A", "\\approxeq", true);
            defineSymbol(symbols_math, ams, bin, "\u22D6", "\\lessdot");
            defineSymbol(symbols_math, ams, rel, "\u22D8", "\\lll", true);
            defineSymbol(symbols_math, ams, rel, "\u2276", "\\lessgtr", true);
            defineSymbol(symbols_math, ams, rel, "\u22DA", "\\lesseqgtr", true);
            defineSymbol(symbols_math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
            defineSymbol(symbols_math, ams, rel, "\u2251", "\\doteqdot");
            defineSymbol(symbols_math, ams, rel, "\u2253", "\\risingdotseq", true);
            defineSymbol(symbols_math, ams, rel, "\u2252", "\\fallingdotseq", true);
            defineSymbol(symbols_math, ams, rel, "\u223D", "\\backsim", true);
            defineSymbol(symbols_math, ams, rel, "\u22CD", "\\backsimeq", true);
            defineSymbol(symbols_math, ams, rel, "\u2AC5", "\\subseteqq", true);
            defineSymbol(symbols_math, ams, rel, "\u22D0", "\\Subset", true);
            defineSymbol(symbols_math, ams, rel, "\u228F", "\\sqsubset", true);
            defineSymbol(symbols_math, ams, rel, "\u227C", "\\preccurlyeq", true);
            defineSymbol(symbols_math, ams, rel, "\u22DE", "\\curlyeqprec", true);
            defineSymbol(symbols_math, ams, rel, "\u227E", "\\precsim", true);
            defineSymbol(symbols_math, ams, rel, "\u2AB7", "\\precapprox", true);
            defineSymbol(symbols_math, ams, rel, "\u22B2", "\\vartriangleleft");
            defineSymbol(symbols_math, ams, rel, "\u22B4", "\\trianglelefteq");
            defineSymbol(symbols_math, ams, rel, "\u22A8", "\\vDash", true);
            defineSymbol(symbols_math, ams, rel, "\u22AA", "\\Vvdash", true);
            defineSymbol(symbols_math, ams, rel, "\u2323", "\\smallsmile");
            defineSymbol(symbols_math, ams, rel, "\u2322", "\\smallfrown");
            defineSymbol(symbols_math, ams, rel, "\u224F", "\\bumpeq", true);
            defineSymbol(symbols_math, ams, rel, "\u224E", "\\Bumpeq", true);
            defineSymbol(symbols_math, ams, rel, "\u2267", "\\geqq", true);
            defineSymbol(symbols_math, ams, rel, "\u2A7E", "\\geqslant", true);
            defineSymbol(symbols_math, ams, rel, "\u2A96", "\\eqslantgtr", true);
            defineSymbol(symbols_math, ams, rel, "\u2273", "\\gtrsim", true);
            defineSymbol(symbols_math, ams, rel, "\u2A86", "\\gtrapprox", true);
            defineSymbol(symbols_math, ams, bin, "\u22D7", "\\gtrdot");
            defineSymbol(symbols_math, ams, rel, "\u22D9", "\\ggg", true);
            defineSymbol(symbols_math, ams, rel, "\u2277", "\\gtrless", true);
            defineSymbol(symbols_math, ams, rel, "\u22DB", "\\gtreqless", true);
            defineSymbol(symbols_math, ams, rel, "\u2A8C", "\\gtreqqless", true);
            defineSymbol(symbols_math, ams, rel, "\u2256", "\\eqcirc", true);
            defineSymbol(symbols_math, ams, rel, "\u2257", "\\circeq", true);
            defineSymbol(symbols_math, ams, rel, "\u225C", "\\triangleq", true);
            defineSymbol(symbols_math, ams, rel, "\u223C", "\\thicksim");
            defineSymbol(symbols_math, ams, rel, "\u2248", "\\thickapprox");
            defineSymbol(symbols_math, ams, rel, "\u2AC6", "\\supseteqq", true);
            defineSymbol(symbols_math, ams, rel, "\u22D1", "\\Supset", true);
            defineSymbol(symbols_math, ams, rel, "\u2290", "\\sqsupset", true);
            defineSymbol(symbols_math, ams, rel, "\u227D", "\\succcurlyeq", true);
            defineSymbol(symbols_math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
            defineSymbol(symbols_math, ams, rel, "\u227F", "\\succsim", true);
            defineSymbol(symbols_math, ams, rel, "\u2AB8", "\\succapprox", true);
            defineSymbol(symbols_math, ams, rel, "\u22B3", "\\vartriangleright");
            defineSymbol(symbols_math, ams, rel, "\u22B5", "\\trianglerighteq");
            defineSymbol(symbols_math, ams, rel, "\u22A9", "\\Vdash", true);
            defineSymbol(symbols_math, ams, rel, "\u2223", "\\shortmid");
            defineSymbol(symbols_math, ams, rel, "\u2225", "\\shortparallel");
            defineSymbol(symbols_math, ams, rel, "\u226C", "\\between", true);
            defineSymbol(symbols_math, ams, rel, "\u22D4", "\\pitchfork", true);
            defineSymbol(symbols_math, ams, rel, "\u221D", "\\varpropto");
            defineSymbol(symbols_math, ams, rel, "\u25C0", "\\blacktriangleleft");
            defineSymbol(symbols_math, ams, rel, "\u2234", "\\therefore", true);
            defineSymbol(symbols_math, ams, rel, "\u220D", "\\backepsilon");
            defineSymbol(symbols_math, ams, rel, "\u25B6", "\\blacktriangleright");
            defineSymbol(symbols_math, ams, rel, "\u2235", "\\because", true);
            defineSymbol(symbols_math, ams, rel, "\u22D8", "\\llless");
            defineSymbol(symbols_math, ams, rel, "\u22D9", "\\gggtr");
            defineSymbol(symbols_math, ams, bin, "\u22B2", "\\lhd");
            defineSymbol(symbols_math, ams, bin, "\u22B3", "\\rhd");
            defineSymbol(symbols_math, ams, rel, "\u2242", "\\eqsim", true);
            defineSymbol(symbols_math, main, rel, "\u22C8", "\\Join");
            defineSymbol(symbols_math, ams, rel, "\u2251", "\\Doteq", true);
            defineSymbol(symbols_math, ams, bin, "\u2214", "\\dotplus", true);
            defineSymbol(symbols_math, ams, bin, "\u2216", "\\smallsetminus");
            defineSymbol(symbols_math, ams, bin, "\u22D2", "\\Cap", true);
            defineSymbol(symbols_math, ams, bin, "\u22D3", "\\Cup", true);
            defineSymbol(symbols_math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
            defineSymbol(symbols_math, ams, bin, "\u229F", "\\boxminus", true);
            defineSymbol(symbols_math, ams, bin, "\u229E", "\\boxplus", true);
            defineSymbol(symbols_math, ams, bin, "\u22C7", "\\divideontimes", true);
            defineSymbol(symbols_math, ams, bin, "\u22C9", "\\ltimes", true);
            defineSymbol(symbols_math, ams, bin, "\u22CA", "\\rtimes", true);
            defineSymbol(symbols_math, ams, bin, "\u22CB", "\\leftthreetimes", true);
            defineSymbol(symbols_math, ams, bin, "\u22CC", "\\rightthreetimes", true);
            defineSymbol(symbols_math, ams, bin, "\u22CF", "\\curlywedge", true);
            defineSymbol(symbols_math, ams, bin, "\u22CE", "\\curlyvee", true);
            defineSymbol(symbols_math, ams, bin, "\u229D", "\\circleddash", true);
            defineSymbol(symbols_math, ams, bin, "\u229B", "\\circledast", true);
            defineSymbol(symbols_math, ams, bin, "\u22C5", "\\centerdot");
            defineSymbol(symbols_math, ams, bin, "\u22BA", "\\intercal", true);
            defineSymbol(symbols_math, ams, bin, "\u22D2", "\\doublecap");
            defineSymbol(symbols_math, ams, bin, "\u22D3", "\\doublecup");
            defineSymbol(symbols_math, ams, bin, "\u22A0", "\\boxtimes", true);
            defineSymbol(symbols_math, ams, rel, "\u21E2", "\\dashrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21E0", "\\dashleftarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21C7", "\\leftleftarrows", true);
            defineSymbol(symbols_math, ams, rel, "\u21C6", "\\leftrightarrows", true);
            defineSymbol(symbols_math, ams, rel, "\u21DA", "\\Lleftarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21A2", "\\leftarrowtail", true);
            defineSymbol(symbols_math, ams, rel, "\u21AB", "\\looparrowleft", true);
            defineSymbol(symbols_math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
            defineSymbol(symbols_math, ams, rel, "\u21B6", "\\curvearrowleft", true);
            defineSymbol(symbols_math, ams, rel, "\u21BA", "\\circlearrowleft", true);
            defineSymbol(symbols_math, ams, rel, "\u21B0", "\\Lsh", true);
            defineSymbol(symbols_math, ams, rel, "\u21C8", "\\upuparrows", true);
            defineSymbol(symbols_math, ams, rel, "\u21BF", "\\upharpoonleft", true);
            defineSymbol(symbols_math, ams, rel, "\u21C3", "\\downharpoonleft", true);
            defineSymbol(symbols_math, ams, rel, "\u22B8", "\\multimap", true);
            defineSymbol(symbols_math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21C9", "\\rightrightarrows", true);
            defineSymbol(symbols_math, ams, rel, "\u21C4", "\\rightleftarrows", true);
            defineSymbol(symbols_math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21A3", "\\rightarrowtail", true);
            defineSymbol(symbols_math, ams, rel, "\u21AC", "\\looparrowright", true);
            defineSymbol(symbols_math, ams, rel, "\u21B7", "\\curvearrowright", true);
            defineSymbol(symbols_math, ams, rel, "\u21BB", "\\circlearrowright", true);
            defineSymbol(symbols_math, ams, rel, "\u21B1", "\\Rsh", true);
            defineSymbol(symbols_math, ams, rel, "\u21CA", "\\downdownarrows", true);
            defineSymbol(symbols_math, ams, rel, "\u21BE", "\\upharpoonright", true);
            defineSymbol(symbols_math, ams, rel, "\u21C2", "\\downharpoonright", true);
            defineSymbol(symbols_math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21DD", "\\leadsto");
            defineSymbol(symbols_math, ams, rel, "\u21DB", "\\Rrightarrow", true);
            defineSymbol(symbols_math, ams, rel, "\u21BE", "\\restriction");
            defineSymbol(symbols_math, main, symbols_textord, "\u2018", "`");
            defineSymbol(symbols_math, main, symbols_textord, "$", "\\$");
            defineSymbol(symbols_text, main, symbols_textord, "$", "\\$");
            defineSymbol(symbols_text, main, symbols_textord, "$", "\\textdollar");
            defineSymbol(symbols_math, main, symbols_textord, "%", "\\%");
            defineSymbol(symbols_text, main, symbols_textord, "%", "\\%");
            defineSymbol(symbols_math, main, symbols_textord, "_", "\\_");
            defineSymbol(symbols_text, main, symbols_textord, "_", "\\_");
            defineSymbol(symbols_text, main, symbols_textord, "_", "\\textunderscore");
            defineSymbol(symbols_math, main, symbols_textord, "\u2220", "\\angle", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u221E", "\\infty", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2032", "\\prime");
            defineSymbol(symbols_math, main, symbols_textord, "\u25B3", "\\triangle");
            defineSymbol(symbols_math, main, symbols_textord, "\u0393", "\\Gamma", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u0394", "\\Delta", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u0398", "\\Theta", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u039B", "\\Lambda", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u039E", "\\Xi", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u03A0", "\\Pi", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u03A3", "\\Sigma", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u03A5", "\\Upsilon", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u03A6", "\\Phi", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u03A8", "\\Psi", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u03A9", "\\Omega", true);
            defineSymbol(symbols_math, main, symbols_textord, "A", "\u0391");
            defineSymbol(symbols_math, main, symbols_textord, "B", "\u0392");
            defineSymbol(symbols_math, main, symbols_textord, "E", "\u0395");
            defineSymbol(symbols_math, main, symbols_textord, "Z", "\u0396");
            defineSymbol(symbols_math, main, symbols_textord, "H", "\u0397");
            defineSymbol(symbols_math, main, symbols_textord, "I", "\u0399");
            defineSymbol(symbols_math, main, symbols_textord, "K", "\u039A");
            defineSymbol(symbols_math, main, symbols_textord, "M", "\u039C");
            defineSymbol(symbols_math, main, symbols_textord, "N", "\u039D");
            defineSymbol(symbols_math, main, symbols_textord, "O", "\u039F");
            defineSymbol(symbols_math, main, symbols_textord, "P", "\u03A1");
            defineSymbol(symbols_math, main, symbols_textord, "T", "\u03A4");
            defineSymbol(symbols_math, main, symbols_textord, "X", "\u03A7");
            defineSymbol(symbols_math, main, symbols_textord, "\xAC", "\\neg", true);
            defineSymbol(symbols_math, main, symbols_textord, "\xAC", "\\lnot");
            defineSymbol(symbols_math, main, symbols_textord, "\u22A4", "\\top");
            defineSymbol(symbols_math, main, symbols_textord, "\u22A5", "\\bot");
            defineSymbol(symbols_math, main, symbols_textord, "\u2205", "\\emptyset");
            defineSymbol(symbols_math, ams, symbols_textord, "\u2205", "\\varnothing");
            defineSymbol(symbols_math, main, mathord, "\u03B1", "\\alpha", true);
            defineSymbol(symbols_math, main, mathord, "\u03B2", "\\beta", true);
            defineSymbol(symbols_math, main, mathord, "\u03B3", "\\gamma", true);
            defineSymbol(symbols_math, main, mathord, "\u03B4", "\\delta", true);
            defineSymbol(symbols_math, main, mathord, "\u03F5", "\\epsilon", true);
            defineSymbol(symbols_math, main, mathord, "\u03B6", "\\zeta", true);
            defineSymbol(symbols_math, main, mathord, "\u03B7", "\\eta", true);
            defineSymbol(symbols_math, main, mathord, "\u03B8", "\\theta", true);
            defineSymbol(symbols_math, main, mathord, "\u03B9", "\\iota", true);
            defineSymbol(symbols_math, main, mathord, "\u03BA", "\\kappa", true);
            defineSymbol(symbols_math, main, mathord, "\u03BB", "\\lambda", true);
            defineSymbol(symbols_math, main, mathord, "\u03BC", "\\mu", true);
            defineSymbol(symbols_math, main, mathord, "\u03BD", "\\nu", true);
            defineSymbol(symbols_math, main, mathord, "\u03BE", "\\xi", true);
            defineSymbol(symbols_math, main, mathord, "\u03BF", "\\omicron", true);
            defineSymbol(symbols_math, main, mathord, "\u03C0", "\\pi", true);
            defineSymbol(symbols_math, main, mathord, "\u03C1", "\\rho", true);
            defineSymbol(symbols_math, main, mathord, "\u03C3", "\\sigma", true);
            defineSymbol(symbols_math, main, mathord, "\u03C4", "\\tau", true);
            defineSymbol(symbols_math, main, mathord, "\u03C5", "\\upsilon", true);
            defineSymbol(symbols_math, main, mathord, "\u03D5", "\\phi", true);
            defineSymbol(symbols_math, main, mathord, "\u03C7", "\\chi", true);
            defineSymbol(symbols_math, main, mathord, "\u03C8", "\\psi", true);
            defineSymbol(symbols_math, main, mathord, "\u03C9", "\\omega", true);
            defineSymbol(symbols_math, main, mathord, "\u03B5", "\\varepsilon", true);
            defineSymbol(symbols_math, main, mathord, "\u03D1", "\\vartheta", true);
            defineSymbol(symbols_math, main, mathord, "\u03D6", "\\varpi", true);
            defineSymbol(symbols_math, main, mathord, "\u03F1", "\\varrho", true);
            defineSymbol(symbols_math, main, mathord, "\u03C2", "\\varsigma", true);
            defineSymbol(symbols_math, main, mathord, "\u03C6", "\\varphi", true);
            defineSymbol(symbols_math, main, bin, "\u2217", "*");
            defineSymbol(symbols_math, main, bin, "+", "+");
            defineSymbol(symbols_math, main, bin, "\u2212", "-");
            defineSymbol(symbols_math, main, bin, "\u22C5", "\\cdot", true);
            defineSymbol(symbols_math, main, bin, "\u2218", "\\circ");
            defineSymbol(symbols_math, main, bin, "\xF7", "\\div", true);
            defineSymbol(symbols_math, main, bin, "\xB1", "\\pm", true);
            defineSymbol(symbols_math, main, bin, "\xD7", "\\times", true);
            defineSymbol(symbols_math, main, bin, "\u2229", "\\cap", true);
            defineSymbol(symbols_math, main, bin, "\u222A", "\\cup", true);
            defineSymbol(symbols_math, main, bin, "\u2216", "\\setminus");
            defineSymbol(symbols_math, main, bin, "\u2227", "\\land");
            defineSymbol(symbols_math, main, bin, "\u2228", "\\lor");
            defineSymbol(symbols_math, main, bin, "\u2227", "\\wedge", true);
            defineSymbol(symbols_math, main, bin, "\u2228", "\\vee", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u221A", "\\surd");
            defineSymbol(symbols_math, main, symbols_open, "(", "(");
            defineSymbol(symbols_math, main, symbols_open, "[", "[");
            defineSymbol(symbols_math, main, symbols_open, "\u27E8", "\\langle", true);
            defineSymbol(symbols_math, main, symbols_open, "\u2223", "\\lvert");
            defineSymbol(symbols_math, main, symbols_open, "\u2225", "\\lVert");
            defineSymbol(symbols_math, main, symbols_close, ")", ")");
            defineSymbol(symbols_math, main, symbols_close, "]", "]");
            defineSymbol(symbols_math, main, symbols_close, "?", "?");
            defineSymbol(symbols_math, main, symbols_close, "!", "!");
            defineSymbol(symbols_math, main, symbols_close, "\u27E9", "\\rangle", true);
            defineSymbol(symbols_math, main, symbols_close, "\u2223", "\\rvert");
            defineSymbol(symbols_math, main, symbols_close, "\u2225", "\\rVert");
            defineSymbol(symbols_math, main, rel, "=", "=");
            defineSymbol(symbols_math, main, rel, "<", "<");
            defineSymbol(symbols_math, main, rel, ">", ">");
            defineSymbol(symbols_math, main, rel, ":", ":");
            defineSymbol(symbols_math, main, rel, "\u2248", "\\approx", true);
            defineSymbol(symbols_math, main, rel, "\u2245", "\\cong", true);
            defineSymbol(symbols_math, main, rel, "\u2265", "\\ge");
            defineSymbol(symbols_math, main, rel, "\u2265", "\\geq", true);
            defineSymbol(symbols_math, main, rel, "\u2190", "\\gets");
            defineSymbol(symbols_math, main, rel, ">", "\\gt");
            defineSymbol(symbols_math, main, rel, "\u2208", "\\in", true);
            defineSymbol(symbols_math, main, rel, "\uE020", "\\@not");
            defineSymbol(symbols_math, main, rel, "\u2282", "\\subset", true);
            defineSymbol(symbols_math, main, rel, "\u2283", "\\supset", true);
            defineSymbol(symbols_math, main, rel, "\u2286", "\\subseteq", true);
            defineSymbol(symbols_math, main, rel, "\u2287", "\\supseteq", true);
            defineSymbol(symbols_math, ams, rel, "\u2288", "\\nsubseteq", true);
            defineSymbol(symbols_math, ams, rel, "\u2289", "\\nsupseteq", true);
            defineSymbol(symbols_math, main, rel, "\u22A8", "\\models");
            defineSymbol(symbols_math, main, rel, "\u2190", "\\leftarrow", true);
            defineSymbol(symbols_math, main, rel, "\u2264", "\\le");
            defineSymbol(symbols_math, main, rel, "\u2264", "\\leq", true);
            defineSymbol(symbols_math, main, rel, "<", "\\lt");
            defineSymbol(symbols_math, main, rel, "\u2192", "\\rightarrow", true);
            defineSymbol(symbols_math, main, rel, "\u2192", "\\to");
            defineSymbol(symbols_math, ams, rel, "\u2271", "\\ngeq", true);
            defineSymbol(symbols_math, ams, rel, "\u2270", "\\nleq", true);
            defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\ ");
            defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "~");
            defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\space");
            defineSymbol(symbols_math, main, symbols_spacing, "\xA0", "\\nobreakspace");
            defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\ ");
            defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "~");
            defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\space");
            defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\nobreakspace");
            defineSymbol(symbols_math, main, symbols_spacing, null, "\\nobreak");
            defineSymbol(symbols_math, main, symbols_spacing, null, "\\allowbreak");
            defineSymbol(symbols_math, main, punct, ",", ",");
            defineSymbol(symbols_math, main, punct, ";", ";");
            defineSymbol(symbols_math, ams, bin, "\u22BC", "\\barwedge", true);
            defineSymbol(symbols_math, ams, bin, "\u22BB", "\\veebar", true);
            defineSymbol(symbols_math, main, bin, "\u2299", "\\odot", true);
            defineSymbol(symbols_math, main, bin, "\u2295", "\\oplus", true);
            defineSymbol(symbols_math, main, bin, "\u2297", "\\otimes", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u2202", "\\partial", true);
            defineSymbol(symbols_math, main, bin, "\u2298", "\\oslash", true);
            defineSymbol(symbols_math, ams, bin, "\u229A", "\\circledcirc", true);
            defineSymbol(symbols_math, ams, bin, "\u22A1", "\\boxdot", true);
            defineSymbol(symbols_math, main, bin, "\u25B3", "\\bigtriangleup");
            defineSymbol(symbols_math, main, bin, "\u25BD", "\\bigtriangledown");
            defineSymbol(symbols_math, main, bin, "\u2020", "\\dagger");
            defineSymbol(symbols_math, main, bin, "\u22C4", "\\diamond");
            defineSymbol(symbols_math, main, bin, "\u22C6", "\\star");
            defineSymbol(symbols_math, main, bin, "\u25C3", "\\triangleleft");
            defineSymbol(symbols_math, main, bin, "\u25B9", "\\triangleright");
            defineSymbol(symbols_math, main, symbols_open, "{", "\\{");
            defineSymbol(symbols_text, main, symbols_textord, "{", "\\{");
            defineSymbol(symbols_text, main, symbols_textord, "{", "\\textbraceleft");
            defineSymbol(symbols_math, main, symbols_close, "}", "\\}");
            defineSymbol(symbols_text, main, symbols_textord, "}", "\\}");
            defineSymbol(symbols_text, main, symbols_textord, "}", "\\textbraceright");
            defineSymbol(symbols_math, main, symbols_open, "{", "\\lbrace");
            defineSymbol(symbols_math, main, symbols_close, "}", "\\rbrace");
            defineSymbol(symbols_math, main, symbols_open, "[", "\\lbrack");
            defineSymbol(symbols_text, main, symbols_textord, "[", "\\lbrack");
            defineSymbol(symbols_math, main, symbols_close, "]", "\\rbrack");
            defineSymbol(symbols_text, main, symbols_textord, "]", "\\rbrack");
            defineSymbol(symbols_math, main, symbols_open, "(", "\\lparen");
            defineSymbol(symbols_math, main, symbols_close, ")", "\\rparen");
            defineSymbol(symbols_text, main, symbols_textord, "<", "\\textless");
            defineSymbol(symbols_text, main, symbols_textord, ">", "\\textgreater");
            defineSymbol(symbols_math, main, symbols_open, "\u230A", "\\lfloor", true);
            defineSymbol(symbols_math, main, symbols_close, "\u230B", "\\rfloor", true);
            defineSymbol(symbols_math, main, symbols_open, "\u2308", "\\lceil", true);
            defineSymbol(symbols_math, main, symbols_close, "\u2309", "\\rceil", true);
            defineSymbol(symbols_math, main, symbols_textord, "\\", "\\backslash");
            defineSymbol(symbols_math, main, symbols_textord, "\u2223", "|");
            defineSymbol(symbols_math, main, symbols_textord, "\u2223", "\\vert");
            defineSymbol(symbols_text, main, symbols_textord, "|", "\\textbar");
            defineSymbol(symbols_math, main, symbols_textord, "\u2225", "\\|");
            defineSymbol(symbols_math, main, symbols_textord, "\u2225", "\\Vert");
            defineSymbol(symbols_text, main, symbols_textord, "\u2225", "\\textbardbl");
            defineSymbol(symbols_text, main, symbols_textord, "~", "\\textasciitilde");
            defineSymbol(symbols_text, main, symbols_textord, "\\", "\\textbackslash");
            defineSymbol(symbols_text, main, symbols_textord, "^", "\\textasciicircum");
            defineSymbol(symbols_math, main, rel, "\u2191", "\\uparrow", true);
            defineSymbol(symbols_math, main, rel, "\u21D1", "\\Uparrow", true);
            defineSymbol(symbols_math, main, rel, "\u2193", "\\downarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21D3", "\\Downarrow", true);
            defineSymbol(symbols_math, main, rel, "\u2195", "\\updownarrow", true);
            defineSymbol(symbols_math, main, rel, "\u21D5", "\\Updownarrow", true);
            defineSymbol(symbols_math, main, op, "\u2210", "\\coprod");
            defineSymbol(symbols_math, main, op, "\u22C1", "\\bigvee");
            defineSymbol(symbols_math, main, op, "\u22C0", "\\bigwedge");
            defineSymbol(symbols_math, main, op, "\u2A04", "\\biguplus");
            defineSymbol(symbols_math, main, op, "\u22C2", "\\bigcap");
            defineSymbol(symbols_math, main, op, "\u22C3", "\\bigcup");
            defineSymbol(symbols_math, main, op, "\u222B", "\\int");
            defineSymbol(symbols_math, main, op, "\u222B", "\\intop");
            defineSymbol(symbols_math, main, op, "\u222C", "\\iint");
            defineSymbol(symbols_math, main, op, "\u222D", "\\iiint");
            defineSymbol(symbols_math, main, op, "\u220F", "\\prod");
            defineSymbol(symbols_math, main, op, "\u2211", "\\sum");
            defineSymbol(symbols_math, main, op, "\u2A02", "\\bigotimes");
            defineSymbol(symbols_math, main, op, "\u2A01", "\\bigoplus");
            defineSymbol(symbols_math, main, op, "\u2A00", "\\bigodot");
            defineSymbol(symbols_math, main, op, "\u222E", "\\oint");
            defineSymbol(symbols_math, main, op, "\u222F", "\\oiint");
            defineSymbol(symbols_math, main, op, "\u2230", "\\oiiint");
            defineSymbol(symbols_math, main, op, "\u2A06", "\\bigsqcup");
            defineSymbol(symbols_math, main, op, "\u222B", "\\smallint");
            defineSymbol(symbols_text, main, symbols_inner, "\u2026", "\\textellipsis");
            defineSymbol(symbols_math, main, symbols_inner, "\u2026", "\\mathellipsis");
            defineSymbol(symbols_text, main, symbols_inner, "\u2026", "\\ldots", true);
            defineSymbol(symbols_math, main, symbols_inner, "\u2026", "\\ldots", true);
            defineSymbol(symbols_math, main, symbols_inner, "\u22EF", "\\@cdots", true);
            defineSymbol(symbols_math, main, symbols_inner, "\u22F1", "\\ddots", true);
            defineSymbol(symbols_math, main, symbols_textord, "\u22EE", "\\varvdots");
            defineSymbol(symbols_math, main, symbols_accent, "\u02CA", "\\acute");
            defineSymbol(symbols_math, main, symbols_accent, "\u02CB", "\\grave");
            defineSymbol(symbols_math, main, symbols_accent, "\xA8", "\\ddot");
            defineSymbol(symbols_math, main, symbols_accent, "~", "\\tilde");
            defineSymbol(symbols_math, main, symbols_accent, "\u02C9", "\\bar");
            defineSymbol(symbols_math, main, symbols_accent, "\u02D8", "\\breve");
            defineSymbol(symbols_math, main, symbols_accent, "\u02C7", "\\check");
            defineSymbol(symbols_math, main, symbols_accent, "^", "\\hat");
            defineSymbol(symbols_math, main, symbols_accent, "\u20D7", "\\vec");
            defineSymbol(symbols_math, main, symbols_accent, "\u02D9", "\\dot");
            defineSymbol(symbols_math, main, symbols_accent, "\u02DA", "\\mathring");
            defineSymbol(symbols_math, main, mathord, "\u0131", "\\imath", true);
            defineSymbol(symbols_math, main, mathord, "\u0237", "\\jmath", true);
            defineSymbol(symbols_text, main, symbols_textord, "\u0131", "\\i", true);
            defineSymbol(symbols_text, main, symbols_textord, "\u0237", "\\j", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xDF", "\\ss", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xE6", "\\ae", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xE6", "\\ae", true);
            defineSymbol(symbols_text, main, symbols_textord, "\u0153", "\\oe", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xF8", "\\o", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xC6", "\\AE", true);
            defineSymbol(symbols_text, main, symbols_textord, "\u0152", "\\OE", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xD8", "\\O", true);
            defineSymbol(symbols_text, main, symbols_accent, "\u02CA", "\\'");
            defineSymbol(symbols_text, main, symbols_accent, "\u02CB", "\\`");
            defineSymbol(symbols_text, main, symbols_accent, "\u02C6", "\\^");
            defineSymbol(symbols_text, main, symbols_accent, "\u02DC", "\\~");
            defineSymbol(symbols_text, main, symbols_accent, "\u02C9", "\\=");
            defineSymbol(symbols_text, main, symbols_accent, "\u02D8", "\\u");
            defineSymbol(symbols_text, main, symbols_accent, "\u02D9", "\\.");
            defineSymbol(symbols_text, main, symbols_accent, "\u02DA", "\\r");
            defineSymbol(symbols_text, main, symbols_accent, "\u02C7", "\\v");
            defineSymbol(symbols_text, main, symbols_accent, "\xA8", '\\"');
            defineSymbol(symbols_text, main, symbols_accent, "\u02DD", "\\H");
            defineSymbol(symbols_text, main, symbols_accent, "\u25EF", "\\textcircled");
            var ligatures = {
              "--": true,
              "---": true,
              "``": true,
              "''": true
            };
            defineSymbol(symbols_text, main, symbols_textord, "\u2013", "--");
            defineSymbol(symbols_text, main, symbols_textord, "\u2013", "\\textendash");
            defineSymbol(symbols_text, main, symbols_textord, "\u2014", "---");
            defineSymbol(symbols_text, main, symbols_textord, "\u2014", "\\textemdash");
            defineSymbol(symbols_text, main, symbols_textord, "\u2018", "`");
            defineSymbol(symbols_text, main, symbols_textord, "\u2018", "\\textquoteleft");
            defineSymbol(symbols_text, main, symbols_textord, "\u2019", "'");
            defineSymbol(symbols_text, main, symbols_textord, "\u2019", "\\textquoteright");
            defineSymbol(symbols_text, main, symbols_textord, "\u201C", "``");
            defineSymbol(symbols_text, main, symbols_textord, "\u201C", "\\textquotedblleft");
            defineSymbol(symbols_text, main, symbols_textord, "\u201D", "''");
            defineSymbol(symbols_text, main, symbols_textord, "\u201D", "\\textquotedblright");
            defineSymbol(symbols_math, main, symbols_textord, "\xB0", "\\degree", true);
            defineSymbol(symbols_text, main, symbols_textord, "\xB0", "\\degree");
            defineSymbol(symbols_text, main, symbols_textord, "\xB0", "\\textdegree", true);
            defineSymbol(symbols_math, main, mathord, "\xA3", "\\pounds");
            defineSymbol(symbols_math, main, mathord, "\xA3", "\\mathsterling", true);
            defineSymbol(symbols_text, main, mathord, "\xA3", "\\pounds");
            defineSymbol(symbols_text, main, mathord, "\xA3", "\\textsterling", true);
            defineSymbol(symbols_math, ams, symbols_textord, "\u2720", "\\maltese");
            defineSymbol(symbols_text, ams, symbols_textord, "\u2720", "\\maltese");
            defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "\\ ");
            defineSymbol(symbols_text, main, symbols_spacing, "\xA0", " ");
            defineSymbol(symbols_text, main, symbols_spacing, "\xA0", "~");
            var mathTextSymbols = '0123456789/@."';
            for (var symbols_i = 0; symbols_i < mathTextSymbols.length; symbols_i++) {
              var symbols_ch = mathTextSymbols.charAt(symbols_i);
              defineSymbol(symbols_math, main, symbols_textord, symbols_ch, symbols_ch);
            }
            var textSymbols = '0123456789!@*()-=+[]<>|";:?/.,';
            for (var src_symbols_i = 0; src_symbols_i < textSymbols.length; src_symbols_i++) {
              var _ch = textSymbols.charAt(src_symbols_i);
              defineSymbol(symbols_text, main, symbols_textord, _ch, _ch);
            }
            var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            for (var symbols_i2 = 0; symbols_i2 < letters.length; symbols_i2++) {
              var _ch2 = letters.charAt(symbols_i2);
              defineSymbol(symbols_math, main, mathord, _ch2, _ch2);
              defineSymbol(symbols_text, main, symbols_textord, _ch2, _ch2);
            }
            defineSymbol(symbols_math, ams, symbols_textord, "C", "\u2102");
            defineSymbol(symbols_text, ams, symbols_textord, "C", "\u2102");
            defineSymbol(symbols_math, ams, symbols_textord, "H", "\u210D");
            defineSymbol(symbols_text, ams, symbols_textord, "H", "\u210D");
            defineSymbol(symbols_math, ams, symbols_textord, "N", "\u2115");
            defineSymbol(symbols_text, ams, symbols_textord, "N", "\u2115");
            defineSymbol(symbols_math, ams, symbols_textord, "P", "\u2119");
            defineSymbol(symbols_text, ams, symbols_textord, "P", "\u2119");
            defineSymbol(symbols_math, ams, symbols_textord, "Q", "\u211A");
            defineSymbol(symbols_text, ams, symbols_textord, "Q", "\u211A");
            defineSymbol(symbols_math, ams, symbols_textord, "R", "\u211D");
            defineSymbol(symbols_text, ams, symbols_textord, "R", "\u211D");
            defineSymbol(symbols_math, ams, symbols_textord, "Z", "\u2124");
            defineSymbol(symbols_text, ams, symbols_textord, "Z", "\u2124");
            defineSymbol(symbols_math, main, mathord, "h", "\u210E");
            defineSymbol(symbols_text, main, mathord, "h", "\u210E");
            var symbols_wideChar = "";
            for (var symbols_i3 = 0; symbols_i3 < letters.length; symbols_i3++) {
              var _ch3 = letters.charAt(symbols_i3);
              symbols_wideChar = String.fromCharCode(55349, 56320 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56372 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56424 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56580 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56736 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56788 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56840 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 56944 + symbols_i3);
              defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              if (symbols_i3 < 26) {
                symbols_wideChar = String.fromCharCode(55349, 56632 + symbols_i3);
                defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
                defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
                symbols_wideChar = String.fromCharCode(55349, 56476 + symbols_i3);
                defineSymbol(symbols_math, main, mathord, _ch3, symbols_wideChar);
                defineSymbol(symbols_text, main, symbols_textord, _ch3, symbols_wideChar);
              }
            }
            symbols_wideChar = String.fromCharCode(55349, 56668);
            defineSymbol(symbols_math, main, mathord, "k", symbols_wideChar);
            defineSymbol(symbols_text, main, symbols_textord, "k", symbols_wideChar);
            for (var symbols_i4 = 0; symbols_i4 < 10; symbols_i4++) {
              var _ch4 = symbols_i4.toString();
              symbols_wideChar = String.fromCharCode(55349, 57294 + symbols_i4);
              defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 57314 + symbols_i4);
              defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 57324 + symbols_i4);
              defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
              symbols_wideChar = String.fromCharCode(55349, 57334 + symbols_i4);
              defineSymbol(symbols_math, main, mathord, _ch4, symbols_wideChar);
              defineSymbol(symbols_text, main, symbols_textord, _ch4, symbols_wideChar);
            }
            var extraLatin = "\xC7\xD0\xDE\xE7\xFE";
            for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
              var _ch5 = extraLatin.charAt(_i5);
              defineSymbol(symbols_math, main, mathord, _ch5, _ch5);
              defineSymbol(symbols_text, main, symbols_textord, _ch5, _ch5);
            }
            defineSymbol(symbols_text, main, symbols_textord, "\xF0", "\xF0");
            defineSymbol(symbols_text, main, symbols_textord, "\u2013", "\u2013");
            defineSymbol(symbols_text, main, symbols_textord, "\u2014", "\u2014");
            defineSymbol(symbols_text, main, symbols_textord, "\u2018", "\u2018");
            defineSymbol(symbols_text, main, symbols_textord, "\u2019", "\u2019");
            defineSymbol(symbols_text, main, symbols_textord, "\u201C", "\u201C");
            defineSymbol(symbols_text, main, symbols_textord, "\u201D", "\u201D");
            var wideLatinLetterData = [
              ["mathbf", "textbf", "Main-Bold"],
              // A-Z bold upright
              ["mathbf", "textbf", "Main-Bold"],
              // a-z bold upright
              ["mathdefault", "textit", "Math-Italic"],
              // A-Z italic
              ["mathdefault", "textit", "Math-Italic"],
              // a-z italic
              ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
              // A-Z bold italic
              ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
              // a-z bold italic
              // Map fancy A-Z letters to script, not calligraphic.
              // This aligns with unicode-math and math fonts (except Cambria Math).
              ["mathscr", "textscr", "Script-Regular"],
              // A-Z script
              ["", "", ""],
              // a-z script.  No font
              ["", "", ""],
              // A-Z bold script. No font
              ["", "", ""],
              // a-z bold script. No font
              ["mathfrak", "textfrak", "Fraktur-Regular"],
              // A-Z Fraktur
              ["mathfrak", "textfrak", "Fraktur-Regular"],
              // a-z Fraktur
              ["mathbb", "textbb", "AMS-Regular"],
              // A-Z double-struck
              ["mathbb", "textbb", "AMS-Regular"],
              // k double-struck
              ["", "", ""],
              // A-Z bold Fraktur No font metrics
              ["", "", ""],
              // a-z bold Fraktur.   No font.
              ["mathsf", "textsf", "SansSerif-Regular"],
              // A-Z sans-serif
              ["mathsf", "textsf", "SansSerif-Regular"],
              // a-z sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // A-Z bold sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // a-z bold sans-serif
              ["mathitsf", "textitsf", "SansSerif-Italic"],
              // A-Z italic sans-serif
              ["mathitsf", "textitsf", "SansSerif-Italic"],
              // a-z italic sans-serif
              ["", "", ""],
              // A-Z bold italic sans. No font
              ["", "", ""],
              // a-z bold italic sans. No font
              ["mathtt", "texttt", "Typewriter-Regular"],
              // A-Z monospace
              ["mathtt", "texttt", "Typewriter-Regular"]
            ];
            var wideNumeralData = [
              ["mathbf", "textbf", "Main-Bold"],
              // 0-9 bold
              ["", "", ""],
              // 0-9 double-struck. No KaTeX font.
              ["mathsf", "textsf", "SansSerif-Regular"],
              // 0-9 sans-serif
              ["mathboldsf", "textboldsf", "SansSerif-Bold"],
              // 0-9 bold sans-serif
              ["mathtt", "texttt", "Typewriter-Regular"]
            ];
            var wide_character_wideCharacterFont = function wideCharacterFont(wideChar, mode) {
              var H = wideChar.charCodeAt(0);
              var L = wideChar.charCodeAt(1);
              var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
              var j = mode === "math" ? 0 : 1;
              if (119808 <= codePoint && codePoint < 120484) {
                var i = Math.floor((codePoint - 119808) / 26);
                return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];
              } else if (120782 <= codePoint && codePoint <= 120831) {
                var _i = Math.floor((codePoint - 120782) / 10);
                return [wideNumeralData[_i][2], wideNumeralData[_i][j]];
              } else if (codePoint === 120485 || codePoint === 120486) {
                return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
              } else if (120486 < codePoint && codePoint < 120782) {
                return ["", ""];
              } else {
                throw new src_ParseError("Unsupported character: " + wideChar);
              }
            };
            var sizeStyleMap = [
              // Each element contains [textsize, scriptsize, scriptscriptsize].
              // The size mappings are taken from TeX with \normalsize=10pt.
              [1, 1, 1],
              // size1: [5, 5, 5]              \tiny
              [2, 1, 1],
              // size2: [6, 5, 5]
              [3, 1, 1],
              // size3: [7, 5, 5]              \scriptsize
              [4, 2, 1],
              // size4: [8, 6, 5]              \footnotesize
              [5, 2, 1],
              // size5: [9, 6, 5]              \small
              [6, 3, 1],
              // size6: [10, 7, 5]             \normalsize
              [7, 4, 2],
              // size7: [12, 8, 6]             \large
              [8, 6, 3],
              // size8: [14.4, 10, 7]          \Large
              [9, 7, 6],
              // size9: [17.28, 12, 10]        \LARGE
              [10, 8, 7],
              // size10: [20.74, 14.4, 12]     \huge
              [11, 10, 9]
            ];
            var sizeMultipliers = [
              // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
              // you change size indexes, change that function.
              0.5,
              0.6,
              0.7,
              0.8,
              0.9,
              1,
              1.2,
              1.44,
              1.728,
              2.074,
              2.488
            ];
            var sizeAtStyle = function sizeAtStyle2(size, style) {
              return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
            };
            var Options_Options = /* @__PURE__ */ function() {
              function Options(data) {
                this.style = void 0;
                this.color = void 0;
                this.size = void 0;
                this.textSize = void 0;
                this.phantom = void 0;
                this.font = void 0;
                this.fontFamily = void 0;
                this.fontWeight = void 0;
                this.fontShape = void 0;
                this.sizeMultiplier = void 0;
                this.maxSize = void 0;
                this._fontMetrics = void 0;
                this.style = data.style;
                this.color = data.color;
                this.size = data.size || Options.BASESIZE;
                this.textSize = data.textSize || this.size;
                this.phantom = !!data.phantom;
                this.font = data.font || "";
                this.fontFamily = data.fontFamily || "";
                this.fontWeight = data.fontWeight || "";
                this.fontShape = data.fontShape || "";
                this.sizeMultiplier = sizeMultipliers[this.size - 1];
                this.maxSize = data.maxSize;
                this._fontMetrics = void 0;
              }
              var _proto = Options.prototype;
              _proto.extend = function extend3(extension) {
                var data = {
                  style: this.style,
                  size: this.size,
                  textSize: this.textSize,
                  color: this.color,
                  phantom: this.phantom,
                  font: this.font,
                  fontFamily: this.fontFamily,
                  fontWeight: this.fontWeight,
                  fontShape: this.fontShape,
                  maxSize: this.maxSize
                };
                for (var key in extension) {
                  if (extension.hasOwnProperty(key)) {
                    data[key] = extension[key];
                  }
                }
                return new Options(data);
              };
              _proto.havingStyle = function havingStyle(style) {
                if (this.style === style) {
                  return this;
                } else {
                  return this.extend({
                    style,
                    size: sizeAtStyle(this.textSize, style)
                  });
                }
              };
              _proto.havingCrampedStyle = function havingCrampedStyle() {
                return this.havingStyle(this.style.cramp());
              };
              _proto.havingSize = function havingSize(size) {
                if (this.size === size && this.textSize === size) {
                  return this;
                } else {
                  return this.extend({
                    style: this.style.text(),
                    size,
                    textSize: size,
                    sizeMultiplier: sizeMultipliers[size - 1]
                  });
                }
              };
              _proto.havingBaseStyle = function havingBaseStyle(style) {
                style = style || this.style.text();
                var wantSize = sizeAtStyle(Options.BASESIZE, style);
                if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
                  return this;
                } else {
                  return this.extend({
                    style,
                    size: wantSize
                  });
                }
              };
              _proto.havingBaseSizing = function havingBaseSizing() {
                var size;
                switch (this.style.id) {
                  case 4:
                  case 5:
                    size = 3;
                    break;
                  case 6:
                  case 7:
                    size = 1;
                    break;
                  default:
                    size = 6;
                }
                return this.extend({
                  style: this.style.text(),
                  size
                });
              };
              _proto.withColor = function withColor(color3) {
                return this.extend({
                  color: color3
                });
              };
              _proto.withPhantom = function withPhantom() {
                return this.extend({
                  phantom: true
                });
              };
              _proto.withFont = function withFont(font) {
                return this.extend({
                  font
                });
              };
              _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {
                return this.extend({
                  fontFamily,
                  font: ""
                });
              };
              _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {
                return this.extend({
                  fontWeight,
                  font: ""
                });
              };
              _proto.withTextFontShape = function withTextFontShape(fontShape) {
                return this.extend({
                  fontShape,
                  font: ""
                });
              };
              _proto.sizingClasses = function sizingClasses(oldOptions) {
                if (oldOptions.size !== this.size) {
                  return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
                } else {
                  return [];
                }
              };
              _proto.baseSizingClasses = function baseSizingClasses() {
                if (this.size !== Options.BASESIZE) {
                  return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
                } else {
                  return [];
                }
              };
              _proto.fontMetrics = function fontMetrics() {
                if (!this._fontMetrics) {
                  this._fontMetrics = getGlobalMetrics(this.size);
                }
                return this._fontMetrics;
              };
              _proto.getColor = function getColor() {
                if (this.phantom) {
                  return "transparent";
                } else {
                  return this.color;
                }
              };
              return Options;
            }();
            Options_Options.BASESIZE = 6;
            var src_Options = Options_Options;
            var ptPerUnit = {
              // https://en.wikibooks.org/wiki/LaTeX/Lengths and
              // https://tex.stackexchange.com/a/8263
              "pt": 1,
              // TeX point
              "mm": 7227 / 2540,
              // millimeter
              "cm": 7227 / 254,
              // centimeter
              "in": 72.27,
              // inch
              "bp": 803 / 800,
              // big (PostScript) points
              "pc": 12,
              // pica
              "dd": 1238 / 1157,
              // didot
              "cc": 14856 / 1157,
              // cicero (12 didot)
              "nd": 685 / 642,
              // new didot
              "nc": 1370 / 107,
              // new cicero (12 new didot)
              "sp": 1 / 65536,
              // scaled point (TeX's internal smallest unit)
              // https://tex.stackexchange.com/a/41371
              "px": 803 / 800
              // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
            };
            var relativeUnit = {
              "ex": true,
              "em": true,
              "mu": true
            };
            var validUnit = function validUnit2(unit2) {
              if (typeof unit2 !== "string") {
                unit2 = unit2.unit;
              }
              return unit2 in ptPerUnit || unit2 in relativeUnit || unit2 === "ex";
            };
            var units_calculateSize = function calculateSize(sizeValue, options) {
              var scale;
              if (sizeValue.unit in ptPerUnit) {
                scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
              } else if (sizeValue.unit === "mu") {
                scale = options.fontMetrics().cssEmPerMu;
              } else {
                var unitOptions;
                if (options.style.isTight()) {
                  unitOptions = options.havingStyle(options.style.text());
                } else {
                  unitOptions = options;
                }
                if (sizeValue.unit === "ex") {
                  scale = unitOptions.fontMetrics().xHeight;
                } else if (sizeValue.unit === "em") {
                  scale = unitOptions.fontMetrics().quad;
                } else {
                  throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
                }
                if (unitOptions !== options) {
                  scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              return Math.min(sizeValue.number * scale, options.maxSize);
            };
            var mathitLetters = [
              "\\imath",
              "\u0131",
              // dotless i
              "\\jmath",
              "\u0237",
              // dotless j
              "\\pounds",
              "\\mathsterling",
              "\\textsterling",
              "\xA3"
            ];
            var buildCommon_lookupSymbol = function lookupSymbol(value, fontName, mode) {
              if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
                value = src_symbols[mode][value].replace;
              }
              return {
                value,
                metrics: getCharacterMetrics(value, fontName, mode)
              };
            };
            var buildCommon_makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {
              var lookup = buildCommon_lookupSymbol(value, fontName, mode);
              var metrics = lookup.metrics;
              value = lookup.value;
              var symbolNode;
              if (metrics) {
                var italic = metrics.italic;
                if (mode === "text" || options && options.font === "mathit") {
                  italic = 0;
                }
                symbolNode = new domTree_SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
              } else {
                typeof console !== "undefined" && console.warn("No character metrics for '" + value + "' in style '" + fontName + "'");
                symbolNode = new domTree_SymbolNode(value, 0, 0, 0, 0, 0, classes);
              }
              if (options) {
                symbolNode.maxFontSize = options.sizeMultiplier;
                if (options.style.isTight()) {
                  symbolNode.classes.push("mtight");
                }
                var color3 = options.getColor();
                if (color3) {
                  symbolNode.style.color = color3;
                }
              }
              return symbolNode;
            };
            var buildCommon_mathsym = function mathsym(value, mode, options, classes) {
              if (classes === void 0) {
                classes = [];
              }
              if (options && options.font && options.font === "boldsymbol" && buildCommon_lookupSymbol(value, "Main-Bold", mode).metrics) {
                return buildCommon_makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
              } else if (value === "\\" || src_symbols[mode][value].font === "main") {
                return buildCommon_makeSymbol(value, "Main-Regular", mode, options, classes);
              } else {
                return buildCommon_makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
              }
            };
            var buildCommon_mathdefault = function mathdefault(value, mode, options, classes) {
              if (/[0-9]/.test(value.charAt(0)) || // glyphs for \imath and \jmath do not exist in Math-Italic so we
              // need to use Main-Italic instead
              utils.contains(mathitLetters, value)) {
                return {
                  fontName: "Main-Italic",
                  fontClass: "mathit"
                };
              } else {
                return {
                  fontName: "Math-Italic",
                  fontClass: "mathdefault"
                };
              }
            };
            var buildCommon_mathnormal = function mathnormal(value, mode, options, classes) {
              if (utils.contains(mathitLetters, value)) {
                return {
                  fontName: "Main-Italic",
                  fontClass: "mathit"
                };
              } else if (/[0-9]/.test(value.charAt(0))) {
                return {
                  fontName: "Caligraphic-Regular",
                  fontClass: "mathcal"
                };
              } else {
                return {
                  fontName: "Math-Italic",
                  fontClass: "mathdefault"
                };
              }
            };
            var boldsymbol = function boldsymbol2(value, mode, options, classes) {
              if (buildCommon_lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
                return {
                  fontName: "Math-BoldItalic",
                  fontClass: "boldsymbol"
                };
              } else {
                return {
                  fontName: "Main-Bold",
                  fontClass: "mathbf"
                };
              }
            };
            var buildCommon_makeOrd = function makeOrd(group, options, type) {
              var mode = group.mode;
              var text = group.text;
              var classes = ["mord"];
              var isFont = mode === "math" || mode === "text" && options.font;
              var fontOrFamily = isFont ? options.font : options.fontFamily;
              if (text.charCodeAt(0) === 55349) {
                var _wideCharacterFont = wide_character_wideCharacterFont(text, mode), wideFontName = _wideCharacterFont[0], wideFontClass = _wideCharacterFont[1];
                return buildCommon_makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
              } else if (fontOrFamily) {
                var fontName;
                var fontClasses;
                if (fontOrFamily === "boldsymbol" || fontOrFamily === "mathnormal") {
                  var fontData = fontOrFamily === "boldsymbol" ? boldsymbol(text, mode, options, classes) : buildCommon_mathnormal(text, mode, options, classes);
                  fontName = fontData.fontName;
                  fontClasses = [fontData.fontClass];
                } else if (utils.contains(mathitLetters, text)) {
                  fontName = "Main-Italic";
                  fontClasses = ["mathit"];
                } else if (isFont) {
                  fontName = fontMap[fontOrFamily].fontName;
                  fontClasses = [fontOrFamily];
                } else {
                  fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
                  fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
                }
                if (buildCommon_lookupSymbol(text, fontName, mode).metrics) {
                  return buildCommon_makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
                } else if (ligatures.hasOwnProperty(text) && fontName.substr(0, 10) === "Typewriter") {
                  var parts = [];
                  for (var i = 0; i < text.length; i++) {
                    parts.push(buildCommon_makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));
                  }
                  return buildCommon_makeFragment(parts);
                }
              }
              if (type === "mathord") {
                var fontLookup = buildCommon_mathdefault(text, mode, options, classes);
                return buildCommon_makeSymbol(text, fontLookup.fontName, mode, options, classes.concat([fontLookup.fontClass]));
              } else if (type === "textord") {
                var font = src_symbols[mode][text] && src_symbols[mode][text].font;
                if (font === "ams") {
                  var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
                  return buildCommon_makeSymbol(text, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
                } else if (font === "main" || !font) {
                  var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
                  return buildCommon_makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
                } else {
                  var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
                  return buildCommon_makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
                }
              } else {
                throw new Error("unexpected type: " + type + " in makeOrd");
              }
            };
            var buildCommon_canCombine = function canCombine(prev, next) {
              if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
                return false;
              }
              for (var style in prev.style) {
                if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
                  return false;
                }
              }
              for (var _style in next.style) {
                if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
                  return false;
                }
              }
              return true;
            };
            var buildCommon_tryCombineChars = function tryCombineChars(chars) {
              for (var i = 0; i < chars.length - 1; i++) {
                var prev = chars[i];
                var next = chars[i + 1];
                if (prev instanceof domTree_SymbolNode && next instanceof domTree_SymbolNode && buildCommon_canCombine(prev, next)) {
                  prev.text += next.text;
                  prev.height = Math.max(prev.height, next.height);
                  prev.depth = Math.max(prev.depth, next.depth);
                  prev.italic = next.italic;
                  chars.splice(i + 1, 1);
                  i--;
                }
              }
              return chars;
            };
            var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
              var height = 0;
              var depth = 0;
              var maxFontSize = 0;
              for (var i = 0; i < elem.children.length; i++) {
                var child = elem.children[i];
                if (child.height > height) {
                  height = child.height;
                }
                if (child.depth > depth) {
                  depth = child.depth;
                }
                if (child.maxFontSize > maxFontSize) {
                  maxFontSize = child.maxFontSize;
                }
              }
              elem.height = height;
              elem.depth = depth;
              elem.maxFontSize = maxFontSize;
            };
            var buildCommon_makeSpan = function makeSpan(classes, children, options, style) {
              var span = new domTree_Span(classes, children, options, style);
              sizeElementFromChildren(span);
              return span;
            };
            var buildCommon_makeSvgSpan = function makeSvgSpan(classes, children, options, style) {
              return new domTree_Span(classes, children, options, style);
            };
            var makeLineSpan = function makeLineSpan2(className, options, thickness) {
              var line = buildCommon_makeSpan([className], [], options);
              line.height = thickness || options.fontMetrics().defaultRuleThickness;
              line.style.borderBottomWidth = line.height + "em";
              line.maxFontSize = 1;
              return line;
            };
            var buildCommon_makeAnchor = function makeAnchor(href, classes, children, options) {
              var anchor = new domTree_Anchor(href, classes, children, options);
              sizeElementFromChildren(anchor);
              return anchor;
            };
            var buildCommon_makeFragment = function makeFragment(children) {
              var fragment = new tree_DocumentFragment(children);
              sizeElementFromChildren(fragment);
              return fragment;
            };
            var buildCommon_wrapFragment = function wrapFragment(group, options) {
              if (group instanceof tree_DocumentFragment) {
                return buildCommon_makeSpan([], [group], options);
              }
              return group;
            };
            var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
              if (params.positionType === "individualShift") {
                var oldChildren = params.children;
                var children = [oldChildren[0]];
                var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
                var currPos = _depth;
                for (var i = 1; i < oldChildren.length; i++) {
                  var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;
                  var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);
                  currPos = currPos + diff;
                  children.push({
                    type: "kern",
                    size
                  });
                  children.push(oldChildren[i]);
                }
                return {
                  children,
                  depth: _depth
                };
              }
              var depth;
              if (params.positionType === "top") {
                var bottom = params.positionData;
                for (var _i = 0; _i < params.children.length; _i++) {
                  var child = params.children[_i];
                  bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
                }
                depth = bottom;
              } else if (params.positionType === "bottom") {
                depth = -params.positionData;
              } else {
                var firstChild = params.children[0];
                if (firstChild.type !== "elem") {
                  throw new Error('First child must have type "elem".');
                }
                if (params.positionType === "shift") {
                  depth = -firstChild.elem.depth - params.positionData;
                } else if (params.positionType === "firstBaseline") {
                  depth = -firstChild.elem.depth;
                } else {
                  throw new Error("Invalid positionType " + params.positionType + ".");
                }
              }
              return {
                children: params.children,
                depth
              };
            };
            var buildCommon_makeVList = function makeVList(params, options) {
              var _getVListChildrenAndD = getVListChildrenAndDepth(params), children = _getVListChildrenAndD.children, depth = _getVListChildrenAndD.depth;
              var pstrutSize = 0;
              for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.type === "elem") {
                  var elem = child.elem;
                  pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
                }
              }
              pstrutSize += 2;
              var pstrut = buildCommon_makeSpan(["pstrut"], []);
              pstrut.style.height = pstrutSize + "em";
              var realChildren = [];
              var minPos = depth;
              var maxPos = depth;
              var currPos = depth;
              for (var _i2 = 0; _i2 < children.length; _i2++) {
                var _child = children[_i2];
                if (_child.type === "kern") {
                  currPos += _child.size;
                } else {
                  var _elem = _child.elem;
                  var classes = _child.wrapperClasses || [];
                  var style = _child.wrapperStyle || {};
                  var childWrap = buildCommon_makeSpan(classes, [pstrut, _elem], void 0, style);
                  childWrap.style.top = -pstrutSize - currPos - _elem.depth + "em";
                  if (_child.marginLeft) {
                    childWrap.style.marginLeft = _child.marginLeft;
                  }
                  if (_child.marginRight) {
                    childWrap.style.marginRight = _child.marginRight;
                  }
                  realChildren.push(childWrap);
                  currPos += _elem.height + _elem.depth;
                }
                minPos = Math.min(minPos, currPos);
                maxPos = Math.max(maxPos, currPos);
              }
              var vlist = buildCommon_makeSpan(["vlist"], realChildren);
              vlist.style.height = maxPos + "em";
              var rows;
              if (minPos < 0) {
                var emptySpan = buildCommon_makeSpan([], []);
                var depthStrut = buildCommon_makeSpan(["vlist"], [emptySpan]);
                depthStrut.style.height = -minPos + "em";
                var topStrut = buildCommon_makeSpan(["vlist-s"], [new domTree_SymbolNode("\u200B")]);
                rows = [buildCommon_makeSpan(["vlist-r"], [vlist, topStrut]), buildCommon_makeSpan(["vlist-r"], [depthStrut])];
              } else {
                rows = [buildCommon_makeSpan(["vlist-r"], [vlist])];
              }
              var vtable = buildCommon_makeSpan(["vlist-t"], rows);
              if (rows.length === 2) {
                vtable.classes.push("vlist-t2");
              }
              vtable.height = maxPos;
              vtable.depth = -minPos;
              return vtable;
            };
            var buildCommon_makeGlue = function makeGlue(measurement, options) {
              var rule = buildCommon_makeSpan(["mspace"], [], options);
              var size = units_calculateSize(measurement, options);
              rule.style.marginRight = size + "em";
              return rule;
            };
            var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
              var baseFontName = "";
              switch (fontFamily) {
                case "amsrm":
                  baseFontName = "AMS";
                  break;
                case "textrm":
                  baseFontName = "Main";
                  break;
                case "textsf":
                  baseFontName = "SansSerif";
                  break;
                case "texttt":
                  baseFontName = "Typewriter";
                  break;
                default:
                  baseFontName = fontFamily;
              }
              var fontStylesName;
              if (fontWeight === "textbf" && fontShape === "textit") {
                fontStylesName = "BoldItalic";
              } else if (fontWeight === "textbf") {
                fontStylesName = "Bold";
              } else if (fontWeight === "textit") {
                fontStylesName = "Italic";
              } else {
                fontStylesName = "Regular";
              }
              return baseFontName + "-" + fontStylesName;
            };
            var fontMap = {
              // styles
              "mathbf": {
                variant: "bold",
                fontName: "Main-Bold"
              },
              "mathrm": {
                variant: "normal",
                fontName: "Main-Regular"
              },
              "textit": {
                variant: "italic",
                fontName: "Main-Italic"
              },
              "mathit": {
                variant: "italic",
                fontName: "Main-Italic"
              },
              // Default math font, "mathnormal" and "boldsymbol" are missing because they
              // require the use of several fonts: Main-Italic and Math-Italic for default
              // math font, Main-Italic, Math-Italic, Caligraphic for "mathnormal", and
              // Math-BoldItalic and Main-Bold for "boldsymbol".  This is handled by a
              // special case in makeOrd which ends up calling mathdefault, mathnormal,
              // and boldsymbol.
              // families
              "mathbb": {
                variant: "double-struck",
                fontName: "AMS-Regular"
              },
              "mathcal": {
                variant: "script",
                fontName: "Caligraphic-Regular"
              },
              "mathfrak": {
                variant: "fraktur",
                fontName: "Fraktur-Regular"
              },
              "mathscr": {
                variant: "script",
                fontName: "Script-Regular"
              },
              "mathsf": {
                variant: "sans-serif",
                fontName: "SansSerif-Regular"
              },
              "mathtt": {
                variant: "monospace",
                fontName: "Typewriter-Regular"
              }
            };
            var svgData = {
              //   path, width, height
              vec: ["vec", 0.471, 0.714],
              // values from the font glyph
              oiintSize1: ["oiintSize1", 0.957, 0.499],
              // oval to overlay the integrand
              oiintSize2: ["oiintSize2", 1.472, 0.659],
              oiiintSize1: ["oiiintSize1", 1.304, 0.499],
              oiiintSize2: ["oiiintSize2", 1.98, 0.659]
            };
            var buildCommon_staticSvg = function staticSvg(value, options) {
              var _svgData$value = svgData[value], pathName = _svgData$value[0], width = _svgData$value[1], height = _svgData$value[2];
              var path = new domTree_PathNode(pathName);
              var svgNode2 = new SvgNode([path], {
                "width": width + "em",
                "height": height + "em",
                // Override CSS rule `.katex svg { width: 100% }`
                "style": "width:" + width + "em",
                "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
                "preserveAspectRatio": "xMinYMin"
              });
              var span = buildCommon_makeSvgSpan(["overlay"], [svgNode2], options);
              span.height = height;
              span.style.height = height + "em";
              span.style.width = width + "em";
              return span;
            };
            var buildCommon = {
              fontMap,
              makeSymbol: buildCommon_makeSymbol,
              mathsym: buildCommon_mathsym,
              makeSpan: buildCommon_makeSpan,
              makeSvgSpan: buildCommon_makeSvgSpan,
              makeLineSpan,
              makeAnchor: buildCommon_makeAnchor,
              makeFragment: buildCommon_makeFragment,
              wrapFragment: buildCommon_wrapFragment,
              makeVList: buildCommon_makeVList,
              makeOrd: buildCommon_makeOrd,
              makeGlue: buildCommon_makeGlue,
              staticSvg: buildCommon_staticSvg,
              svgData,
              tryCombineChars: buildCommon_tryCombineChars
            };
            function assertNodeType(node, type) {
              var typedNode = checkNodeType(node, type);
              if (!typedNode) {
                throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
              }
              return typedNode;
            }
            function checkNodeType(node, type) {
              if (node && node.type === type) {
                return node;
              }
              return null;
            }
            function assertAtomFamily(node, family) {
              var typedNode = checkAtomFamily(node, family);
              if (!typedNode) {
                throw new Error('Expected node of type "atom" and family "' + family + '", but got ' + (node ? node.type === "atom" ? "atom of family " + node.family : "node of type " + node.type : String(node)));
              }
              return typedNode;
            }
            function checkAtomFamily(node, family) {
              return node && node.type === "atom" && node.family === family ? node : null;
            }
            function assertSymbolNodeType(node) {
              var typedNode = checkSymbolNodeType(node);
              if (!typedNode) {
                throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
              }
              return typedNode;
            }
            function checkSymbolNodeType(node) {
              if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
                return node;
              }
              return null;
            }
            var thinspace = {
              number: 3,
              unit: "mu"
            };
            var mediumspace = {
              number: 4,
              unit: "mu"
            };
            var thickspace = {
              number: 5,
              unit: "mu"
            };
            var spacings = {
              mord: {
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                minner: thinspace
              },
              mop: {
                mord: thinspace,
                mop: thinspace,
                mrel: thickspace,
                minner: thinspace
              },
              mbin: {
                mord: mediumspace,
                mop: mediumspace,
                mopen: mediumspace,
                minner: mediumspace
              },
              mrel: {
                mord: thickspace,
                mop: thickspace,
                mopen: thickspace,
                minner: thickspace
              },
              mopen: {},
              mclose: {
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                minner: thinspace
              },
              mpunct: {
                mord: thinspace,
                mop: thinspace,
                mrel: thickspace,
                mopen: thinspace,
                mclose: thinspace,
                mpunct: thinspace,
                minner: thinspace
              },
              minner: {
                mord: thinspace,
                mop: thinspace,
                mbin: mediumspace,
                mrel: thickspace,
                mopen: thinspace,
                mpunct: thinspace,
                minner: thinspace
              }
            };
            var tightSpacings = {
              mord: {
                mop: thinspace
              },
              mop: {
                mord: thinspace,
                mop: thinspace
              },
              mbin: {},
              mrel: {},
              mopen: {},
              mclose: {
                mop: thinspace
              },
              mpunct: {},
              minner: {
                mop: thinspace
              }
            };
            var _functions = {};
            var _htmlGroupBuilders = {};
            var _mathmlGroupBuilders = {};
            function defineFunction(_ref) {
              var type = _ref.type, nodeType = _ref.nodeType, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder = _ref.htmlBuilder, mathmlBuilder = _ref.mathmlBuilder;
              var data = {
                type,
                numArgs: props.numArgs,
                argTypes: props.argTypes,
                greediness: props.greediness === void 0 ? 1 : props.greediness,
                allowedInText: !!props.allowedInText,
                allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
                numOptionalArgs: props.numOptionalArgs || 0,
                infix: !!props.infix,
                consumeMode: props.consumeMode,
                handler
              };
              for (var i = 0; i < names.length; ++i) {
                _functions[names[i]] = data;
              }
              if (type) {
                if (htmlBuilder) {
                  _htmlGroupBuilders[type] = htmlBuilder;
                }
                if (mathmlBuilder) {
                  _mathmlGroupBuilders[type] = mathmlBuilder;
                }
              }
            }
            function defineFunctionBuilders(_ref2) {
              var type = _ref2.type, htmlBuilder = _ref2.htmlBuilder, mathmlBuilder = _ref2.mathmlBuilder;
              defineFunction({
                type,
                names: [],
                props: {
                  numArgs: 0
                },
                handler: function handler() {
                  throw new Error("Should never be called.");
                },
                htmlBuilder,
                mathmlBuilder
              });
            }
            var defineFunction_ordargument = function ordargument(arg) {
              var node = checkNodeType(arg, "ordgroup");
              return node ? node.body : [arg];
            };
            var buildHTML_makeSpan = buildCommon.makeSpan;
            var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
            var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
            var buildHTML_styleMap = {
              "display": src_Style.DISPLAY,
              "text": src_Style.TEXT,
              "script": src_Style.SCRIPT,
              "scriptscript": src_Style.SCRIPTSCRIPT
            };
            var DomEnum = {
              mord: "mord",
              mop: "mop",
              mbin: "mbin",
              mrel: "mrel",
              mopen: "mopen",
              mclose: "mclose",
              mpunct: "mpunct",
              minner: "minner"
            };
            var buildHTML_buildExpression = function buildExpression(expression, options, isRealGroup, surrounding) {
              if (surrounding === void 0) {
                surrounding = [null, null];
              }
              var groups = [];
              for (var i = 0; i < expression.length; i++) {
                var output = buildHTML_buildGroup(expression[i], options);
                if (output instanceof tree_DocumentFragment) {
                  var children = output.children;
                  groups.push.apply(groups, children);
                } else {
                  groups.push(output);
                }
              }
              if (!isRealGroup) {
                return groups;
              }
              var glueOptions = options;
              if (expression.length === 1) {
                var node = checkNodeType(expression[0], "sizing") || checkNodeType(expression[0], "styling");
                if (!node) {
                } else if (node.type === "sizing") {
                  glueOptions = options.havingSize(node.size);
                } else if (node.type === "styling") {
                  glueOptions = options.havingStyle(buildHTML_styleMap[node.style]);
                }
              }
              var dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
              var dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
              traverseNonSpaceNodes(groups, function(node2, prev) {
                var prevType = prev.classes[0];
                var type = node2.classes[0];
                if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
                  prev.classes[0] = "mord";
                } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
                  node2.classes[0] = "mord";
                }
              }, {
                node: dummyPrev
              }, dummyNext);
              traverseNonSpaceNodes(groups, function(node2, prev) {
                var prevType = getTypeOfDomTree(prev);
                var type = getTypeOfDomTree(node2);
                var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
                if (space) {
                  return buildCommon.makeGlue(space, glueOptions);
                }
              }, {
                node: dummyPrev
              }, dummyNext);
              return groups;
            };
            var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next) {
              if (next) {
                nodes.push(next);
              }
              var i = 0;
              for (; i < nodes.length; i++) {
                var node = nodes[i];
                var partialGroup = buildHTML_checkPartialGroup(node);
                if (partialGroup) {
                  traverseNonSpaceNodes2(partialGroup.children, callback, prev);
                  continue;
                }
                if (node.classes[0] === "mspace") {
                  continue;
                }
                var result = callback(node, prev.node);
                if (result) {
                  if (prev.insertAfter) {
                    prev.insertAfter(result);
                  } else {
                    nodes.unshift(result);
                    i++;
                  }
                }
                prev.node = node;
                prev.insertAfter = /* @__PURE__ */ function(index) {
                  return function(n) {
                    nodes.splice(index + 1, 0, n);
                    i++;
                  };
                }(i);
              }
              if (next) {
                nodes.pop();
              }
            };
            var buildHTML_checkPartialGroup = function checkPartialGroup(node) {
              if (node instanceof tree_DocumentFragment || node instanceof domTree_Anchor) {
                return node;
              }
              return null;
            };
            var getOutermostNode = function getOutermostNode2(node, side) {
              var partialGroup = buildHTML_checkPartialGroup(node);
              if (partialGroup) {
                var children = partialGroup.children;
                if (children.length) {
                  if (side === "right") {
                    return getOutermostNode2(children[children.length - 1], "right");
                  } else if (side === "left") {
                    return getOutermostNode2(children[0], "left");
                  }
                }
              }
              return node;
            };
            var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
              if (!node) {
                return null;
              }
              if (side) {
                node = getOutermostNode(node, side);
              }
              return DomEnum[node.classes[0]] || null;
            };
            var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
              var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
              return buildHTML_makeSpan(classes.concat(moreClasses));
            };
            var buildHTML_buildGroup = function buildGroup(group, options, baseOptions) {
              if (!group) {
                return buildHTML_makeSpan();
              }
              if (_htmlGroupBuilders[group.type]) {
                var groupNode = _htmlGroupBuilders[group.type](group, options);
                if (baseOptions && options.size !== baseOptions.size) {
                  groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
                  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
                  groupNode.height *= multiplier;
                  groupNode.depth *= multiplier;
                }
                return groupNode;
              } else {
                throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
              }
            };
            function buildHTMLUnbreakable(children, options) {
              var body = buildHTML_makeSpan(["base"], children, options);
              var strut = buildHTML_makeSpan(["strut"]);
              strut.style.height = body.height + body.depth + "em";
              strut.style.verticalAlign = -body.depth + "em";
              body.children.unshift(strut);
              return body;
            }
            function buildHTML(tree, options) {
              var tag = null;
              if (tree.length === 1 && tree[0].type === "tag") {
                tag = tree[0].tag;
                tree = tree[0].body;
              }
              var expression = buildHTML_buildExpression(tree, options, true);
              var children = [];
              var parts = [];
              for (var i = 0; i < expression.length; i++) {
                parts.push(expression[i]);
                if (expression[i].hasClass("mbin") || expression[i].hasClass("mrel") || expression[i].hasClass("allowbreak")) {
                  var nobreak = false;
                  while (i < expression.length - 1 && expression[i + 1].hasClass("mspace") && !expression[i + 1].hasClass("newline")) {
                    i++;
                    parts.push(expression[i]);
                    if (expression[i].hasClass("nobreak")) {
                      nobreak = true;
                    }
                  }
                  if (!nobreak) {
                    children.push(buildHTMLUnbreakable(parts, options));
                    parts = [];
                  }
                } else if (expression[i].hasClass("newline")) {
                  parts.pop();
                  if (parts.length > 0) {
                    children.push(buildHTMLUnbreakable(parts, options));
                    parts = [];
                  }
                  children.push(expression[i]);
                }
              }
              if (parts.length > 0) {
                children.push(buildHTMLUnbreakable(parts, options));
              }
              var tagChild;
              if (tag) {
                tagChild = buildHTMLUnbreakable(buildHTML_buildExpression(tag, options, true));
                tagChild.classes = ["tag"];
                children.push(tagChild);
              }
              var htmlNode = buildHTML_makeSpan(["katex-html"], children);
              htmlNode.setAttribute("aria-hidden", "true");
              if (tagChild) {
                var strut = tagChild.children[0];
                strut.style.height = htmlNode.height + htmlNode.depth + "em";
                strut.style.verticalAlign = -htmlNode.depth + "em";
              }
              return htmlNode;
            }
            function newDocumentFragment(children) {
              return new tree_DocumentFragment(children);
            }
            var mathMLTree_MathNode = /* @__PURE__ */ function() {
              function MathNode(type, children) {
                this.type = void 0;
                this.attributes = void 0;
                this.children = void 0;
                this.type = type;
                this.attributes = {};
                this.children = children || [];
              }
              var _proto = MathNode.prototype;
              _proto.setAttribute = function setAttribute(name2, value) {
                this.attributes[name2] = value;
              };
              _proto.getAttribute = function getAttribute(name2) {
                return this.attributes[name2];
              };
              _proto.toNode = function toNode() {
                var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
                for (var attr in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                    node.setAttribute(attr, this.attributes[attr]);
                  }
                }
                for (var i = 0; i < this.children.length; i++) {
                  node.appendChild(this.children[i].toNode());
                }
                return node;
              };
              _proto.toMarkup = function toMarkup() {
                var markup = "<" + this.type;
                for (var attr in this.attributes) {
                  if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                    markup += " " + attr + '="';
                    markup += utils.escape(this.attributes[attr]);
                    markup += '"';
                  }
                }
                markup += ">";
                for (var i = 0; i < this.children.length; i++) {
                  markup += this.children[i].toMarkup();
                }
                markup += "</" + this.type + ">";
                return markup;
              };
              _proto.toText = function toText() {
                return this.children.map(function(child) {
                  return child.toText();
                }).join("");
              };
              return MathNode;
            }();
            var mathMLTree_TextNode = /* @__PURE__ */ function() {
              function TextNode(text) {
                this.text = void 0;
                this.text = text;
              }
              var _proto2 = TextNode.prototype;
              _proto2.toNode = function toNode() {
                return document.createTextNode(this.text);
              };
              _proto2.toMarkup = function toMarkup() {
                return utils.escape(this.toText());
              };
              _proto2.toText = function toText() {
                return this.text;
              };
              return TextNode;
            }();
            var SpaceNode = /* @__PURE__ */ function() {
              function SpaceNode2(width) {
                this.width = void 0;
                this.character = void 0;
                this.width = width;
                if (width >= 0.05555 && width <= 0.05556) {
                  this.character = "\u200A";
                } else if (width >= 0.1666 && width <= 0.1667) {
                  this.character = "\u2009";
                } else if (width >= 0.2222 && width <= 0.2223) {
                  this.character = "\u2005";
                } else if (width >= 0.2777 && width <= 0.2778) {
                  this.character = "\u2005\u200A";
                } else if (width >= -0.05556 && width <= -0.05555) {
                  this.character = "\u200A\u2063";
                } else if (width >= -0.1667 && width <= -0.1666) {
                  this.character = "\u2009\u2063";
                } else if (width >= -0.2223 && width <= -0.2222) {
                  this.character = "\u205F\u2063";
                } else if (width >= -0.2778 && width <= -0.2777) {
                  this.character = "\u2005\u2063";
                } else {
                  this.character = null;
                }
              }
              var _proto3 = SpaceNode2.prototype;
              _proto3.toNode = function toNode() {
                if (this.character) {
                  return document.createTextNode(this.character);
                } else {
                  var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                  node.setAttribute("width", this.width + "em");
                  return node;
                }
              };
              _proto3.toMarkup = function toMarkup() {
                if (this.character) {
                  return "<mtext>" + this.character + "</mtext>";
                } else {
                  return '<mspace width="' + this.width + 'em"/>';
                }
              };
              _proto3.toText = function toText() {
                if (this.character) {
                  return this.character;
                } else {
                  return " ";
                }
              };
              return SpaceNode2;
            }();
            var mathMLTree = {
              MathNode: mathMLTree_MathNode,
              TextNode: mathMLTree_TextNode,
              SpaceNode,
              newDocumentFragment
            };
            var buildMathML_makeText = function makeText(text, mode, options) {
              if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === "tt" || options.font && options.font.substr(4, 2) === "tt"))) {
                text = src_symbols[mode][text].replace;
              }
              return new mathMLTree.TextNode(text);
            };
            var buildMathML_makeRow = function makeRow(body) {
              if (body.length === 1) {
                return body[0];
              } else {
                return new mathMLTree.MathNode("mrow", body);
              }
            };
            var buildMathML_getVariant = function getVariant(group, options) {
              if (options.fontFamily === "texttt") {
                return "monospace";
              } else if (options.fontFamily === "textsf") {
                if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                  return "sans-serif-bold-italic";
                } else if (options.fontShape === "textit") {
                  return "sans-serif-italic";
                } else if (options.fontWeight === "textbf") {
                  return "bold-sans-serif";
                } else {
                  return "sans-serif";
                }
              } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                return "bold-italic";
              } else if (options.fontShape === "textit") {
                return "italic";
              } else if (options.fontWeight === "textbf") {
                return "bold";
              }
              var font = options.font;
              if (!font || font === "mathnormal") {
                return null;
              }
              var mode = group.mode;
              if (font === "mathit") {
                return "italic";
              } else if (font === "boldsymbol") {
                return "bold-italic";
              }
              var text = group.text;
              if (utils.contains(["\\imath", "\\jmath"], text)) {
                return null;
              }
              if (src_symbols[mode][text] && src_symbols[mode][text].replace) {
                text = src_symbols[mode][text].replace;
              }
              var fontName = buildCommon.fontMap[font].fontName;
              if (getCharacterMetrics(text, fontName, mode)) {
                return buildCommon.fontMap[font].variant;
              }
              return null;
            };
            var buildMathML_buildExpression = function buildExpression(expression, options) {
              var groups = [];
              var lastGroup;
              for (var i = 0; i < expression.length; i++) {
                var group = buildMathML_buildGroup(expression[i], options);
                if (group instanceof mathMLTree_MathNode && lastGroup instanceof mathMLTree_MathNode) {
                  if (group.type === "mtext" && lastGroup.type === "mtext" && group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                    var _lastGroup$children;
                    (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, group.children);
                    continue;
                  } else if (group.type === "mn" && lastGroup.type === "mn") {
                    var _lastGroup$children2;
                    (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, group.children);
                    continue;
                  } else if (group.type === "mi" && group.children.length === 1 && lastGroup.type === "mn") {
                    var child = group.children[0];
                    if (child instanceof mathMLTree_TextNode && child.text === ".") {
                      var _lastGroup$children3;
                      (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, group.children);
                      continue;
                    }
                  } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                    var lastChild = lastGroup.children[0];
                    if (lastChild instanceof mathMLTree_TextNode && lastChild.text === "\u0338" && (group.type === "mo" || group.type === "mi" || group.type === "mn")) {
                      var _child = group.children[0];
                      if (_child instanceof mathMLTree_TextNode && _child.text.length > 0) {
                        _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
                        groups.pop();
                      }
                    }
                  }
                }
                groups.push(group);
                lastGroup = group;
              }
              return groups;
            };
            var buildExpressionRow = function buildExpressionRow2(expression, options) {
              return buildMathML_makeRow(buildMathML_buildExpression(expression, options));
            };
            var buildMathML_buildGroup = function buildGroup(group, options) {
              if (!group) {
                return new mathMLTree.MathNode("mrow");
              }
              if (_mathmlGroupBuilders[group.type]) {
                var result = _mathmlGroupBuilders[group.type](group, options);
                return result;
              } else {
                throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
              }
            };
            function buildMathML(tree, texExpression, options) {
              var expression = buildMathML_buildExpression(tree, options);
              var wrapper;
              if (expression.length === 1 && expression[0] instanceof mathMLTree_MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
                wrapper = expression[0];
              } else {
                wrapper = new mathMLTree.MathNode("mrow", expression);
              }
              var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
              annotation.setAttribute("encoding", "application/x-tex");
              var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
              var math = new mathMLTree.MathNode("math", [semantics]);
              return buildCommon.makeSpan(["katex-mathml"], [math]);
            }
            var buildTree_optionsFromSettings = function optionsFromSettings(settings) {
              return new src_Options({
                style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
                maxSize: settings.maxSize
              });
            };
            var buildTree_displayWrap = function displayWrap(node, settings) {
              if (settings.displayMode) {
                var classes = ["katex-display"];
                if (settings.leqno) {
                  classes.push("leqno");
                }
                if (settings.fleqn) {
                  classes.push("fleqn");
                }
                node = buildCommon.makeSpan(classes, [node]);
              }
              return node;
            };
            var buildTree_buildTree = function buildTree(tree, expression, settings) {
              var options = buildTree_optionsFromSettings(settings);
              var mathMLNode = buildMathML(tree, expression, options);
              var htmlNode = buildHTML(tree, options);
              var katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
              return buildTree_displayWrap(katexNode, settings);
            };
            var buildTree_buildHTMLTree = function buildHTMLTree(tree, expression, settings) {
              var options = buildTree_optionsFromSettings(settings);
              var htmlNode = buildHTML(tree, options);
              var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
              return buildTree_displayWrap(katexNode, settings);
            };
            var src_buildTree = buildTree_buildTree;
            var stretchyCodePoint = {
              widehat: "^",
              widecheck: "\u02C7",
              widetilde: "~",
              utilde: "~",
              overleftarrow: "\u2190",
              underleftarrow: "\u2190",
              xleftarrow: "\u2190",
              overrightarrow: "\u2192",
              underrightarrow: "\u2192",
              xrightarrow: "\u2192",
              underbrace: "\u23DF",
              overbrace: "\u23DE",
              overgroup: "\u23E0",
              undergroup: "\u23E1",
              overleftrightarrow: "\u2194",
              underleftrightarrow: "\u2194",
              xleftrightarrow: "\u2194",
              Overrightarrow: "\u21D2",
              xRightarrow: "\u21D2",
              overleftharpoon: "\u21BC",
              xleftharpoonup: "\u21BC",
              overrightharpoon: "\u21C0",
              xrightharpoonup: "\u21C0",
              xLeftarrow: "\u21D0",
              xLeftrightarrow: "\u21D4",
              xhookleftarrow: "\u21A9",
              xhookrightarrow: "\u21AA",
              xmapsto: "\u21A6",
              xrightharpoondown: "\u21C1",
              xleftharpoondown: "\u21BD",
              xrightleftharpoons: "\u21CC",
              xleftrightharpoons: "\u21CB",
              xtwoheadleftarrow: "\u219E",
              xtwoheadrightarrow: "\u21A0",
              xlongequal: "=",
              xtofrom: "\u21C4",
              xrightleftarrows: "\u21C4",
              xrightequilibrium: "\u21CC",
              // Not a perfect match.
              xleftequilibrium: "\u21CB"
              // None better available.
            };
            var stretchy_mathMLnode = function mathMLnode(label) {
              var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.substr(1)])]);
              node.setAttribute("stretchy", "true");
              return node;
            };
            var katexImagesData = {
              //   path(s), minWidth, height, align
              overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
              overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
              underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
              underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
              xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
              xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
              Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
              xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
              xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
              overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
              xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
              xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
              overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
              xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
              xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
              xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
              xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
              xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
              overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
              overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
              underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
              underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
              xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
              xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
              xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
              xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
              xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
              xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
              overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
              underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
              overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
              undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
              xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
              xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
              // The next three arrows are from the mhchem package.
              // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
              // document as \xrightarrow or \xrightleftharpoons. Those have
              // min-length = 1.75em, so we set min-length on these next three to match.
              xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
              xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
              xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
            };
            var groupLength = function groupLength2(arg) {
              if (arg.type === "ordgroup") {
                return arg.body.length;
              } else {
                return 1;
              }
            };
            var stretchy_svgSpan = function svgSpan(group, options) {
              function buildSvgSpan_() {
                var viewBoxWidth = 4e5;
                var label = group.label.substr(1);
                if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
                  var grp = group;
                  var numChars = groupLength(grp.base);
                  var viewBoxHeight;
                  var pathName;
                  var _height;
                  if (numChars > 5) {
                    if (label === "widehat" || label === "widecheck") {
                      viewBoxHeight = 420;
                      viewBoxWidth = 2364;
                      _height = 0.42;
                      pathName = label + "4";
                    } else {
                      viewBoxHeight = 312;
                      viewBoxWidth = 2340;
                      _height = 0.34;
                      pathName = "tilde4";
                    }
                  } else {
                    var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                    if (label === "widehat" || label === "widecheck") {
                      viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                      viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                      _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                      pathName = label + imgIndex;
                    } else {
                      viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                      viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                      _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                      pathName = "tilde" + imgIndex;
                    }
                  }
                  var path = new domTree_PathNode(pathName);
                  var svgNode2 = new SvgNode([path], {
                    "width": "100%",
                    "height": _height + "em",
                    "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                    "preserveAspectRatio": "none"
                  });
                  return {
                    span: buildCommon.makeSvgSpan([], [svgNode2], options),
                    minWidth: 0,
                    height: _height
                  };
                } else {
                  var spans = [];
                  var data = katexImagesData[label];
                  var paths = data[0], _minWidth = data[1], _viewBoxHeight = data[2];
                  var _height2 = _viewBoxHeight / 1e3;
                  var numSvgChildren = paths.length;
                  var widthClasses;
                  var aligns;
                  if (numSvgChildren === 1) {
                    var align1 = data[3];
                    widthClasses = ["hide-tail"];
                    aligns = [align1];
                  } else if (numSvgChildren === 2) {
                    widthClasses = ["halfarrow-left", "halfarrow-right"];
                    aligns = ["xMinYMin", "xMaxYMin"];
                  } else if (numSvgChildren === 3) {
                    widthClasses = ["brace-left", "brace-center", "brace-right"];
                    aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                  } else {
                    throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
                  }
                  for (var i = 0; i < numSvgChildren; i++) {
                    var _path = new domTree_PathNode(paths[i]);
                    var _svgNode = new SvgNode([_path], {
                      "width": "400em",
                      "height": _height2 + "em",
                      "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                      "preserveAspectRatio": aligns[i] + " slice"
                    });
                    var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);
                    if (numSvgChildren === 1) {
                      return {
                        span: _span,
                        minWidth: _minWidth,
                        height: _height2
                      };
                    } else {
                      _span.style.height = _height2 + "em";
                      spans.push(_span);
                    }
                  }
                  return {
                    span: buildCommon.makeSpan(["stretchy"], spans, options),
                    minWidth: _minWidth,
                    height: _height2
                  };
                }
              }
              var _buildSvgSpan_ = buildSvgSpan_(), span = _buildSvgSpan_.span, minWidth = _buildSvgSpan_.minWidth, height = _buildSvgSpan_.height;
              span.height = height;
              span.style.height = height + "em";
              if (minWidth > 0) {
                span.style.minWidth = minWidth + "em";
              }
              return span;
            };
            var stretchy_encloseSpan = function encloseSpan(inner, label, pad2, options) {
              var img;
              var totalHeight = inner.height + inner.depth + 2 * pad2;
              if (/fbox|color/.test(label)) {
                img = buildCommon.makeSpan(["stretchy", label], [], options);
                if (label === "fbox") {
                  var color3 = options.color && options.getColor();
                  if (color3) {
                    img.style.borderColor = color3;
                  }
                }
              } else {
                var lines = [];
                if (/^[bx]cancel$/.test(label)) {
                  lines.push(new LineNode({
                    "x1": "0",
                    "y1": "0",
                    "x2": "100%",
                    "y2": "100%",
                    "stroke-width": "0.046em"
                  }));
                }
                if (/^x?cancel$/.test(label)) {
                  lines.push(new LineNode({
                    "x1": "0",
                    "y1": "100%",
                    "x2": "100%",
                    "y2": "0",
                    "stroke-width": "0.046em"
                  }));
                }
                var svgNode2 = new SvgNode(lines, {
                  "width": "100%",
                  "height": totalHeight + "em"
                });
                img = buildCommon.makeSvgSpan([], [svgNode2], options);
              }
              img.height = totalHeight;
              img.style.height = totalHeight + "em";
              return img;
            };
            var stretchy = {
              encloseSpan: stretchy_encloseSpan,
              mathMLnode: stretchy_mathMLnode,
              svgSpan: stretchy_svgSpan
            };
            var accent_htmlBuilder = function htmlBuilder(grp, options) {
              var base;
              var group;
              var supSub = checkNodeType(grp, "supsub");
              var supSubGroup;
              if (supSub) {
                group = assertNodeType(supSub.base, "accent");
                base = group.base;
                supSub.base = base;
                supSubGroup = assertSpan(buildHTML_buildGroup(supSub, options));
                supSub.base = group;
              } else {
                group = assertNodeType(grp, "accent");
                base = group.base;
              }
              var body = buildHTML_buildGroup(base, options.havingCrampedStyle());
              var mustShift = group.isShifty && utils.isCharacterBox(base);
              var skew = 0;
              if (mustShift) {
                var baseChar = utils.getBaseElem(base);
                var baseGroup = buildHTML_buildGroup(baseChar, options.havingCrampedStyle());
                skew = assertSymbolDomNode(baseGroup).skew;
              }
              var clearance = Math.min(body.height, options.fontMetrics().xHeight);
              var accentBody;
              if (!group.isStretchy) {
                var accent;
                var width;
                if (group.label === "\\vec") {
                  accent = buildCommon.staticSvg("vec", options);
                  width = buildCommon.svgData.vec[1];
                } else {
                  accent = buildCommon.makeSymbol(group.label, "Main-Regular", group.mode, options);
                  accent.italic = 0;
                  width = accent.width;
                }
                accentBody = buildCommon.makeSpan(["accent-body"], [accent]);
                var accentFull = group.label === "\\textcircled";
                if (accentFull) {
                  accentBody.classes.push("accent-full");
                  clearance = body.height;
                }
                var left = skew;
                if (!accentFull) {
                  left -= width / 2;
                }
                accentBody.style.left = left + "em";
                if (group.label === "\\textcircled") {
                  accentBody.style.top = ".2em";
                }
                accentBody = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "kern",
                    size: -clearance
                  }, {
                    type: "elem",
                    elem: accentBody
                  }]
                }, options);
              } else {
                accentBody = stretchy.svgSpan(group, options);
                accentBody = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "elem",
                    elem: accentBody,
                    wrapperClasses: ["svg-align"],
                    wrapperStyle: skew > 0 ? {
                      width: "calc(100% - " + 2 * skew + "em)",
                      marginLeft: 2 * skew + "em"
                    } : void 0
                  }]
                }, options);
              }
              var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
              if (supSubGroup) {
                supSubGroup.children[0] = accentWrap;
                supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
                supSubGroup.classes[0] = "mord";
                return supSubGroup;
              } else {
                return accentWrap;
              }
            };
            var accent_mathmlBuilder = function mathmlBuilder(group, options) {
              var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [buildMathML_makeText(group.label, group.mode)]);
              var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
              node.setAttribute("accent", "true");
              return node;
            };
            var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function(accent) {
              return "\\" + accent;
            }).join("|"));
            defineFunction({
              type: "accent",
              names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var base = args[0];
                var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
                var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
                return {
                  type: "accent",
                  mode: context.parser.mode,
                  label: context.funcName,
                  isStretchy,
                  isShifty,
                  base
                };
              },
              htmlBuilder: accent_htmlBuilder,
              mathmlBuilder: accent_mathmlBuilder
            });
            defineFunction({
              type: "accent",
              names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v", "\\textcircled"],
              props: {
                numArgs: 1,
                allowedInText: true,
                allowedInMath: false
              },
              handler: function handler(context, args) {
                var base = args[0];
                return {
                  type: "accent",
                  mode: context.parser.mode,
                  label: context.funcName,
                  isStretchy: false,
                  isShifty: true,
                  base
                };
              },
              htmlBuilder: accent_htmlBuilder,
              mathmlBuilder: accent_mathmlBuilder
            });
            defineFunction({
              type: "accentUnder",
              names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var base = args[0];
                return {
                  type: "accentUnder",
                  mode: parser.mode,
                  label: funcName,
                  base
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var innerGroup = buildHTML_buildGroup(group.base, options);
                var accentBody = stretchy.svgSpan(group, options);
                var kern = group.label === "\\utilde" ? 0.12 : 0;
                var vlist = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: accentBody.height + kern,
                  children: [{
                    type: "elem",
                    elem: accentBody,
                    wrapperClasses: ["svg-align"]
                  }, {
                    type: "kern",
                    size: kern
                  }, {
                    type: "elem",
                    elem: innerGroup
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var accentNode = stretchy.mathMLnode(group.label);
                var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
                node.setAttribute("accentunder", "true");
                return node;
              }
            });
            var arrow_paddedNode = function paddedNode(group) {
              var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
              node.setAttribute("width", "+0.6em");
              node.setAttribute("lspace", "0.3em");
              return node;
            };
            defineFunction({
              type: "xArrow",
              names: [
                "\\xleftarrow",
                "\\xrightarrow",
                "\\xLeftarrow",
                "\\xRightarrow",
                "\\xleftrightarrow",
                "\\xLeftrightarrow",
                "\\xhookleftarrow",
                "\\xhookrightarrow",
                "\\xmapsto",
                "\\xrightharpoondown",
                "\\xrightharpoonup",
                "\\xleftharpoondown",
                "\\xleftharpoonup",
                "\\xrightleftharpoons",
                "\\xleftrightharpoons",
                "\\xlongequal",
                "\\xtwoheadrightarrow",
                "\\xtwoheadleftarrow",
                "\\xtofrom",
                // The next 3 functions are here to support the mhchem extension.
                // Direct use of these functions is discouraged and may break someday.
                "\\xrightleftarrows",
                "\\xrightequilibrium",
                "\\xleftequilibrium"
              ],
              props: {
                numArgs: 1,
                numOptionalArgs: 1
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser, funcName = _ref.funcName;
                return {
                  type: "xArrow",
                  mode: parser.mode,
                  label: funcName,
                  body: args[0],
                  below: optArgs[0]
                };
              },
              // Flow is unable to correctly infer the type of `group`, even though it's
              // unamibiguously determined from the passed-in `type` above.
              htmlBuilder: function htmlBuilder(group, options) {
                var style = options.style;
                var newOptions = options.havingStyle(style.sup());
                var upperGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, newOptions, options), options);
                upperGroup.classes.push("x-arrow-pad");
                var lowerGroup;
                if (group.below) {
                  newOptions = options.havingStyle(style.sub());
                  lowerGroup = buildCommon.wrapFragment(buildHTML_buildGroup(group.below, newOptions, options), options);
                  lowerGroup.classes.push("x-arrow-pad");
                }
                var arrowBody = stretchy.svgSpan(group, options);
                var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
                var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
                if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
                  upperShift -= upperGroup.depth;
                }
                var vlist;
                if (lowerGroup) {
                  var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
                  vlist = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: upperGroup,
                      shift: upperShift
                    }, {
                      type: "elem",
                      elem: arrowBody,
                      shift: arrowShift
                    }, {
                      type: "elem",
                      elem: lowerGroup,
                      shift: lowerShift
                    }]
                  }, options);
                } else {
                  vlist = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: upperGroup,
                      shift: upperShift
                    }, {
                      type: "elem",
                      elem: arrowBody,
                      shift: arrowShift
                    }]
                  }, options);
                }
                vlist.children[0].children[0].children[1].classes.push("svg-align");
                return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var arrowNode = stretchy.mathMLnode(group.label);
                var node;
                if (group.body) {
                  var upperNode = arrow_paddedNode(buildMathML_buildGroup(group.body, options));
                  if (group.below) {
                    var lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));
                    node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
                  } else {
                    node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
                  }
                } else if (group.below) {
                  var _lowerNode = arrow_paddedNode(buildMathML_buildGroup(group.below, options));
                  node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
                } else {
                  node = arrow_paddedNode();
                  node = new mathMLTree.MathNode("mover", [arrowNode, node]);
                }
                return node;
              }
            });
            defineFunction({
              type: "textord",
              names: ["\\@char"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var arg = assertNodeType(args[0], "ordgroup");
                var group = arg.body;
                var number3 = "";
                for (var i = 0; i < group.length; i++) {
                  var node = assertNodeType(group[i], "textord");
                  number3 += node.text;
                }
                var code = parseInt(number3);
                if (isNaN(code)) {
                  throw new src_ParseError("\\@char has non-numeric argument " + number3);
                }
                return {
                  type: "textord",
                  mode: parser.mode,
                  text: String.fromCharCode(code)
                };
              }
            });
            var color_htmlBuilder = function htmlBuilder(group, options) {
              var elements = buildHTML_buildExpression(group.body, options.withColor(group.color), false);
              return buildCommon.makeFragment(elements);
            };
            var color_mathmlBuilder = function mathmlBuilder(group, options) {
              var inner = buildMathML_buildExpression(group.body, options.withColor(group.color));
              var node = new mathMLTree.MathNode("mstyle", inner);
              node.setAttribute("mathcolor", group.color);
              return node;
            };
            defineFunction({
              type: "color",
              names: ["\\textcolor"],
              props: {
                numArgs: 2,
                allowedInText: true,
                greediness: 3,
                argTypes: ["color", "original"]
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var color3 = assertNodeType(args[0], "color-token").color;
                var body = args[1];
                return {
                  type: "color",
                  mode: parser.mode,
                  color: color3,
                  body: defineFunction_ordargument(body)
                };
              },
              htmlBuilder: color_htmlBuilder,
              mathmlBuilder: color_mathmlBuilder
            });
            defineFunction({
              type: "color",
              names: ["\\color"],
              props: {
                numArgs: 1,
                allowedInText: true,
                greediness: 3,
                argTypes: ["color"]
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser, breakOnTokenText = _ref2.breakOnTokenText;
                var color3 = assertNodeType(args[0], "color-token").color;
                var body = parser.parseExpression(true, breakOnTokenText);
                return {
                  type: "color",
                  mode: parser.mode,
                  color: color3,
                  body
                };
              },
              htmlBuilder: color_htmlBuilder,
              mathmlBuilder: color_mathmlBuilder
            });
            defineFunction({
              type: "cr",
              names: ["\\cr", "\\newline"],
              props: {
                numArgs: 0,
                numOptionalArgs: 1,
                argTypes: ["size"],
                allowedInText: true
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var size = optArgs[0];
                var newRow = funcName === "\\cr";
                var newLine = false;
                if (!newRow) {
                  if (parser.settings.displayMode && parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode")) {
                    newLine = false;
                  } else {
                    newLine = true;
                  }
                }
                return {
                  type: "cr",
                  mode: parser.mode,
                  newLine,
                  newRow,
                  size: size && assertNodeType(size, "size").value
                };
              },
              // The following builders are called only at the top level,
              // not within tabular/array environments.
              htmlBuilder: function htmlBuilder(group, options) {
                if (group.newRow) {
                  throw new src_ParseError("\\cr valid only within a tabular/array environment");
                }
                var span = buildCommon.makeSpan(["mspace"], [], options);
                if (group.newLine) {
                  span.classes.push("newline");
                  if (group.size) {
                    span.style.marginTop = units_calculateSize(group.size, options) + "em";
                  }
                }
                return span;
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mspace");
                if (group.newLine) {
                  node.setAttribute("linebreak", "newline");
                  if (group.size) {
                    node.setAttribute("height", units_calculateSize(group.size, options) + "em");
                  }
                }
                return node;
              }
            });
            var delimiter_getMetrics = function getMetrics(symbol, font, mode) {
              var replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
              var metrics = getCharacterMetrics(replace || symbol, font, mode);
              if (!metrics) {
                throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
              }
              return metrics;
            };
            var delimiter_styleWrap = function styleWrap(delim, toStyle, options, classes) {
              var newOptions = options.havingBaseStyle(toStyle);
              var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
              var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
              span.height *= delimSizeMultiplier;
              span.depth *= delimSizeMultiplier;
              span.maxFontSize = newOptions.sizeMultiplier;
              return span;
            };
            var centerSpan = function centerSpan2(span, options, style) {
              var newOptions = options.havingBaseStyle(style);
              var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
              span.classes.push("delimcenter");
              span.style.top = shift + "em";
              span.height -= shift;
              span.depth += shift;
            };
            var delimiter_makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {
              var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
              var span = delimiter_styleWrap(text, style, options, classes);
              if (center) {
                centerSpan(span, options, style);
              }
              return span;
            };
            var delimiter_mathrmSize = function mathrmSize(value, size, mode, options) {
              return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
            };
            var delimiter_makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {
              var inner = delimiter_mathrmSize(delim, size, mode, options);
              var span = delimiter_styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner], options), src_Style.TEXT, options, classes);
              if (center) {
                centerSpan(span, options, src_Style.TEXT);
              }
              return span;
            };
            var delimiter_makeInner = function makeInner(symbol, font, mode) {
              var sizeClass;
              if (font === "Size1-Regular") {
                sizeClass = "delim-size1";
              } else {
                sizeClass = "delim-size4";
              }
              var inner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
              return {
                type: "elem",
                elem: inner
              };
            };
            var delimiter_makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {
              var top;
              var middle;
              var repeat;
              var bottom;
              top = repeat = bottom = delim;
              middle = null;
              var font = "Size1-Regular";
              if (delim === "\\uparrow") {
                repeat = bottom = "\u23D0";
              } else if (delim === "\\Uparrow") {
                repeat = bottom = "\u2016";
              } else if (delim === "\\downarrow") {
                top = repeat = "\u23D0";
              } else if (delim === "\\Downarrow") {
                top = repeat = "\u2016";
              } else if (delim === "\\updownarrow") {
                top = "\\uparrow";
                repeat = "\u23D0";
                bottom = "\\downarrow";
              } else if (delim === "\\Updownarrow") {
                top = "\\Uparrow";
                repeat = "\u2016";
                bottom = "\\Downarrow";
              } else if (delim === "[" || delim === "\\lbrack") {
                top = "\u23A1";
                repeat = "\u23A2";
                bottom = "\u23A3";
                font = "Size4-Regular";
              } else if (delim === "]" || delim === "\\rbrack") {
                top = "\u23A4";
                repeat = "\u23A5";
                bottom = "\u23A6";
                font = "Size4-Regular";
              } else if (delim === "\\lfloor" || delim === "\u230A") {
                repeat = top = "\u23A2";
                bottom = "\u23A3";
                font = "Size4-Regular";
              } else if (delim === "\\lceil" || delim === "\u2308") {
                top = "\u23A1";
                repeat = bottom = "\u23A2";
                font = "Size4-Regular";
              } else if (delim === "\\rfloor" || delim === "\u230B") {
                repeat = top = "\u23A5";
                bottom = "\u23A6";
                font = "Size4-Regular";
              } else if (delim === "\\rceil" || delim === "\u2309") {
                top = "\u23A4";
                repeat = bottom = "\u23A5";
                font = "Size4-Regular";
              } else if (delim === "(" || delim === "\\lparen") {
                top = "\u239B";
                repeat = "\u239C";
                bottom = "\u239D";
                font = "Size4-Regular";
              } else if (delim === ")" || delim === "\\rparen") {
                top = "\u239E";
                repeat = "\u239F";
                bottom = "\u23A0";
                font = "Size4-Regular";
              } else if (delim === "\\{" || delim === "\\lbrace") {
                top = "\u23A7";
                middle = "\u23A8";
                bottom = "\u23A9";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\}" || delim === "\\rbrace") {
                top = "\u23AB";
                middle = "\u23AC";
                bottom = "\u23AD";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\lgroup" || delim === "\u27EE") {
                top = "\u23A7";
                bottom = "\u23A9";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\rgroup" || delim === "\u27EF") {
                top = "\u23AB";
                bottom = "\u23AD";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\lmoustache" || delim === "\u23B0") {
                top = "\u23A7";
                bottom = "\u23AD";
                repeat = "\u23AA";
                font = "Size4-Regular";
              } else if (delim === "\\rmoustache" || delim === "\u23B1") {
                top = "\u23AB";
                bottom = "\u23A9";
                repeat = "\u23AA";
                font = "Size4-Regular";
              }
              var topMetrics = delimiter_getMetrics(top, font, mode);
              var topHeightTotal = topMetrics.height + topMetrics.depth;
              var repeatMetrics = delimiter_getMetrics(repeat, font, mode);
              var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
              var bottomMetrics = delimiter_getMetrics(bottom, font, mode);
              var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
              var middleHeightTotal = 0;
              var middleFactor = 1;
              if (middle !== null) {
                var middleMetrics = delimiter_getMetrics(middle, font, mode);
                middleHeightTotal = middleMetrics.height + middleMetrics.depth;
                middleFactor = 2;
              }
              var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
              var repeatCount = Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal));
              var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
              var axisHeight = options.fontMetrics().axisHeight;
              if (center) {
                axisHeight *= options.sizeMultiplier;
              }
              var depth = realHeightTotal / 2 - axisHeight;
              var inners = [];
              inners.push(delimiter_makeInner(bottom, font, mode));
              if (middle === null) {
                for (var i = 0; i < repeatCount; i++) {
                  inners.push(delimiter_makeInner(repeat, font, mode));
                }
              } else {
                for (var _i = 0; _i < repeatCount; _i++) {
                  inners.push(delimiter_makeInner(repeat, font, mode));
                }
                inners.push(delimiter_makeInner(middle, font, mode));
                for (var _i2 = 0; _i2 < repeatCount; _i2++) {
                  inners.push(delimiter_makeInner(repeat, font, mode));
                }
              }
              inners.push(delimiter_makeInner(top, font, mode));
              var newOptions = options.havingBaseStyle(src_Style.TEXT);
              var inner = buildCommon.makeVList({
                positionType: "bottom",
                positionData: depth,
                children: inners
              }, newOptions);
              return delimiter_styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner], newOptions), src_Style.TEXT, options, classes);
            };
            var vbPad = 80;
            var emPad = 0.08;
            var delimiter_sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, options) {
              var alternate;
              if (sqrtName === "sqrtTall") {
                var vertSegment = viewBoxHeight - 54 - vbPad;
                alternate = "M702 " + vbPad + "H400000v40H742v" + vertSegment + "l-4 4-4 4c-.667.7\n-2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1h-12l-28-84c-16.667-52-96.667\n-294.333-240-727l-212 -643 -85 170c-4-3.333-8.333-7.667-13 -13l-13-13l77-155\n 77-156c66 199.333 139 419.667 219 661 l218 661zM702 " + vbPad + "H400000v40H742z";
              }
              var pathNode = new domTree_PathNode(sqrtName, alternate);
              var svg = new SvgNode([pathNode], {
                // Note: 1000:1 ratio of viewBox to document em width.
                "width": "400em",
                "height": height + "em",
                "viewBox": "0 0 400000 " + viewBoxHeight,
                "preserveAspectRatio": "xMinYMin slice"
              });
              return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
            };
            var makeSqrtImage = function makeSqrtImage2(height, options) {
              var newOptions = options.havingBaseSizing();
              var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
              var sizeMultiplier = newOptions.sizeMultiplier;
              var span;
              var spanHeight = 0;
              var texHeight = 0;
              var viewBoxHeight = 0;
              var advanceWidth;
              if (delim.type === "small") {
                viewBoxHeight = 1e3 + vbPad;
                if (height < 1) {
                  sizeMultiplier = 1;
                } else if (height < 1.4) {
                  sizeMultiplier = 0.7;
                }
                spanHeight = (1 + emPad) / sizeMultiplier;
                texHeight = 1 / sizeMultiplier;
                span = delimiter_sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, options);
                span.style.minWidth = "0.853em";
                advanceWidth = 0.833 / sizeMultiplier;
              } else if (delim.type === "large") {
                viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
                texHeight = sizeToMaxHeight[delim.size] / sizeMultiplier;
                spanHeight = (sizeToMaxHeight[delim.size] + emPad) / sizeMultiplier;
                span = delimiter_sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, options);
                span.style.minWidth = "1.02em";
                advanceWidth = 1 / sizeMultiplier;
              } else {
                spanHeight = height + emPad;
                texHeight = height;
                viewBoxHeight = Math.floor(1e3 * height) + vbPad;
                span = delimiter_sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, options);
                span.style.minWidth = "0.742em";
                advanceWidth = 1.056;
              }
              span.height = texHeight;
              span.style.height = spanHeight + "em";
              return {
                span,
                advanceWidth,
                // Calculate the actual line width.
                // This actually should depend on the chosen font -- e.g. \boldmath
                // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
                // have thicker rules.
                ruleWidth: options.fontMetrics().sqrtRuleThickness * sizeMultiplier
              };
            };
            var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
            var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
            var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
            var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
            var delimiter_makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {
              if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
                delim = "\\langle";
              } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
                delim = "\\rangle";
              }
              if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
                return delimiter_makeLargeDelim(delim, size, false, options, mode, classes);
              } else if (utils.contains(stackAlwaysDelimiters, delim)) {
                return delimiter_makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
              } else {
                throw new src_ParseError("Illegal delimiter: '" + delim + "'");
              }
            };
            var stackNeverDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "large",
              size: 1
            }, {
              type: "large",
              size: 2
            }, {
              type: "large",
              size: 3
            }, {
              type: "large",
              size: 4
            }];
            var stackAlwaysDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "stack"
            }];
            var stackLargeDelimiterSequence = [{
              type: "small",
              style: src_Style.SCRIPTSCRIPT
            }, {
              type: "small",
              style: src_Style.SCRIPT
            }, {
              type: "small",
              style: src_Style.TEXT
            }, {
              type: "large",
              size: 1
            }, {
              type: "large",
              size: 2
            }, {
              type: "large",
              size: 3
            }, {
              type: "large",
              size: 4
            }, {
              type: "stack"
            }];
            var delimTypeToFont = function delimTypeToFont2(type) {
              if (type.type === "small") {
                return "Main-Regular";
              } else if (type.type === "large") {
                return "Size" + type.size + "-Regular";
              } else if (type.type === "stack") {
                return "Size4-Regular";
              } else {
                throw new Error("Add support for delim type '" + type.type + "' here.");
              }
            };
            var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
              var start2 = Math.min(2, 3 - options.style.size);
              for (var i = start2; i < sequence.length; i++) {
                if (sequence[i].type === "stack") {
                  break;
                }
                var metrics = delimiter_getMetrics(delim, delimTypeToFont(sequence[i]), "math");
                var heightDepth = metrics.height + metrics.depth;
                if (sequence[i].type === "small") {
                  var newOptions = options.havingBaseStyle(sequence[i].style);
                  heightDepth *= newOptions.sizeMultiplier;
                }
                if (heightDepth > height) {
                  return sequence[i];
                }
              }
              return sequence[sequence.length - 1];
            };
            var delimiter_makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {
              if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
                delim = "\\langle";
              } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
                delim = "\\rangle";
              }
              var sequence;
              if (utils.contains(stackNeverDelimiters, delim)) {
                sequence = stackNeverDelimiterSequence;
              } else if (utils.contains(stackLargeDelimiters, delim)) {
                sequence = stackLargeDelimiterSequence;
              } else {
                sequence = stackAlwaysDelimiterSequence;
              }
              var delimType = traverseSequence(delim, height, sequence, options);
              if (delimType.type === "small") {
                return delimiter_makeSmallDelim(delim, delimType.style, center, options, mode, classes);
              } else if (delimType.type === "large") {
                return delimiter_makeLargeDelim(delim, delimType.size, center, options, mode, classes);
              } else {
                return delimiter_makeStackedDelim(delim, height, center, options, mode, classes);
              }
            };
            var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
              var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
              var delimiterFactor = 901;
              var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
              var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
              var totalHeight = Math.max(
                // In real TeX, calculations are done using integral values which are
                // 65536 per pt, or 655360 per em. So, the division here truncates in
                // TeX but doesn't here, producing different results. If we wanted to
                // exactly match TeX's calculation, we could do
                //   Math.floor(655360 * maxDistFromAxis / 500) *
                //    delimiterFactor / 655360
                // (To see the difference, compare
                //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
                // in TeX and KaTeX)
                maxDistFromAxis / 500 * delimiterFactor,
                2 * maxDistFromAxis - delimiterExtend
              );
              return delimiter_makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
            };
            var delimiter = {
              sqrtImage: makeSqrtImage,
              sizedDelim: delimiter_makeSizedDelim,
              customSizedDelim: delimiter_makeCustomSizedDelim,
              leftRightDelim: makeLeftRightDelim
            };
            var delimiterSizes = {
              "\\bigl": {
                mclass: "mopen",
                size: 1
              },
              "\\Bigl": {
                mclass: "mopen",
                size: 2
              },
              "\\biggl": {
                mclass: "mopen",
                size: 3
              },
              "\\Biggl": {
                mclass: "mopen",
                size: 4
              },
              "\\bigr": {
                mclass: "mclose",
                size: 1
              },
              "\\Bigr": {
                mclass: "mclose",
                size: 2
              },
              "\\biggr": {
                mclass: "mclose",
                size: 3
              },
              "\\Biggr": {
                mclass: "mclose",
                size: 4
              },
              "\\bigm": {
                mclass: "mrel",
                size: 1
              },
              "\\Bigm": {
                mclass: "mrel",
                size: 2
              },
              "\\biggm": {
                mclass: "mrel",
                size: 3
              },
              "\\Biggm": {
                mclass: "mrel",
                size: 4
              },
              "\\big": {
                mclass: "mord",
                size: 1
              },
              "\\Big": {
                mclass: "mord",
                size: 2
              },
              "\\bigg": {
                mclass: "mord",
                size: 3
              },
              "\\Bigg": {
                mclass: "mord",
                size: 4
              }
            };
            var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
            function checkDelimiter(delim, context) {
              var symDelim = checkSymbolNodeType(delim);
              if (symDelim && utils.contains(delimiters, symDelim.text)) {
                return symDelim;
              } else {
                throw new src_ParseError("Invalid delimiter: '" + (symDelim ? symDelim.text : JSON.stringify(delim)) + "' after '" + context.funcName + "'", delim);
              }
            }
            defineFunction({
              type: "delimsizing",
              names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var delim = checkDelimiter(args[0], context);
                return {
                  type: "delimsizing",
                  mode: context.parser.mode,
                  size: delimiterSizes[context.funcName].size,
                  mclass: delimiterSizes[context.funcName].mclass,
                  delim: delim.text
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                if (group.delim === ".") {
                  return buildCommon.makeSpan([group.mclass]);
                }
                return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
              },
              mathmlBuilder: function mathmlBuilder(group) {
                var children = [];
                if (group.delim !== ".") {
                  children.push(buildMathML_makeText(group.delim, group.mode));
                }
                var node = new mathMLTree.MathNode("mo", children);
                if (group.mclass === "mopen" || group.mclass === "mclose") {
                  node.setAttribute("fence", "true");
                } else {
                  node.setAttribute("fence", "false");
                }
                return node;
              }
            });
            function assertParsed(group) {
              if (!group.body) {
                throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
              }
            }
            defineFunction({
              type: "leftright-right",
              names: ["\\right"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                return {
                  type: "leftright-right",
                  mode: context.parser.mode,
                  delim: checkDelimiter(args[0], context).text
                };
              }
            });
            defineFunction({
              type: "leftright",
              names: ["\\left"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var delim = checkDelimiter(args[0], context);
                var parser = context.parser;
                ++parser.leftrightDepth;
                var body = parser.parseExpression(false);
                --parser.leftrightDepth;
                parser.expect("\\right", false);
                var right = assertNodeType(parser.parseFunction(), "leftright-right");
                return {
                  type: "leftright",
                  mode: parser.mode,
                  body,
                  left: delim.text,
                  right: right.delim
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                assertParsed(group);
                var inner = buildHTML_buildExpression(group.body, options, true, ["mopen", "mclose"]);
                var innerHeight = 0;
                var innerDepth = 0;
                var hadMiddle = false;
                for (var i = 0; i < inner.length; i++) {
                  if (inner[i].isMiddle) {
                    hadMiddle = true;
                  } else {
                    innerHeight = Math.max(inner[i].height, innerHeight);
                    innerDepth = Math.max(inner[i].depth, innerDepth);
                  }
                }
                innerHeight *= options.sizeMultiplier;
                innerDepth *= options.sizeMultiplier;
                var leftDelim;
                if (group.left === ".") {
                  leftDelim = makeNullDelimiter(options, ["mopen"]);
                } else {
                  leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
                }
                inner.unshift(leftDelim);
                if (hadMiddle) {
                  for (var _i = 1; _i < inner.length; _i++) {
                    var middleDelim = inner[_i];
                    var isMiddle = middleDelim.isMiddle;
                    if (isMiddle) {
                      inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                    }
                  }
                }
                var rightDelim;
                if (group.right === ".") {
                  rightDelim = makeNullDelimiter(options, ["mclose"]);
                } else {
                  rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, options, group.mode, ["mclose"]);
                }
                inner.push(rightDelim);
                return buildCommon.makeSpan(["minner"], inner, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                assertParsed(group);
                var inner = buildMathML_buildExpression(group.body, options);
                if (group.left !== ".") {
                  var leftNode = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.left, group.mode)]);
                  leftNode.setAttribute("fence", "true");
                  inner.unshift(leftNode);
                }
                if (group.right !== ".") {
                  var rightNode = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.right, group.mode)]);
                  rightNode.setAttribute("fence", "true");
                  inner.push(rightNode);
                }
                return buildMathML_makeRow(inner);
              }
            });
            defineFunction({
              type: "middle",
              names: ["\\middle"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var delim = checkDelimiter(args[0], context);
                if (!context.parser.leftrightDepth) {
                  throw new src_ParseError("\\middle without preceding \\left", delim);
                }
                return {
                  type: "middle",
                  mode: context.parser.mode,
                  delim: delim.text
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var middleDelim;
                if (group.delim === ".") {
                  middleDelim = makeNullDelimiter(options, []);
                } else {
                  middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
                  var isMiddle = {
                    delim: group.delim,
                    options
                  };
                  middleDelim.isMiddle = isMiddle;
                }
                return middleDelim;
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var textNode = group.delim === "\\vert" || group.delim === "|" ? buildMathML_makeText("|", "text") : buildMathML_makeText(group.delim, group.mode);
                var middleNode = new mathMLTree.MathNode("mo", [textNode]);
                middleNode.setAttribute("fence", "true");
                middleNode.setAttribute("lspace", "0.05em");
                middleNode.setAttribute("rspace", "0.05em");
                return middleNode;
              }
            });
            var enclose_htmlBuilder = function htmlBuilder(group, options) {
              var inner = buildCommon.wrapFragment(buildHTML_buildGroup(group.body, options), options);
              var label = group.label.substr(1);
              var scale = options.sizeMultiplier;
              var img;
              var imgShift = 0;
              var isSingleChar = utils.isCharacterBox(group.body);
              if (label === "sout") {
                img = buildCommon.makeSpan(["stretchy", "sout"]);
                img.height = options.fontMetrics().defaultRuleThickness / scale;
                imgShift = -0.5 * options.fontMetrics().xHeight;
              } else {
                if (/cancel/.test(label)) {
                  if (!isSingleChar) {
                    inner.classes.push("cancel-pad");
                  }
                } else {
                  inner.classes.push("boxpad");
                }
                var vertPad = 0;
                if (/box/.test(label)) {
                  vertPad = label === "colorbox" ? 0.3 : 0.34;
                } else {
                  vertPad = isSingleChar ? 0.2 : 0;
                }
                img = stretchy.encloseSpan(inner, label, vertPad, options);
                imgShift = inner.depth + vertPad;
                if (group.backgroundColor) {
                  img.style.backgroundColor = group.backgroundColor;
                  if (group.borderColor) {
                    img.style.borderColor = group.borderColor;
                  }
                }
              }
              var vlist;
              if (group.backgroundColor) {
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [
                    // Put the color background behind inner;
                    {
                      type: "elem",
                      elem: img,
                      shift: imgShift
                    },
                    {
                      type: "elem",
                      elem: inner,
                      shift: 0
                    }
                  ]
                }, options);
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [
                    // Write the \cancel stroke on top of inner.
                    {
                      type: "elem",
                      elem: inner,
                      shift: 0
                    },
                    {
                      type: "elem",
                      elem: img,
                      shift: imgShift,
                      wrapperClasses: /cancel/.test(label) ? ["svg-align"] : []
                    }
                  ]
                }, options);
              }
              if (/cancel/.test(label)) {
                vlist.height = inner.height;
                vlist.depth = inner.depth;
              }
              if (/cancel/.test(label) && !isSingleChar) {
                return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
              } else {
                return buildCommon.makeSpan(["mord"], [vlist], options);
              }
            };
            var enclose_mathmlBuilder = function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
              switch (group.label) {
                case "\\cancel":
                  node.setAttribute("notation", "updiagonalstrike");
                  break;
                case "\\bcancel":
                  node.setAttribute("notation", "downdiagonalstrike");
                  break;
                case "\\sout":
                  node.setAttribute("notation", "horizontalstrike");
                  break;
                case "\\fbox":
                  node.setAttribute("notation", "box");
                  break;
                case "\\fcolorbox":
                case "\\colorbox":
                  node.setAttribute("width", "+6pt");
                  node.setAttribute("height", "+6pt");
                  node.setAttribute("lspace", "3pt");
                  node.setAttribute("voffset", "3pt");
                  if (group.label === "\\fcolorbox") {
                    var thk = options.fontMetrics().defaultRuleThickness;
                    node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
                  }
                  break;
                case "\\xcancel":
                  node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                  break;
              }
              if (group.backgroundColor) {
                node.setAttribute("mathbackground", group.backgroundColor);
              }
              return node;
            };
            defineFunction({
              type: "enclose",
              names: ["\\colorbox"],
              props: {
                numArgs: 2,
                allowedInText: true,
                greediness: 3,
                argTypes: ["color", "text"]
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var color3 = assertNodeType(args[0], "color-token").color;
                var body = args[1];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  backgroundColor: color3,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            defineFunction({
              type: "enclose",
              names: ["\\fcolorbox"],
              props: {
                numArgs: 3,
                allowedInText: true,
                greediness: 3,
                argTypes: ["color", "color", "text"]
              },
              handler: function handler(_ref2, args, optArgs) {
                var parser = _ref2.parser, funcName = _ref2.funcName;
                var borderColor = assertNodeType(args[0], "color-token").color;
                var backgroundColor = assertNodeType(args[1], "color-token").color;
                var body = args[2];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  backgroundColor,
                  borderColor,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            defineFunction({
              type: "enclose",
              names: ["\\fbox"],
              props: {
                numArgs: 1,
                argTypes: ["text"],
                allowedInText: true
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser;
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: "\\fbox",
                  body: args[0]
                };
              }
            });
            defineFunction({
              type: "enclose",
              names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref4, args, optArgs) {
                var parser = _ref4.parser, funcName = _ref4.funcName;
                var body = args[0];
                return {
                  type: "enclose",
                  mode: parser.mode,
                  label: funcName,
                  body
                };
              },
              htmlBuilder: enclose_htmlBuilder,
              mathmlBuilder: enclose_mathmlBuilder
            });
            var _environments = {};
            function defineEnvironment(_ref) {
              var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder = _ref.htmlBuilder, mathmlBuilder = _ref.mathmlBuilder;
              var data = {
                type,
                numArgs: props.numArgs || 0,
                greediness: 1,
                allowedInText: false,
                numOptionalArgs: 0,
                handler
              };
              for (var i = 0; i < names.length; ++i) {
                _environments[names[i]] = data;
              }
              if (htmlBuilder) {
                _htmlGroupBuilders[type] = htmlBuilder;
              }
              if (mathmlBuilder) {
                _mathmlGroupBuilders[type] = mathmlBuilder;
              }
            }
            function getHLines(parser) {
              var hlineInfo = [];
              parser.consumeSpaces();
              var nxt = parser.nextToken.text;
              while (nxt === "\\hline" || nxt === "\\hdashline") {
                parser.consume();
                hlineInfo.push(nxt === "\\hdashline");
                parser.consumeSpaces();
                nxt = parser.nextToken.text;
              }
              return hlineInfo;
            }
            function parseArray(parser, _ref, style) {
              var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter, addJot = _ref.addJot, cols = _ref.cols, arraystretch = _ref.arraystretch, colSeparationType = _ref.colSeparationType;
              parser.gullet.beginGroup();
              parser.gullet.macros.set("\\\\", "\\cr");
              if (!arraystretch) {
                var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
                if (stretch == null) {
                  arraystretch = 1;
                } else {
                  arraystretch = parseFloat(stretch);
                  if (!arraystretch || arraystretch < 0) {
                    throw new src_ParseError("Invalid \\arraystretch: " + stretch);
                  }
                }
              }
              var row = [];
              var body = [row];
              var rowGaps = [];
              var hLinesBeforeRow = [];
              hLinesBeforeRow.push(getHLines(parser));
              while (true) {
                var cell = parser.parseExpression(false, "\\cr");
                cell = {
                  type: "ordgroup",
                  mode: parser.mode,
                  body: cell
                };
                if (style) {
                  cell = {
                    type: "styling",
                    mode: parser.mode,
                    style,
                    body: [cell]
                  };
                }
                row.push(cell);
                var next = parser.nextToken.text;
                if (next === "&") {
                  parser.consume();
                } else if (next === "\\end") {
                  if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0) {
                    body.pop();
                  }
                  if (hLinesBeforeRow.length < body.length + 1) {
                    hLinesBeforeRow.push([]);
                  }
                  break;
                } else if (next === "\\cr") {
                  var cr = assertNodeType(parser.parseFunction(), "cr");
                  rowGaps.push(cr.size);
                  hLinesBeforeRow.push(getHLines(parser));
                  row = [];
                  body.push(row);
                } else {
                  throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
                }
              }
              parser.gullet.endGroup();
              return {
                type: "array",
                mode: parser.mode,
                addJot,
                arraystretch,
                body,
                cols,
                rowGaps,
                hskipBeforeAndAfter,
                hLinesBeforeRow,
                colSeparationType
              };
            }
            function dCellStyle(envName) {
              if (envName.substr(0, 1) === "d") {
                return "display";
              } else {
                return "text";
              }
            }
            var array_htmlBuilder = function htmlBuilder(group, options) {
              var r;
              var c;
              var nr = group.body.length;
              var hLinesBeforeRow = group.hLinesBeforeRow;
              var nc = 0;
              var body = new Array(nr);
              var hlines = [];
              var pt = 1 / options.fontMetrics().ptPerEm;
              var arraycolsep = 5 * pt;
              var baselineskip = 12 * pt;
              var jot = 3 * pt;
              var arrayskip = group.arraystretch * baselineskip;
              var arstrutHeight = 0.7 * arrayskip;
              var arstrutDepth = 0.3 * arrayskip;
              var totalHeight = 0;
              function setHLinePos(hlinesInGap) {
                for (var i = 0; i < hlinesInGap.length; ++i) {
                  if (i > 0) {
                    totalHeight += 0.25;
                  }
                  hlines.push({
                    pos: totalHeight,
                    isDashed: hlinesInGap[i]
                  });
                }
              }
              setHLinePos(hLinesBeforeRow[0]);
              for (r = 0; r < group.body.length; ++r) {
                var inrow = group.body[r];
                var height = arstrutHeight;
                var depth = arstrutDepth;
                if (nc < inrow.length) {
                  nc = inrow.length;
                }
                var outrow = new Array(inrow.length);
                for (c = 0; c < inrow.length; ++c) {
                  var elt = buildHTML_buildGroup(inrow[c], options);
                  if (depth < elt.depth) {
                    depth = elt.depth;
                  }
                  if (height < elt.height) {
                    height = elt.height;
                  }
                  outrow[c] = elt;
                }
                var rowGap = group.rowGaps[r];
                var gap = 0;
                if (rowGap) {
                  gap = units_calculateSize(rowGap, options);
                  if (gap > 0) {
                    gap += arstrutDepth;
                    if (depth < gap) {
                      depth = gap;
                    }
                    gap = 0;
                  }
                }
                if (group.addJot) {
                  depth += jot;
                }
                outrow.height = height;
                outrow.depth = depth;
                totalHeight += height;
                outrow.pos = totalHeight;
                totalHeight += depth + gap;
                body[r] = outrow;
                setHLinePos(hLinesBeforeRow[r + 1]);
              }
              var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
              var colDescriptions = group.cols || [];
              var cols = [];
              var colSep;
              var colDescrNum;
              for (
                c = 0, colDescrNum = 0;
                // Continue while either there are more columns or more column
                // descriptions, so trailing separators don't get lost.
                c < nc || colDescrNum < colDescriptions.length;
                ++c, ++colDescrNum
              ) {
                var colDescr = colDescriptions[colDescrNum] || {};
                var firstSeparator = true;
                while (colDescr.type === "separator") {
                  if (!firstSeparator) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = options.fontMetrics().doubleRuleSep + "em";
                    cols.push(colSep);
                  }
                  if (colDescr.separator === "|") {
                    var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                    separator.style.height = totalHeight + "em";
                    separator.style.verticalAlign = -(totalHeight - offset) + "em";
                    cols.push(separator);
                  } else if (colDescr.separator === ":") {
                    var _separator = buildCommon.makeSpan(["vertical-separator", "vs-dashed"], [], options);
                    _separator.style.height = totalHeight + "em";
                    _separator.style.verticalAlign = -(totalHeight - offset) + "em";
                    cols.push(_separator);
                  } else {
                    throw new src_ParseError("Invalid separator type: " + colDescr.separator);
                  }
                  colDescrNum++;
                  colDescr = colDescriptions[colDescrNum] || {};
                  firstSeparator = false;
                }
                if (c >= nc) {
                  continue;
                }
                var sepwidth = void 0;
                if (c > 0 || group.hskipBeforeAndAfter) {
                  sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
                  if (sepwidth !== 0) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = sepwidth + "em";
                    cols.push(colSep);
                  }
                }
                var col = [];
                for (r = 0; r < nr; ++r) {
                  var row = body[r];
                  var elem = row[c];
                  if (!elem) {
                    continue;
                  }
                  var shift = row.pos - offset;
                  elem.depth = row.depth;
                  elem.height = row.height;
                  col.push({
                    type: "elem",
                    elem,
                    shift
                  });
                }
                col = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: col
                }, options);
                col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
                cols.push(col);
                if (c < nc - 1 || group.hskipBeforeAndAfter) {
                  sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
                  if (sepwidth !== 0) {
                    colSep = buildCommon.makeSpan(["arraycolsep"], []);
                    colSep.style.width = sepwidth + "em";
                    cols.push(colSep);
                  }
                }
              }
              body = buildCommon.makeSpan(["mtable"], cols);
              if (hlines.length > 0) {
                var line = buildCommon.makeLineSpan("hline", options, 0.05);
                var dashes = buildCommon.makeLineSpan("hdashline", options, 0.05);
                var vListElems = [{
                  type: "elem",
                  elem: body,
                  shift: 0
                }];
                while (hlines.length > 0) {
                  var hline = hlines.pop();
                  var lineShift = hline.pos - offset;
                  if (hline.isDashed) {
                    vListElems.push({
                      type: "elem",
                      elem: dashes,
                      shift: lineShift
                    });
                  } else {
                    vListElems.push({
                      type: "elem",
                      elem: line,
                      shift: lineShift
                    });
                  }
                }
                body = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: vListElems
                }, options);
              }
              return buildCommon.makeSpan(["mord"], [body], options);
            };
            var alignMap = {
              c: "center ",
              l: "left ",
              r: "right "
            };
            var array_mathmlBuilder = function mathmlBuilder(group, options) {
              var table = new mathMLTree.MathNode("mtable", group.body.map(function(row) {
                return new mathMLTree.MathNode("mtr", row.map(function(cell) {
                  return new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(cell, options)]);
                }));
              }));
              var gap = 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
              table.setAttribute("rowspacing", gap + "em");
              var menclose = "";
              var align = "";
              if (group.cols) {
                var cols = group.cols;
                var columnLines = "";
                var prevTypeWasAlign = false;
                var iStart = 0;
                var iEnd = cols.length;
                if (cols[0].type === "separator") {
                  menclose += "top ";
                  iStart = 1;
                }
                if (cols[cols.length - 1].type === "separator") {
                  menclose += "bottom ";
                  iEnd -= 1;
                }
                for (var i = iStart; i < iEnd; i++) {
                  if (cols[i].type === "align") {
                    align += alignMap[cols[i].align];
                    if (prevTypeWasAlign) {
                      columnLines += "none ";
                    }
                    prevTypeWasAlign = true;
                  } else if (cols[i].type === "separator") {
                    if (prevTypeWasAlign) {
                      columnLines += cols[i].separator === "|" ? "solid " : "dashed ";
                      prevTypeWasAlign = false;
                    }
                  }
                }
                table.setAttribute("columnalign", align.trim());
                if (/[sd]/.test(columnLines)) {
                  table.setAttribute("columnlines", columnLines.trim());
                }
              }
              if (group.colSeparationType === "align") {
                var _cols = group.cols || [];
                var spacing = "";
                for (var _i = 1; _i < _cols.length; _i++) {
                  spacing += _i % 2 ? "0em " : "1em ";
                }
                table.setAttribute("columnspacing", spacing.trim());
              } else if (group.colSeparationType === "alignat") {
                table.setAttribute("columnspacing", "0em");
              } else {
                table.setAttribute("columnspacing", "1em");
              }
              var rowLines = "";
              var hlines = group.hLinesBeforeRow;
              menclose += hlines[0].length > 0 ? "left " : "";
              menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
              for (var _i2 = 1; _i2 < hlines.length - 1; _i2++) {
                rowLines += hlines[_i2].length === 0 ? "none " : hlines[_i2][0] ? "dashed " : "solid ";
              }
              if (/[sd]/.test(rowLines)) {
                table.setAttribute("rowlines", rowLines.trim());
              }
              if (menclose === "") {
                return table;
              } else {
                var wrapper = new mathMLTree.MathNode("menclose", [table]);
                wrapper.setAttribute("notation", menclose.trim());
                return wrapper;
              }
            };
            var array_alignedHandler = function alignedHandler(context, args) {
              var cols = [];
              var res = parseArray(context.parser, {
                cols,
                addJot: true
              }, "display");
              var numMaths;
              var numCols = 0;
              var emptyGroup = {
                type: "ordgroup",
                mode: context.mode,
                body: []
              };
              var ordgroup = checkNodeType(args[0], "ordgroup");
              if (ordgroup) {
                var arg0 = "";
                for (var i = 0; i < ordgroup.body.length; i++) {
                  var textord = assertNodeType(ordgroup.body[i], "textord");
                  arg0 += textord.text;
                }
                numMaths = Number(arg0);
                numCols = numMaths * 2;
              }
              var isAligned = !numCols;
              res.body.forEach(function(row) {
                for (var _i3 = 1; _i3 < row.length; _i3 += 2) {
                  var styling = assertNodeType(row[_i3], "styling");
                  var _ordgroup = assertNodeType(styling.body[0], "ordgroup");
                  _ordgroup.body.unshift(emptyGroup);
                }
                if (!isAligned) {
                  var curMaths = row.length / 2;
                  if (numMaths < curMaths) {
                    throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
                  }
                } else if (numCols < row.length) {
                  numCols = row.length;
                }
              });
              for (var _i4 = 0; _i4 < numCols; ++_i4) {
                var align = "r";
                var pregap = 0;
                if (_i4 % 2 === 1) {
                  align = "l";
                } else if (_i4 > 0 && isAligned) {
                  pregap = 1;
                }
                cols[_i4] = {
                  type: "align",
                  align,
                  pregap,
                  postgap: 0
                };
              }
              res.colSeparationType = isAligned ? "align" : "alignat";
              return res;
            };
            defineEnvironment({
              type: "array",
              names: ["array", "darray"],
              props: {
                numArgs: 1
              },
              handler: function handler(context, args) {
                var symNode = checkSymbolNodeType(args[0]);
                var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
                var cols = colalign.map(function(nde) {
                  var node = assertSymbolNodeType(nde);
                  var ca = node.text;
                  if ("lcr".indexOf(ca) !== -1) {
                    return {
                      type: "align",
                      align: ca
                    };
                  } else if (ca === "|") {
                    return {
                      type: "separator",
                      separator: "|"
                    };
                  } else if (ca === ":") {
                    return {
                      type: "separator",
                      separator: ":"
                    };
                  }
                  throw new src_ParseError("Unknown column alignment: " + ca, nde);
                });
                var res = {
                  cols,
                  hskipBeforeAndAfter: true
                  // \@preamble in lttab.dtx
                };
                return parseArray(context.parser, res, dCellStyle(context.envName));
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix"],
              props: {
                numArgs: 0
              },
              handler: function handler(context) {
                var delimiters2 = {
                  "matrix": null,
                  "pmatrix": ["(", ")"],
                  "bmatrix": ["[", "]"],
                  "Bmatrix": ["\\{", "\\}"],
                  "vmatrix": ["|", "|"],
                  "Vmatrix": ["\\Vert", "\\Vert"]
                }[context.envName];
                var payload = {
                  hskipBeforeAndAfter: false
                };
                var res = parseArray(context.parser, payload, dCellStyle(context.envName));
                return delimiters2 ? {
                  type: "leftright",
                  mode: context.mode,
                  body: [res],
                  left: delimiters2[0],
                  right: delimiters2[1]
                } : res;
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["cases", "dcases"],
              props: {
                numArgs: 0
              },
              handler: function handler(context) {
                var payload = {
                  arraystretch: 1.2,
                  cols: [{
                    type: "align",
                    align: "l",
                    pregap: 0,
                    // TODO(kevinb) get the current style.
                    // For now we use the metrics for TEXT style which is what we were
                    // doing before.  Before attempting to get the current style we
                    // should look at TeX's behavior especially for \over and matrices.
                    postgap: 1
                    /* 1em quad */
                  }, {
                    type: "align",
                    align: "l",
                    pregap: 0,
                    postgap: 0
                  }]
                };
                var res = parseArray(context.parser, payload, dCellStyle(context.envName));
                return {
                  type: "leftright",
                  mode: context.mode,
                  body: [res],
                  left: "\\{",
                  right: "."
                };
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["aligned"],
              props: {
                numArgs: 0
              },
              handler: array_alignedHandler,
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["gathered"],
              props: {
                numArgs: 0
              },
              handler: function handler(context) {
                var res = {
                  cols: [{
                    type: "align",
                    align: "c"
                  }],
                  addJot: true
                };
                return parseArray(context.parser, res, "display");
              },
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineEnvironment({
              type: "array",
              names: ["alignedat"],
              // One for numbered and for unnumbered;
              // but, KaTeX doesn't supports math numbering yet,
              // they make no difference for now.
              props: {
                numArgs: 1
              },
              handler: array_alignedHandler,
              htmlBuilder: array_htmlBuilder,
              mathmlBuilder: array_mathmlBuilder
            });
            defineFunction({
              type: "text",
              // Doesn't matter what this is.
              names: ["\\hline", "\\hdashline"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: true
              },
              handler: function handler(context, args) {
                throw new src_ParseError(context.funcName + " valid only within array environment");
              }
            });
            var environments = _environments;
            var src_environments = environments;
            defineFunction({
              type: "environment",
              names: ["\\begin", "\\end"],
              props: {
                numArgs: 1,
                argTypes: ["text"]
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var nameGroup = args[0];
                if (nameGroup.type !== "ordgroup") {
                  throw new src_ParseError("Invalid environment name", nameGroup);
                }
                var envName = "";
                for (var i = 0; i < nameGroup.body.length; ++i) {
                  envName += assertNodeType(nameGroup.body[i], "textord").text;
                }
                if (funcName === "\\begin") {
                  if (!src_environments.hasOwnProperty(envName)) {
                    throw new src_ParseError("No such environment: " + envName, nameGroup);
                  }
                  var env = src_environments[envName];
                  var _parser$parseArgument = parser.parseArguments("\\begin{" + envName + "}", env), _args = _parser$parseArgument.args, optArgs = _parser$parseArgument.optArgs;
                  var context = {
                    mode: parser.mode,
                    envName,
                    parser
                  };
                  var result = env.handler(context, _args, optArgs);
                  parser.expect("\\end", false);
                  var endNameToken = parser.nextToken;
                  var end = assertNodeType(parser.parseFunction(), "environment");
                  if (end.name !== envName) {
                    throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
                  }
                  return result;
                }
                return {
                  type: "environment",
                  mode: parser.mode,
                  name: envName,
                  nameGroup
                };
              }
            });
            var mclass_makeSpan = buildCommon.makeSpan;
            function mclass_htmlBuilder(group, options) {
              var elements = buildHTML_buildExpression(group.body, options, true);
              return mclass_makeSpan([group.mclass], elements, options);
            }
            function mclass_mathmlBuilder(group, options) {
              var inner = buildMathML_buildExpression(group.body, options);
              return mathMLTree.newDocumentFragment(inner);
            }
            defineFunction({
              type: "mclass",
              names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: "m" + funcName.substr(5),
                  body: defineFunction_ordargument(body)
                };
              },
              htmlBuilder: mclass_htmlBuilder,
              mathmlBuilder: mclass_mathmlBuilder
            });
            var binrelClass = function binrelClass2(arg) {
              var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
              if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
                return "m" + atom.family;
              } else {
                return "mord";
              }
            };
            defineFunction({
              type: "mclass",
              names: ["\\@binrel"],
              props: {
                numArgs: 2
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: binrelClass(args[0]),
                  body: [args[1]]
                };
              }
            });
            defineFunction({
              type: "mclass",
              names: ["\\stackrel", "\\overset", "\\underset"],
              props: {
                numArgs: 2
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser, funcName = _ref3.funcName;
                var baseArg = args[1];
                var shiftedArg = args[0];
                var mclass;
                if (funcName !== "\\stackrel") {
                  mclass = binrelClass(baseArg);
                } else {
                  mclass = "mrel";
                }
                var baseOp = {
                  type: "op",
                  mode: baseArg.mode,
                  limits: true,
                  alwaysHandleSupSub: true,
                  parentIsSupSub: false,
                  symbol: false,
                  suppressBaseShift: funcName !== "\\stackrel",
                  body: defineFunction_ordargument(baseArg)
                };
                var supsub = {
                  type: "supsub",
                  mode: shiftedArg.mode,
                  base: baseOp,
                  sup: funcName === "\\underset" ? null : shiftedArg,
                  sub: funcName === "\\underset" ? shiftedArg : null
                };
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass,
                  body: [supsub]
                };
              },
              htmlBuilder: mclass_htmlBuilder,
              mathmlBuilder: mclass_mathmlBuilder
            });
            var font_htmlBuilder = function htmlBuilder(group, options) {
              var font = group.font;
              var newOptions = options.withFont(font);
              return buildHTML_buildGroup(group.body, newOptions);
            };
            var font_mathmlBuilder = function mathmlBuilder(group, options) {
              var font = group.font;
              var newOptions = options.withFont(font);
              return buildMathML_buildGroup(group.body, newOptions);
            };
            var fontAliases = {
              "\\Bbb": "\\mathbb",
              "\\bold": "\\mathbf",
              "\\frak": "\\mathfrak",
              "\\bm": "\\boldsymbol"
            };
            defineFunction({
              type: "font",
              names: [
                // styles, except \boldsymbol defined below
                "\\mathrm",
                "\\mathit",
                "\\mathbf",
                "\\mathnormal",
                // families
                "\\mathbb",
                "\\mathcal",
                "\\mathfrak",
                "\\mathscr",
                "\\mathsf",
                "\\mathtt",
                // aliases, except \bm defined below
                "\\Bbb",
                "\\bold",
                "\\frak"
              ],
              props: {
                numArgs: 1,
                greediness: 2
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                var func = funcName;
                if (func in fontAliases) {
                  func = fontAliases[func];
                }
                return {
                  type: "font",
                  mode: parser.mode,
                  font: func.slice(1),
                  body
                };
              },
              htmlBuilder: font_htmlBuilder,
              mathmlBuilder: font_mathmlBuilder
            });
            defineFunction({
              type: "mclass",
              names: ["\\boldsymbol", "\\bm"],
              props: {
                numArgs: 1,
                greediness: 2
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                var body = args[0];
                return {
                  type: "mclass",
                  mode: parser.mode,
                  mclass: binrelClass(body),
                  body: [{
                    type: "font",
                    mode: parser.mode,
                    font: "boldsymbol",
                    body
                  }]
                };
              }
            });
            defineFunction({
              type: "font",
              names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser, funcName = _ref3.funcName, breakOnTokenText = _ref3.breakOnTokenText;
                var mode = parser.mode;
                var body = parser.parseExpression(true, breakOnTokenText);
                var style = "math" + funcName.slice(1);
                return {
                  type: "font",
                  mode,
                  font: style,
                  body: {
                    type: "ordgroup",
                    mode: parser.mode,
                    body
                  }
                };
              },
              htmlBuilder: font_htmlBuilder,
              mathmlBuilder: font_mathmlBuilder
            });
            var genfrac_adjustStyle = function adjustStyle(size, originalStyle) {
              var style = originalStyle;
              if (size === "display") {
                style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
              } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
                style = src_Style.TEXT;
              } else if (size === "script") {
                style = src_Style.SCRIPT;
              } else if (size === "scriptscript") {
                style = src_Style.SCRIPTSCRIPT;
              }
              return style;
            };
            var genfrac_htmlBuilder = function htmlBuilder(group, options) {
              var style = genfrac_adjustStyle(group.size, options.style);
              var nstyle = style.fracNum();
              var dstyle = style.fracDen();
              var newOptions;
              newOptions = options.havingStyle(nstyle);
              var numerm = buildHTML_buildGroup(group.numer, newOptions, options);
              if (group.continued) {
                var hStrut = 8.5 / options.fontMetrics().ptPerEm;
                var dStrut = 3.5 / options.fontMetrics().ptPerEm;
                numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
                numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
              }
              newOptions = options.havingStyle(dstyle);
              var denomm = buildHTML_buildGroup(group.denom, newOptions, options);
              var rule;
              var ruleWidth;
              var ruleSpacing;
              if (group.hasBarLine) {
                if (group.barSize) {
                  ruleWidth = units_calculateSize(group.barSize, options);
                  rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
                } else {
                  rule = buildCommon.makeLineSpan("frac-line", options);
                }
                ruleWidth = rule.height;
                ruleSpacing = rule.height;
              } else {
                rule = null;
                ruleWidth = 0;
                ruleSpacing = options.fontMetrics().defaultRuleThickness;
              }
              var numShift;
              var clearance;
              var denomShift;
              if (style.size === src_Style.DISPLAY.size || group.size === "display") {
                numShift = options.fontMetrics().num1;
                if (ruleWidth > 0) {
                  clearance = 3 * ruleSpacing;
                } else {
                  clearance = 7 * ruleSpacing;
                }
                denomShift = options.fontMetrics().denom1;
              } else {
                if (ruleWidth > 0) {
                  numShift = options.fontMetrics().num2;
                  clearance = ruleSpacing;
                } else {
                  numShift = options.fontMetrics().num3;
                  clearance = 3 * ruleSpacing;
                }
                denomShift = options.fontMetrics().denom2;
              }
              var frac;
              if (!rule) {
                var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
                if (candidateClearance < clearance) {
                  numShift += 0.5 * (clearance - candidateClearance);
                  denomShift += 0.5 * (clearance - candidateClearance);
                }
                frac = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: denomm,
                    shift: denomShift
                  }, {
                    type: "elem",
                    elem: numerm,
                    shift: -numShift
                  }]
                }, options);
              } else {
                var axisHeight = options.fontMetrics().axisHeight;
                if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
                  numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
                }
                if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
                  denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
                }
                var midShift = -(axisHeight - 0.5 * ruleWidth);
                frac = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: denomm,
                    shift: denomShift
                  }, {
                    type: "elem",
                    elem: rule,
                    shift: midShift
                  }, {
                    type: "elem",
                    elem: numerm,
                    shift: -numShift
                  }]
                }, options);
              }
              newOptions = options.havingStyle(style);
              frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
              frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
              var delimSize;
              if (style.size === src_Style.DISPLAY.size) {
                delimSize = options.fontMetrics().delim1;
              } else {
                delimSize = options.fontMetrics().delim2;
              }
              var leftDelim;
              var rightDelim;
              if (group.leftDelim == null) {
                leftDelim = makeNullDelimiter(options, ["mopen"]);
              } else {
                leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
              }
              if (group.continued) {
                rightDelim = buildCommon.makeSpan([]);
              } else if (group.rightDelim == null) {
                rightDelim = makeNullDelimiter(options, ["mclose"]);
              } else {
                rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
              }
              return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
            };
            var genfrac_mathmlBuilder = function mathmlBuilder(group, options) {
              var node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
              if (!group.hasBarLine) {
                node.setAttribute("linethickness", "0px");
              } else if (group.barSize) {
                var ruleWidth = units_calculateSize(group.barSize, options);
                node.setAttribute("linethickness", ruleWidth + "em");
              }
              var style = genfrac_adjustStyle(group.size, options.style);
              if (style.size !== options.style.size) {
                node = new mathMLTree.MathNode("mstyle", [node]);
                var isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
                node.setAttribute("displaystyle", isDisplay);
                node.setAttribute("scriptlevel", "0");
              }
              if (group.leftDelim != null || group.rightDelim != null) {
                var withDelims = [];
                if (group.leftDelim != null) {
                  var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
                  leftOp.setAttribute("fence", "true");
                  withDelims.push(leftOp);
                }
                withDelims.push(node);
                if (group.rightDelim != null) {
                  var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
                  rightOp.setAttribute("fence", "true");
                  withDelims.push(rightOp);
                }
                return buildMathML_makeRow(withDelims);
              }
              return node;
            };
            defineFunction({
              type: "genfrac",
              names: [
                "\\cfrac",
                "\\dfrac",
                "\\frac",
                "\\tfrac",
                "\\dbinom",
                "\\binom",
                "\\tbinom",
                "\\\\atopfrac",
                // can’t be entered directly
                "\\\\bracefrac",
                "\\\\brackfrac"
              ],
              props: {
                numArgs: 2,
                greediness: 2
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var numer = args[0];
                var denom = args[1];
                var hasBarLine;
                var leftDelim = null;
                var rightDelim = null;
                var size = "auto";
                switch (funcName) {
                  case "\\cfrac":
                  case "\\dfrac":
                  case "\\frac":
                  case "\\tfrac":
                    hasBarLine = true;
                    break;
                  case "\\\\atopfrac":
                    hasBarLine = false;
                    break;
                  case "\\dbinom":
                  case "\\binom":
                  case "\\tbinom":
                    hasBarLine = false;
                    leftDelim = "(";
                    rightDelim = ")";
                    break;
                  case "\\\\bracefrac":
                    hasBarLine = false;
                    leftDelim = "\\{";
                    rightDelim = "\\}";
                    break;
                  case "\\\\brackfrac":
                    hasBarLine = false;
                    leftDelim = "[";
                    rightDelim = "]";
                    break;
                  default:
                    throw new Error("Unrecognized genfrac command");
                }
                switch (funcName) {
                  case "\\cfrac":
                  case "\\dfrac":
                  case "\\dbinom":
                    size = "display";
                    break;
                  case "\\tfrac":
                  case "\\tbinom":
                    size = "text";
                    break;
                }
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  continued: funcName === "\\cfrac",
                  numer,
                  denom,
                  hasBarLine,
                  leftDelim,
                  rightDelim,
                  size,
                  barSize: null
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            defineFunction({
              type: "infix",
              names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
              props: {
                numArgs: 0,
                infix: true
              },
              handler: function handler(_ref2) {
                var parser = _ref2.parser, funcName = _ref2.funcName, token = _ref2.token;
                var replaceWith;
                switch (funcName) {
                  case "\\over":
                    replaceWith = "\\frac";
                    break;
                  case "\\choose":
                    replaceWith = "\\binom";
                    break;
                  case "\\atop":
                    replaceWith = "\\\\atopfrac";
                    break;
                  case "\\brace":
                    replaceWith = "\\\\bracefrac";
                    break;
                  case "\\brack":
                    replaceWith = "\\\\brackfrac";
                    break;
                  default:
                    throw new Error("Unrecognized infix genfrac command");
                }
                return {
                  type: "infix",
                  mode: parser.mode,
                  replaceWith,
                  token
                };
              }
            });
            var stylArray = ["display", "text", "script", "scriptscript"];
            var delimFromValue = function delimFromValue2(delimString) {
              var delim = null;
              if (delimString.length > 0) {
                delim = delimString;
                delim = delim === "." ? null : delim;
              }
              return delim;
            };
            defineFunction({
              type: "genfrac",
              names: ["\\genfrac"],
              props: {
                numArgs: 6,
                greediness: 6,
                argTypes: ["math", "math", "size", "text", "math", "math"]
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser;
                var numer = args[4];
                var denom = args[5];
                var leftNode = checkNodeType(args[0], "atom");
                if (leftNode) {
                  leftNode = assertAtomFamily(args[0], "open");
                }
                var leftDelim = leftNode ? delimFromValue(leftNode.text) : null;
                var rightNode = checkNodeType(args[1], "atom");
                if (rightNode) {
                  rightNode = assertAtomFamily(args[1], "close");
                }
                var rightDelim = rightNode ? delimFromValue(rightNode.text) : null;
                var barNode = assertNodeType(args[2], "size");
                var hasBarLine;
                var barSize = null;
                if (barNode.isBlank) {
                  hasBarLine = true;
                } else {
                  barSize = barNode.value;
                  hasBarLine = barSize.number > 0;
                }
                var size = "auto";
                var styl = checkNodeType(args[3], "ordgroup");
                if (styl) {
                  if (styl.body.length > 0) {
                    var textOrd = assertNodeType(styl.body[0], "textord");
                    size = stylArray[Number(textOrd.text)];
                  }
                } else {
                  styl = assertNodeType(args[3], "textord");
                  size = stylArray[Number(styl.text)];
                }
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  numer,
                  denom,
                  continued: false,
                  hasBarLine,
                  barSize,
                  leftDelim,
                  rightDelim,
                  size
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            defineFunction({
              type: "infix",
              names: ["\\above"],
              props: {
                numArgs: 1,
                argTypes: ["size"],
                infix: true
              },
              handler: function handler(_ref4, args) {
                var parser = _ref4.parser, funcName = _ref4.funcName, token = _ref4.token;
                return {
                  type: "infix",
                  mode: parser.mode,
                  replaceWith: "\\\\abovefrac",
                  size: assertNodeType(args[0], "size").value,
                  token
                };
              }
            });
            defineFunction({
              type: "genfrac",
              names: ["\\\\abovefrac"],
              props: {
                numArgs: 3,
                argTypes: ["math", "size", "math"]
              },
              handler: function handler(_ref5, args) {
                var parser = _ref5.parser, funcName = _ref5.funcName;
                var numer = args[0];
                var barSize = assert(assertNodeType(args[1], "infix").size);
                var denom = args[2];
                var hasBarLine = barSize.number > 0;
                return {
                  type: "genfrac",
                  mode: parser.mode,
                  numer,
                  denom,
                  continued: false,
                  hasBarLine,
                  barSize,
                  leftDelim: null,
                  rightDelim: null,
                  size: "auto"
                };
              },
              htmlBuilder: genfrac_htmlBuilder,
              mathmlBuilder: genfrac_mathmlBuilder
            });
            var horizBrace_htmlBuilder = function htmlBuilder(grp, options) {
              var style = options.style;
              var supSubGroup;
              var group;
              var supSub = checkNodeType(grp, "supsub");
              if (supSub) {
                supSubGroup = supSub.sup ? buildHTML_buildGroup(supSub.sup, options.havingStyle(style.sup()), options) : buildHTML_buildGroup(supSub.sub, options.havingStyle(style.sub()), options);
                group = assertNodeType(supSub.base, "horizBrace");
              } else {
                group = assertNodeType(grp, "horizBrace");
              }
              var body = buildHTML_buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
              var braceBody = stretchy.svgSpan(group, options);
              var vlist;
              if (group.isOver) {
                vlist = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: body
                  }, {
                    type: "kern",
                    size: 0.1
                  }, {
                    type: "elem",
                    elem: braceBody
                  }]
                }, options);
                vlist.children[0].children[0].children[1].classes.push("svg-align");
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: body.depth + 0.1 + braceBody.height,
                  children: [{
                    type: "elem",
                    elem: braceBody
                  }, {
                    type: "kern",
                    size: 0.1
                  }, {
                    type: "elem",
                    elem: body
                  }]
                }, options);
                vlist.children[0].children[0].children[0].classes.push("svg-align");
              }
              if (supSubGroup) {
                var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
                if (group.isOver) {
                  vlist = buildCommon.makeVList({
                    positionType: "firstBaseline",
                    children: [{
                      type: "elem",
                      elem: vSpan
                    }, {
                      type: "kern",
                      size: 0.2
                    }, {
                      type: "elem",
                      elem: supSubGroup
                    }]
                  }, options);
                } else {
                  vlist = buildCommon.makeVList({
                    positionType: "bottom",
                    positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                    children: [{
                      type: "elem",
                      elem: supSubGroup
                    }, {
                      type: "kern",
                      size: 0.2
                    }, {
                      type: "elem",
                      elem: vSpan
                    }]
                  }, options);
                }
              }
              return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
            };
            var horizBrace_mathmlBuilder = function mathmlBuilder(group, options) {
              var accentNode = stretchy.mathMLnode(group.label);
              return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
            };
            defineFunction({
              type: "horizBrace",
              names: ["\\overbrace", "\\underbrace"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                return {
                  type: "horizBrace",
                  mode: parser.mode,
                  label: funcName,
                  isOver: /^\\over/.test(funcName),
                  base: args[0]
                };
              },
              htmlBuilder: horizBrace_htmlBuilder,
              mathmlBuilder: horizBrace_mathmlBuilder
            });
            defineFunction({
              type: "href",
              names: ["\\href"],
              props: {
                numArgs: 2,
                argTypes: ["url", "original"],
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var body = args[1];
                var href = assertNodeType(args[0], "url").url;
                return {
                  type: "href",
                  mode: parser.mode,
                  href,
                  body: defineFunction_ordargument(body)
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var elements = buildHTML_buildExpression(group.body, options, false);
                return buildCommon.makeAnchor(group.href, [], elements, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var math = buildExpressionRow(group.body, options);
                if (!(math instanceof mathMLTree_MathNode)) {
                  math = new mathMLTree_MathNode("mrow", [math]);
                }
                math.setAttribute("href", group.href);
                return math;
              }
            });
            defineFunction({
              type: "href",
              names: ["\\url"],
              props: {
                numArgs: 1,
                argTypes: ["url"],
                allowedInText: true
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                var href = assertNodeType(args[0], "url").url;
                var chars = [];
                for (var i = 0; i < href.length; i++) {
                  var c = href[i];
                  if (c === "~") {
                    c = "\\textasciitilde";
                  }
                  chars.push({
                    type: "textord",
                    mode: "text",
                    text: c
                  });
                }
                var body = {
                  type: "text",
                  mode: parser.mode,
                  font: "\\texttt",
                  body: chars
                };
                return {
                  type: "href",
                  mode: parser.mode,
                  href,
                  body: defineFunction_ordargument(body)
                };
              }
            });
            defineFunction({
              type: "htmlmathml",
              names: ["\\html@mathml"],
              props: {
                numArgs: 2,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                return {
                  type: "htmlmathml",
                  mode: parser.mode,
                  html: defineFunction_ordargument(args[0]),
                  mathml: defineFunction_ordargument(args[1])
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var elements = buildHTML_buildExpression(group.html, options, false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                return buildExpressionRow(group.mathml, options);
              }
            });
            defineFunction({
              type: "kern",
              names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
              props: {
                numArgs: 1,
                argTypes: ["size"],
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var size = assertNodeType(args[0], "size");
                if (parser.settings.strict) {
                  var mathFunction = funcName[1] === "m";
                  var muUnit = size.value.unit === "mu";
                  if (mathFunction) {
                    if (!muUnit) {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
                    }
                    if (parser.mode !== "math") {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                    }
                  } else {
                    if (muUnit) {
                      parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                    }
                  }
                }
                return {
                  type: "kern",
                  mode: parser.mode,
                  dimension: size.value
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                return buildCommon.makeGlue(group.dimension, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var dimension = units_calculateSize(group.dimension, options);
                return new mathMLTree.SpaceNode(dimension);
              }
            });
            defineFunction({
              type: "lap",
              names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                return {
                  type: "lap",
                  mode: parser.mode,
                  alignment: funcName.slice(5),
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var inner;
                if (group.alignment === "clap") {
                  inner = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]);
                  inner = buildCommon.makeSpan(["inner"], [inner], options);
                } else {
                  inner = buildCommon.makeSpan(["inner"], [buildHTML_buildGroup(group.body, options)]);
                }
                var fix = buildCommon.makeSpan(["fix"], []);
                var node = buildCommon.makeSpan([group.alignment], [inner, fix], options);
                var strut = buildCommon.makeSpan(["strut"]);
                strut.style.height = node.height + node.depth + "em";
                strut.style.verticalAlign = -node.depth + "em";
                node.children.unshift(strut);
                node = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: node
                  }]
                }, options);
                return buildCommon.makeSpan(["mord"], [node], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                if (group.alignment !== "rlap") {
                  var offset = group.alignment === "llap" ? "-1" : "-0.5";
                  node.setAttribute("lspace", offset + "width");
                }
                node.setAttribute("width", "0px");
                return node;
              }
            });
            defineFunction({
              type: "styling",
              names: ["\\(", "$"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: false,
                consumeMode: "math"
              },
              handler: function handler(_ref, args) {
                var funcName = _ref.funcName, parser = _ref.parser;
                var outerMode = parser.mode;
                parser.switchMode("math");
                var close = funcName === "\\(" ? "\\)" : "$";
                var body = parser.parseExpression(false, close);
                parser.expect(close, false);
                parser.switchMode(outerMode);
                parser.consume();
                return {
                  type: "styling",
                  mode: parser.mode,
                  style: "text",
                  body
                };
              }
            });
            defineFunction({
              type: "text",
              // Doesn't matter what this is.
              names: ["\\)", "\\]"],
              props: {
                numArgs: 0,
                allowedInText: true,
                allowedInMath: false
              },
              handler: function handler(context, args) {
                throw new src_ParseError("Mismatched " + context.funcName);
              }
            });
            var mathchoice_chooseMathStyle = function chooseMathStyle(group, options) {
              switch (options.style.size) {
                case src_Style.DISPLAY.size:
                  return group.display;
                case src_Style.TEXT.size:
                  return group.text;
                case src_Style.SCRIPT.size:
                  return group.script;
                case src_Style.SCRIPTSCRIPT.size:
                  return group.scriptscript;
                default:
                  return group.text;
              }
            };
            defineFunction({
              type: "mathchoice",
              names: ["\\mathchoice"],
              props: {
                numArgs: 4
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                return {
                  type: "mathchoice",
                  mode: parser.mode,
                  display: defineFunction_ordargument(args[0]),
                  text: defineFunction_ordargument(args[1]),
                  script: defineFunction_ordargument(args[2]),
                  scriptscript: defineFunction_ordargument(args[3])
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var body = mathchoice_chooseMathStyle(group, options);
                var elements = buildHTML_buildExpression(body, options, false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var body = mathchoice_chooseMathStyle(group, options);
                return buildExpressionRow(body, options);
              }
            });
            var noSuccessor = ["\\smallint"];
            var op_htmlBuilder = function htmlBuilder(grp, options) {
              var supGroup;
              var subGroup;
              var hasLimits = false;
              var group;
              var supSub = checkNodeType(grp, "supsub");
              if (supSub) {
                supGroup = supSub.sup;
                subGroup = supSub.sub;
                group = assertNodeType(supSub.base, "op");
                hasLimits = true;
              } else {
                group = assertNodeType(grp, "op");
              }
              var style = options.style;
              var large = false;
              if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
                large = true;
              }
              var base;
              if (group.symbol) {
                var fontName = large ? "Size2-Regular" : "Size1-Regular";
                var stash = "";
                if (group.name === "\\oiint" || group.name === "\\oiiint") {
                  stash = group.name.substr(1);
                  group.name = stash === "oiint" ? "\\iint" : "\\iiint";
                }
                base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
                if (stash.length > 0) {
                  var italic = base.italic;
                  var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
                  base = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: [{
                      type: "elem",
                      elem: base,
                      shift: 0
                    }, {
                      type: "elem",
                      elem: oval,
                      shift: large ? 0.08 : 0
                    }]
                  }, options);
                  group.name = "\\" + stash;
                  base.classes.unshift("mop");
                  base.italic = italic;
                }
              } else if (group.body) {
                var inner = buildHTML_buildExpression(group.body, options, true);
                if (inner.length === 1 && inner[0] instanceof domTree_SymbolNode) {
                  base = inner[0];
                  base.classes[0] = "mop";
                } else {
                  base = buildCommon.makeSpan(["mop"], buildCommon.tryCombineChars(inner), options);
                }
              } else {
                var output = [];
                for (var i = 1; i < group.name.length; i++) {
                  output.push(buildCommon.mathsym(group.name[i], group.mode));
                }
                base = buildCommon.makeSpan(["mop"], output, options);
              }
              var baseShift = 0;
              var slant = 0;
              if ((base instanceof domTree_SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
                baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
                slant = base.italic;
              }
              if (hasLimits) {
                base = buildCommon.makeSpan([], [base]);
                var sub;
                var sup;
                if (supGroup) {
                  var elem = buildHTML_buildGroup(supGroup, options.havingStyle(style.sup()), options);
                  sup = {
                    elem,
                    kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
                  };
                }
                if (subGroup) {
                  var _elem = buildHTML_buildGroup(subGroup, options.havingStyle(style.sub()), options);
                  sub = {
                    elem: _elem,
                    kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
                  };
                }
                var finalGroup;
                if (sup && sub) {
                  var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;
                  finalGroup = buildCommon.makeVList({
                    positionType: "bottom",
                    positionData: bottom,
                    children: [{
                      type: "kern",
                      size: options.fontMetrics().bigOpSpacing5
                    }, {
                      type: "elem",
                      elem: sub.elem,
                      marginLeft: -slant + "em"
                    }, {
                      type: "kern",
                      size: sub.kern
                    }, {
                      type: "elem",
                      elem: base
                    }, {
                      type: "kern",
                      size: sup.kern
                    }, {
                      type: "elem",
                      elem: sup.elem,
                      marginLeft: slant + "em"
                    }, {
                      type: "kern",
                      size: options.fontMetrics().bigOpSpacing5
                    }]
                  }, options);
                } else if (sub) {
                  var top = base.height - baseShift;
                  finalGroup = buildCommon.makeVList({
                    positionType: "top",
                    positionData: top,
                    children: [{
                      type: "kern",
                      size: options.fontMetrics().bigOpSpacing5
                    }, {
                      type: "elem",
                      elem: sub.elem,
                      marginLeft: -slant + "em"
                    }, {
                      type: "kern",
                      size: sub.kern
                    }, {
                      type: "elem",
                      elem: base
                    }]
                  }, options);
                } else if (sup) {
                  var _bottom = base.depth + baseShift;
                  finalGroup = buildCommon.makeVList({
                    positionType: "bottom",
                    positionData: _bottom,
                    children: [{
                      type: "elem",
                      elem: base
                    }, {
                      type: "kern",
                      size: sup.kern
                    }, {
                      type: "elem",
                      elem: sup.elem,
                      marginLeft: slant + "em"
                    }, {
                      type: "kern",
                      size: options.fontMetrics().bigOpSpacing5
                    }]
                  }, options);
                } else {
                  return base;
                }
                return buildCommon.makeSpan(["mop", "op-limits"], [finalGroup], options);
              } else {
                if (baseShift) {
                  base.style.position = "relative";
                  base.style.top = baseShift + "em";
                }
                return base;
              }
            };
            var op_mathmlBuilder = function mathmlBuilder(group, options) {
              var node;
              if (group.symbol) {
                node = new mathMLTree_MathNode("mo", [buildMathML_makeText(group.name, group.mode)]);
                if (utils.contains(noSuccessor, group.name)) {
                  node.setAttribute("largeop", "false");
                }
              } else if (group.body) {
                node = new mathMLTree_MathNode("mo", buildMathML_buildExpression(group.body, options));
              } else {
                node = new mathMLTree_MathNode("mi", [new mathMLTree_TextNode(group.name.slice(1))]);
                var operator = new mathMLTree_MathNode("mo", [buildMathML_makeText("\u2061", "text")]);
                if (group.parentIsSupSub) {
                  node = new mathMLTree_MathNode("mo", [node, operator]);
                } else {
                  node = newDocumentFragment([node, operator]);
                }
              }
              return node;
            };
            var singleCharBigOps = {
              "\u220F": "\\prod",
              "\u2210": "\\coprod",
              "\u2211": "\\sum",
              "\u22C0": "\\bigwedge",
              "\u22C1": "\\bigvee",
              "\u22C2": "\\bigcap",
              "\u22C3": "\\bigcup",
              "\u2A00": "\\bigodot",
              "\u2A01": "\\bigoplus",
              "\u2A02": "\\bigotimes",
              "\u2A04": "\\biguplus",
              "\u2A06": "\\bigsqcup"
            };
            defineFunction({
              type: "op",
              names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
              props: {
                numArgs: 0
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var fName = funcName;
                if (fName.length === 1) {
                  fName = singleCharBigOps[fName];
                }
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: true,
                  parentIsSupSub: false,
                  symbol: true,
                  name: fName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\mathop"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                var body = args[0];
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: false,
                  body: defineFunction_ordargument(body)
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            var singleCharIntegrals = {
              "\u222B": "\\int",
              "\u222C": "\\iint",
              "\u222D": "\\iiint",
              "\u222E": "\\oint",
              "\u222F": "\\oiint",
              "\u2230": "\\oiiint"
            };
            defineFunction({
              type: "op",
              names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
              props: {
                numArgs: 0
              },
              handler: function handler(_ref3) {
                var parser = _ref3.parser, funcName = _ref3.funcName;
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: false,
                  name: funcName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
              props: {
                numArgs: 0
              },
              handler: function handler(_ref4) {
                var parser = _ref4.parser, funcName = _ref4.funcName;
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: true,
                  parentIsSupSub: false,
                  symbol: false,
                  name: funcName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "op",
              names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
              props: {
                numArgs: 0
              },
              handler: function handler(_ref5) {
                var parser = _ref5.parser, funcName = _ref5.funcName;
                var fName = funcName;
                if (fName.length === 1) {
                  fName = singleCharIntegrals[fName];
                }
                return {
                  type: "op",
                  mode: parser.mode,
                  limits: false,
                  parentIsSupSub: false,
                  symbol: true,
                  name: fName
                };
              },
              htmlBuilder: op_htmlBuilder,
              mathmlBuilder: op_mathmlBuilder
            });
            defineFunction({
              type: "operatorname",
              names: ["\\operatorname"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var body = args[0];
                return {
                  type: "operatorname",
                  mode: parser.mode,
                  body: defineFunction_ordargument(body)
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                if (group.body.length > 0) {
                  var body = group.body.map(function(child2) {
                    var childText = child2.text;
                    if (typeof childText === "string") {
                      return {
                        type: "textord",
                        mode: child2.mode,
                        text: childText
                      };
                    } else {
                      return child2;
                    }
                  });
                  var expression = buildHTML_buildExpression(body, options.withFont("mathrm"), true);
                  for (var i = 0; i < expression.length; i++) {
                    var child = expression[i];
                    if (child instanceof domTree_SymbolNode) {
                      child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                    }
                  }
                  return buildCommon.makeSpan(["mop"], expression, options);
                } else {
                  return buildCommon.makeSpan(["mop"], [], options);
                }
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
                var isAllString = true;
                for (var i = 0; i < expression.length; i++) {
                  var node = expression[i];
                  if (node instanceof mathMLTree.SpaceNode) {
                  } else if (node instanceof mathMLTree.MathNode) {
                    switch (node.type) {
                      case "mi":
                      case "mn":
                      case "ms":
                      case "mspace":
                      case "mtext":
                        break;
                      // Do nothing yet.
                      case "mo": {
                        var child = node.children[0];
                        if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                          child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                        } else {
                          isAllString = false;
                        }
                        break;
                      }
                      default:
                        isAllString = false;
                    }
                  } else {
                    isAllString = false;
                  }
                }
                if (isAllString) {
                  var word = expression.map(function(node2) {
                    return node2.toText();
                  }).join("");
                  expression = [new mathMLTree.TextNode(word)];
                }
                var identifier = new mathMLTree.MathNode("mi", expression);
                identifier.setAttribute("mathvariant", "normal");
                var operator = new mathMLTree.MathNode("mo", [buildMathML_makeText("\u2061", "text")]);
                return mathMLTree.newDocumentFragment([identifier, operator]);
              }
            });
            defineFunctionBuilders({
              type: "ordgroup",
              htmlBuilder: function htmlBuilder(group, options) {
                if (group.semisimple) {
                  return buildCommon.makeFragment(buildHTML_buildExpression(group.body, options, false));
                }
                return buildCommon.makeSpan(["mord"], buildHTML_buildExpression(group.body, options, true), options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                return buildExpressionRow(group.body, options);
              }
            });
            defineFunction({
              type: "overline",
              names: ["\\overline"],
              props: {
                numArgs: 1
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var body = args[0];
                return {
                  type: "overline",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var innerGroup = buildHTML_buildGroup(group.body, options.havingCrampedStyle());
                var line = buildCommon.makeLineSpan("overline-line", options);
                var vlist = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: innerGroup
                  }, {
                    type: "kern",
                    size: 3 * line.height
                  }, {
                    type: "elem",
                    elem: line
                  }, {
                    type: "kern",
                    size: line.height
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
                operator.setAttribute("stretchy", "true");
                var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
                node.setAttribute("accent", "true");
                return node;
              }
            });
            defineFunction({
              type: "phantom",
              names: ["\\phantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var body = args[0];
                return {
                  type: "phantom",
                  mode: parser.mode,
                  body: defineFunction_ordargument(body)
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var elements = buildHTML_buildExpression(group.body, options.withPhantom(), false);
                return buildCommon.makeFragment(elements);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var inner = buildMathML_buildExpression(group.body, options);
                return new mathMLTree.MathNode("mphantom", inner);
              }
            });
            defineFunction({
              type: "hphantom",
              names: ["\\hphantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref2, args) {
                var parser = _ref2.parser;
                var body = args[0];
                return {
                  type: "hphantom",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options.withPhantom())]);
                node.height = 0;
                node.depth = 0;
                if (node.children) {
                  for (var i = 0; i < node.children.length; i++) {
                    node.children[i].height = 0;
                    node.children[i].depth = 0;
                  }
                }
                node = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: node
                  }]
                }, options);
                return buildCommon.makeSpan(["mord"], [node], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var inner = buildMathML_buildExpression(defineFunction_ordargument(group.body), options);
                var phantom = new mathMLTree.MathNode("mphantom", inner);
                var node = new mathMLTree.MathNode("mpadded", [phantom]);
                node.setAttribute("height", "0px");
                node.setAttribute("depth", "0px");
                return node;
              }
            });
            defineFunction({
              type: "vphantom",
              names: ["\\vphantom"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref3, args) {
                var parser = _ref3.parser;
                var body = args[0];
                return {
                  type: "vphantom",
                  mode: parser.mode,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var inner = buildCommon.makeSpan(["inner"], [buildHTML_buildGroup(group.body, options.withPhantom())]);
                var fix = buildCommon.makeSpan(["fix"], []);
                return buildCommon.makeSpan(["mord", "rlap"], [inner, fix], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var inner = buildMathML_buildExpression(defineFunction_ordargument(group.body), options);
                var phantom = new mathMLTree.MathNode("mphantom", inner);
                var node = new mathMLTree.MathNode("mpadded", [phantom]);
                node.setAttribute("width", "0px");
                return node;
              }
            });
            function sizingGroup(value, options, baseOptions) {
              var inner = buildHTML_buildExpression(value, options, false);
              var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
              for (var i = 0; i < inner.length; i++) {
                var pos = inner[i].classes.indexOf("sizing");
                if (pos < 0) {
                  Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));
                } else if (inner[i].classes[pos + 1] === "reset-size" + options.size) {
                  inner[i].classes[pos + 1] = "reset-size" + baseOptions.size;
                }
                inner[i].height *= multiplier;
                inner[i].depth *= multiplier;
              }
              return buildCommon.makeFragment(inner);
            }
            var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
            var sizing_htmlBuilder = function htmlBuilder(group, options) {
              var newOptions = options.havingSize(group.size);
              return sizingGroup(group.body, newOptions, options);
            };
            defineFunction({
              type: "sizing",
              names: sizeFuncs,
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
                var body = parser.parseExpression(false, breakOnTokenText);
                return {
                  type: "sizing",
                  mode: parser.mode,
                  // Figure out what size to use based on the list of functions above
                  size: sizeFuncs.indexOf(funcName) + 1,
                  body
                };
              },
              htmlBuilder: sizing_htmlBuilder,
              mathmlBuilder: function mathmlBuilder(group, options) {
                var newOptions = options.havingSize(group.size);
                var inner = buildMathML_buildExpression(group.body, newOptions);
                var node = new mathMLTree.MathNode("mstyle", inner);
                node.setAttribute("mathsize", newOptions.sizeMultiplier + "em");
                return node;
              }
            });
            defineFunction({
              type: "raisebox",
              names: ["\\raisebox"],
              props: {
                numArgs: 2,
                argTypes: ["size", "text"],
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                var amount = assertNodeType(args[0], "size").value;
                var body = args[1];
                return {
                  type: "raisebox",
                  mode: parser.mode,
                  dy: amount,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var text = {
                  type: "text",
                  mode: group.mode,
                  body: defineFunction_ordargument(group.body),
                  font: "mathrm"
                  // simulate \textrm
                };
                var sizedText = {
                  type: "sizing",
                  mode: group.mode,
                  body: [text],
                  size: 6
                  // simulate \normalsize
                };
                var body = sizing_htmlBuilder(sizedText, options);
                var dy = units_calculateSize(group.dy, options);
                return buildCommon.makeVList({
                  positionType: "shift",
                  positionData: -dy,
                  children: [{
                    type: "elem",
                    elem: body
                  }]
                }, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                var dy = group.dy.number + group.dy.unit;
                node.setAttribute("voffset", dy);
                return node;
              }
            });
            defineFunction({
              type: "rule",
              names: ["\\rule"],
              props: {
                numArgs: 2,
                numOptionalArgs: 1,
                argTypes: ["size", "size", "size"]
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser;
                var shift = optArgs[0];
                var width = assertNodeType(args[0], "size");
                var height = assertNodeType(args[1], "size");
                return {
                  type: "rule",
                  mode: parser.mode,
                  shift: shift && assertNodeType(shift, "size").value,
                  width: width.value,
                  height: height.value
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
                var width = units_calculateSize(group.width, options);
                var height = units_calculateSize(group.height, options);
                var shift = group.shift ? units_calculateSize(group.shift, options) : 0;
                rule.style.borderRightWidth = width + "em";
                rule.style.borderTopWidth = height + "em";
                rule.style.bottom = shift + "em";
                rule.width = width;
                rule.height = height + shift;
                rule.depth = -shift;
                rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
                return rule;
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var width = units_calculateSize(group.width, options);
                var height = units_calculateSize(group.height, options);
                var shift = group.shift ? units_calculateSize(group.shift, options) : 0;
                var color3 = options.color && options.getColor() || "black";
                var rule = new mathMLTree.MathNode("mspace");
                rule.setAttribute("mathbackground", color3);
                rule.setAttribute("width", width + "em");
                rule.setAttribute("height", height + "em");
                var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
                if (shift >= 0) {
                  wrapper.setAttribute("height", "+" + shift + "em");
                } else {
                  wrapper.setAttribute("height", shift + "em");
                  wrapper.setAttribute("depth", "+" + -shift + "em");
                }
                wrapper.setAttribute("voffset", shift + "em");
                return wrapper;
              }
            });
            defineFunction({
              type: "smash",
              names: ["\\smash"],
              props: {
                numArgs: 1,
                numOptionalArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser;
                var smashHeight = false;
                var smashDepth = false;
                var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
                if (tbArg) {
                  var letter = "";
                  for (var i = 0; i < tbArg.body.length; ++i) {
                    var node = tbArg.body[i];
                    letter = node.text;
                    if (letter === "t") {
                      smashHeight = true;
                    } else if (letter === "b") {
                      smashDepth = true;
                    } else {
                      smashHeight = false;
                      smashDepth = false;
                      break;
                    }
                  }
                } else {
                  smashHeight = true;
                  smashDepth = true;
                }
                var body = args[0];
                return {
                  type: "smash",
                  mode: parser.mode,
                  body,
                  smashHeight,
                  smashDepth
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var node = buildCommon.makeSpan([], [buildHTML_buildGroup(group.body, options)]);
                if (!group.smashHeight && !group.smashDepth) {
                  return node;
                }
                if (group.smashHeight) {
                  node.height = 0;
                  if (node.children) {
                    for (var i = 0; i < node.children.length; i++) {
                      node.children[i].height = 0;
                    }
                  }
                }
                if (group.smashDepth) {
                  node.depth = 0;
                  if (node.children) {
                    for (var _i = 0; _i < node.children.length; _i++) {
                      node.children[_i].depth = 0;
                    }
                  }
                }
                var smashedNode = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: node
                  }]
                }, options);
                return buildCommon.makeSpan(["mord"], [smashedNode], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
                if (group.smashHeight) {
                  node.setAttribute("height", "0px");
                }
                if (group.smashDepth) {
                  node.setAttribute("depth", "0px");
                }
                return node;
              }
            });
            defineFunction({
              type: "sqrt",
              names: ["\\sqrt"],
              props: {
                numArgs: 1,
                numOptionalArgs: 1
              },
              handler: function handler(_ref, args, optArgs) {
                var parser = _ref.parser;
                var index = optArgs[0];
                var body = args[0];
                return {
                  type: "sqrt",
                  mode: parser.mode,
                  body,
                  index
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var inner = buildHTML_buildGroup(group.body, options.havingCrampedStyle());
                if (inner.height === 0) {
                  inner.height = options.fontMetrics().xHeight;
                }
                inner = buildCommon.wrapFragment(inner, options);
                var metrics = options.fontMetrics();
                var theta = metrics.defaultRuleThickness;
                var phi = theta;
                if (options.style.id < src_Style.TEXT.id) {
                  phi = options.fontMetrics().xHeight;
                }
                var lineClearance = theta + phi / 4;
                var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta;
                var _delimiter$sqrtImage = delimiter.sqrtImage(minDelimiterHeight, options), img = _delimiter$sqrtImage.span, ruleWidth = _delimiter$sqrtImage.ruleWidth, advanceWidth = _delimiter$sqrtImage.advanceWidth;
                var delimDepth = img.height - ruleWidth;
                if (delimDepth > inner.height + inner.depth + lineClearance) {
                  lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;
                }
                var imgShift = img.height - inner.height - lineClearance - ruleWidth;
                inner.style.paddingLeft = advanceWidth + "em";
                var body = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: inner,
                    wrapperClasses: ["svg-align"]
                  }, {
                    type: "kern",
                    size: -(inner.height + imgShift)
                  }, {
                    type: "elem",
                    elem: img
                  }, {
                    type: "kern",
                    size: ruleWidth
                  }]
                }, options);
                if (!group.index) {
                  return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
                } else {
                  var newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
                  var rootm = buildHTML_buildGroup(group.index, newOptions, options);
                  var toShift = 0.6 * (body.height - body.depth);
                  var rootVList = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: -toShift,
                    children: [{
                      type: "elem",
                      elem: rootm
                    }]
                  }, options);
                  var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
                  return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
                }
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var body = group.body, index = group.index;
                return index ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
              }
            });
            var styling_styleMap = {
              "display": src_Style.DISPLAY,
              "text": src_Style.TEXT,
              "script": src_Style.SCRIPT,
              "scriptscript": src_Style.SCRIPTSCRIPT
            };
            defineFunction({
              type: "styling",
              names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser = _ref.parser;
                var body = parser.parseExpression(true, breakOnTokenText);
                var style = funcName.slice(1, funcName.length - 5);
                return {
                  type: "styling",
                  mode: parser.mode,
                  // Figure out what style to use by pulling out the style from
                  // the function name
                  style,
                  body
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var newStyle = styling_styleMap[group.style];
                var newOptions = options.havingStyle(newStyle).withFont("");
                return sizingGroup(group.body, newOptions, options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var styleMap = {
                  "display": src_Style.DISPLAY,
                  "text": src_Style.TEXT,
                  "script": src_Style.SCRIPT,
                  "scriptscript": src_Style.SCRIPTSCRIPT
                };
                var newStyle = styleMap[group.style];
                var newOptions = options.havingStyle(newStyle);
                var inner = buildMathML_buildExpression(group.body, newOptions);
                var node = new mathMLTree.MathNode("mstyle", inner);
                var styleAttributes = {
                  "display": ["0", "true"],
                  "text": ["0", "false"],
                  "script": ["1", "false"],
                  "scriptscript": ["2", "false"]
                };
                var attr = styleAttributes[group.style];
                node.setAttribute("scriptlevel", attr[0]);
                node.setAttribute("displaystyle", attr[1]);
                return node;
              }
            });
            var supsub_htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {
              var base = group.base;
              if (!base) {
                return null;
              } else if (base.type === "op") {
                var delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);
                return delegate ? op_htmlBuilder : null;
              } else if (base.type === "accent") {
                return utils.isCharacterBox(base.base) ? accent_htmlBuilder : null;
              } else if (base.type === "horizBrace") {
                var isSup = !group.sub;
                return isSup === base.isOver ? horizBrace_htmlBuilder : null;
              } else {
                return null;
              }
            };
            defineFunctionBuilders({
              type: "supsub",
              htmlBuilder: function htmlBuilder(group, options) {
                var builderDelegate = supsub_htmlBuilderDelegate(group, options);
                if (builderDelegate) {
                  return builderDelegate(group, options);
                }
                var valueBase = group.base, valueSup = group.sup, valueSub = group.sub;
                var base = buildHTML_buildGroup(valueBase, options);
                var supm;
                var subm;
                var metrics = options.fontMetrics();
                var supShift = 0;
                var subShift = 0;
                var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);
                if (valueSup) {
                  var newOptions = options.havingStyle(options.style.sup());
                  supm = buildHTML_buildGroup(valueSup, newOptions, options);
                  if (!isCharacterBox) {
                    supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                  }
                }
                if (valueSub) {
                  var _newOptions = options.havingStyle(options.style.sub());
                  subm = buildHTML_buildGroup(valueSub, _newOptions, options);
                  if (!isCharacterBox) {
                    subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
                  }
                }
                var minSupShift;
                if (options.style === src_Style.DISPLAY) {
                  minSupShift = metrics.sup1;
                } else if (options.style.cramped) {
                  minSupShift = metrics.sup3;
                } else {
                  minSupShift = metrics.sup2;
                }
                var multiplier = options.sizeMultiplier;
                var marginRight = 0.5 / metrics.ptPerEm / multiplier + "em";
                var marginLeft = null;
                if (subm) {
                  var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
                  if (base instanceof domTree_SymbolNode || isOiint) {
                    marginLeft = -base.italic + "em";
                  }
                }
                var supsub;
                if (supm && subm) {
                  supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                  subShift = Math.max(subShift, metrics.sub2);
                  var ruleWidth = metrics.defaultRuleThickness;
                  var maxWidth = 4 * ruleWidth;
                  if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                    subShift = maxWidth - (supShift - supm.depth) + subm.height;
                    var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                    if (psi > 0) {
                      supShift += psi;
                      subShift -= psi;
                    }
                  }
                  var vlistElem = [{
                    type: "elem",
                    elem: subm,
                    shift: subShift,
                    marginRight,
                    marginLeft
                  }, {
                    type: "elem",
                    elem: supm,
                    shift: -supShift,
                    marginRight
                  }];
                  supsub = buildCommon.makeVList({
                    positionType: "individualShift",
                    children: vlistElem
                  }, options);
                } else if (subm) {
                  subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
                  var _vlistElem = [{
                    type: "elem",
                    elem: subm,
                    marginLeft,
                    marginRight
                  }];
                  supsub = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: subShift,
                    children: _vlistElem
                  }, options);
                } else if (supm) {
                  supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                  supsub = buildCommon.makeVList({
                    positionType: "shift",
                    positionData: -supShift,
                    children: [{
                      type: "elem",
                      elem: supm,
                      marginRight
                    }]
                  }, options);
                } else {
                  throw new Error("supsub must have either sup or sub.");
                }
                var mclass = getTypeOfDomTree(base, "right") || "mord";
                return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var isBrace = false;
                var isOver;
                var isSup;
                var horizBrace = checkNodeType(group.base, "horizBrace");
                if (horizBrace) {
                  isSup = !!group.sup;
                  if (isSup === horizBrace.isOver) {
                    isBrace = true;
                    isOver = horizBrace.isOver;
                  }
                }
                if (group.base && group.base.type === "op") {
                  group.base.parentIsSupSub = true;
                }
                var children = [buildMathML_buildGroup(group.base, options)];
                if (group.sub) {
                  children.push(buildMathML_buildGroup(group.sub, options));
                }
                if (group.sup) {
                  children.push(buildMathML_buildGroup(group.sup, options));
                }
                var nodeType;
                if (isBrace) {
                  nodeType = isOver ? "mover" : "munder";
                } else if (!group.sub) {
                  var base = group.base;
                  if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
                    nodeType = "mover";
                  } else {
                    nodeType = "msup";
                  }
                } else if (!group.sup) {
                  var _base = group.base;
                  if (_base && _base.type === "op" && _base.limits && (options.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {
                    nodeType = "munder";
                  } else {
                    nodeType = "msub";
                  }
                } else {
                  var _base2 = group.base;
                  if (_base2 && _base2.type === "op" && _base2.limits && options.style === src_Style.DISPLAY) {
                    nodeType = "munderover";
                  } else {
                    nodeType = "msubsup";
                  }
                }
                var node = new mathMLTree.MathNode(nodeType, children);
                return node;
              }
            });
            defineFunctionBuilders({
              type: "atom",
              htmlBuilder: function htmlBuilder(group, options) {
                return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mo", [buildMathML_makeText(group.text, group.mode)]);
                if (group.family === "bin") {
                  var variant = buildMathML_getVariant(group, options);
                  if (variant === "bold-italic") {
                    node.setAttribute("mathvariant", variant);
                  }
                } else if (group.family === "punct") {
                  node.setAttribute("separator", "true");
                } else if (group.family === "open" || group.family === "close") {
                  node.setAttribute("stretchy", "false");
                }
                return node;
              }
            });
            var defaultVariant = {
              "mi": "italic",
              "mn": "normal",
              "mtext": "normal"
            };
            defineFunctionBuilders({
              type: "mathord",
              htmlBuilder: function htmlBuilder(group, options) {
                return buildCommon.makeOrd(group, options, "mathord");
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node = new mathMLTree.MathNode("mi", [buildMathML_makeText(group.text, group.mode, options)]);
                var variant = buildMathML_getVariant(group, options) || "italic";
                if (variant !== defaultVariant[node.type]) {
                  node.setAttribute("mathvariant", variant);
                }
                return node;
              }
            });
            defineFunctionBuilders({
              type: "textord",
              htmlBuilder: function htmlBuilder(group, options) {
                return buildCommon.makeOrd(group, options, "textord");
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var text = buildMathML_makeText(group.text, group.mode, options);
                var variant = buildMathML_getVariant(group, options) || "normal";
                var node;
                if (group.mode === "text") {
                  node = new mathMLTree.MathNode("mtext", [text]);
                } else if (/[0-9]/.test(group.text)) {
                  node = new mathMLTree.MathNode("mn", [text]);
                } else if (group.text === "\\prime") {
                  node = new mathMLTree.MathNode("mo", [text]);
                } else {
                  node = new mathMLTree.MathNode("mi", [text]);
                }
                if (variant !== defaultVariant[node.type]) {
                  node.setAttribute("mathvariant", variant);
                }
                return node;
              }
            });
            var cssSpace = {
              "\\nobreak": "nobreak",
              "\\allowbreak": "allowbreak"
            };
            var regularSpace = {
              " ": {},
              "\\ ": {},
              "~": {
                className: "nobreak"
              },
              "\\space": {},
              "\\nobreakspace": {
                className: "nobreak"
              }
            };
            defineFunctionBuilders({
              type: "spacing",
              htmlBuilder: function htmlBuilder(group, options) {
                if (regularSpace.hasOwnProperty(group.text)) {
                  var className = regularSpace[group.text].className || "";
                  if (group.mode === "text") {
                    var ord = buildCommon.makeOrd(group, options, "textord");
                    ord.classes.push(className);
                    return ord;
                  } else {
                    return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
                  }
                } else if (cssSpace.hasOwnProperty(group.text)) {
                  return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
                } else {
                  throw new src_ParseError('Unknown type of space "' + group.text + '"');
                }
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var node;
                if (regularSpace.hasOwnProperty(group.text)) {
                  node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
                } else if (cssSpace.hasOwnProperty(group.text)) {
                  return new mathMLTree.MathNode("mspace");
                } else {
                  throw new src_ParseError('Unknown type of space "' + group.text + '"');
                }
                return node;
              }
            });
            var tag_pad = function pad2() {
              var padNode = new mathMLTree.MathNode("mtd", []);
              padNode.setAttribute("width", "50%");
              return padNode;
            };
            defineFunctionBuilders({
              type: "tag",
              mathmlBuilder: function mathmlBuilder(group, options) {
                var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [tag_pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), tag_pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
                table.setAttribute("width", "100%");
                return table;
              }
            });
            var textFontFamilies = {
              "\\text": void 0,
              "\\textrm": "textrm",
              "\\textsf": "textsf",
              "\\texttt": "texttt",
              "\\textnormal": "textrm"
            };
            var textFontWeights = {
              "\\textbf": "textbf",
              "\\textmd": "textmd"
            };
            var textFontShapes = {
              "\\textit": "textit",
              "\\textup": "textup"
            };
            var optionsWithFont = function optionsWithFont2(group, options) {
              var font = group.font;
              if (!font) {
                return options;
              } else if (textFontFamilies[font]) {
                return options.withTextFontFamily(textFontFamilies[font]);
              } else if (textFontWeights[font]) {
                return options.withTextFontWeight(textFontWeights[font]);
              } else {
                return options.withTextFontShape(textFontShapes[font]);
              }
            };
            defineFunction({
              type: "text",
              names: [
                // Font families
                "\\text",
                "\\textrm",
                "\\textsf",
                "\\texttt",
                "\\textnormal",
                // Font weights
                "\\textbf",
                "\\textmd",
                // Font Shapes
                "\\textit",
                "\\textup"
              ],
              props: {
                numArgs: 1,
                argTypes: ["text"],
                greediness: 2,
                allowedInText: true,
                consumeMode: "text"
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser, funcName = _ref.funcName;
                var body = args[0];
                return {
                  type: "text",
                  mode: parser.mode,
                  body: defineFunction_ordargument(body),
                  font: funcName
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var newOptions = optionsWithFont(group, options);
                var inner = buildHTML_buildExpression(group.body, newOptions, true);
                return buildCommon.makeSpan(["mord", "text"], buildCommon.tryCombineChars(inner), newOptions);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var newOptions = optionsWithFont(group, options);
                return buildExpressionRow(group.body, newOptions);
              }
            });
            defineFunction({
              type: "underline",
              names: ["\\underline"],
              props: {
                numArgs: 1,
                allowedInText: true
              },
              handler: function handler(_ref, args) {
                var parser = _ref.parser;
                return {
                  type: "underline",
                  mode: parser.mode,
                  body: args[0]
                };
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var innerGroup = buildHTML_buildGroup(group.body, options);
                var line = buildCommon.makeLineSpan("underline-line", options);
                var vlist = buildCommon.makeVList({
                  positionType: "top",
                  positionData: innerGroup.height,
                  children: [{
                    type: "kern",
                    size: line.height
                  }, {
                    type: "elem",
                    elem: line
                  }, {
                    type: "kern",
                    size: 3 * line.height
                  }, {
                    type: "elem",
                    elem: innerGroup
                  }]
                }, options);
                return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
                operator.setAttribute("stretchy", "true");
                var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
                node.setAttribute("accentunder", "true");
                return node;
              }
            });
            defineFunction({
              type: "verb",
              names: ["\\verb"],
              props: {
                numArgs: 0,
                allowedInText: true
              },
              handler: function handler(context, args, optArgs) {
                throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
              },
              htmlBuilder: function htmlBuilder(group, options) {
                var text = makeVerb(group);
                var body = [];
                var newOptions = options.havingStyle(options.style.text());
                for (var i = 0; i < text.length; i++) {
                  var c = text[i];
                  if (c === "~") {
                    c = "\\textasciitilde";
                  }
                  body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
                }
                return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
              },
              mathmlBuilder: function mathmlBuilder(group, options) {
                var text = new mathMLTree.TextNode(makeVerb(group));
                var node = new mathMLTree.MathNode("mtext", [text]);
                node.setAttribute("mathvariant", "monospace");
                return node;
              }
            });
            var makeVerb = function makeVerb2(group) {
              return group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
            };
            var functions = _functions;
            var src_functions = functions;
            var spaceRegexString = "[ \r\n	]";
            var controlWordRegexString = "\\\\[a-zA-Z@]+";
            var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
            var controlWordWhitespaceRegexString = "" + controlWordRegexString + spaceRegexString + "*";
            var controlWordWhitespaceRegex = new RegExp("^(" + controlWordRegexString + ")" + spaceRegexString + "*$");
            var combiningDiacriticalMarkString = "[\u0300-\u036F]";
            var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
            var tokenRegexString = "(" + spaceRegexString + "+)|([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
            (combiningDiacriticalMarkString + "*") + // ...plus accents
            "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
            (combiningDiacriticalMarkString + "*") + // ...plus accents
            "|\\\\verb\\*([^]).*?\\3|\\\\verb([^*a-zA-Z]).*?\\4" + // \verb unstarred
            ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
            ("|" + controlSymbolRegexString + ")");
            var Lexer_Lexer = /* @__PURE__ */ function() {
              function Lexer(input, settings) {
                this.input = void 0;
                this.settings = void 0;
                this.tokenRegex = void 0;
                this.catcodes = void 0;
                this.input = input;
                this.settings = settings;
                this.tokenRegex = new RegExp(tokenRegexString, "g");
                this.catcodes = {
                  "%": 14
                  // comment character
                };
              }
              var _proto = Lexer.prototype;
              _proto.setCatcode = function setCatcode(char, code) {
                this.catcodes[char] = code;
              };
              _proto.lex = function lex() {
                var input = this.input;
                var pos = this.tokenRegex.lastIndex;
                if (pos === input.length) {
                  return new Token_Token("EOF", new SourceLocation(this, pos, pos));
                }
                var match = this.tokenRegex.exec(input);
                if (match === null || match.index !== pos) {
                  throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token_Token(input[pos], new SourceLocation(this, pos, pos + 1)));
                }
                var text = match[2] || " ";
                if (this.catcodes[text] === 14) {
                  var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
                  if (nlIndex === -1) {
                    this.tokenRegex.lastIndex = input.length;
                    this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
                  } else {
                    this.tokenRegex.lastIndex = nlIndex + 1;
                  }
                  return this.lex();
                }
                var controlMatch = text.match(controlWordWhitespaceRegex);
                if (controlMatch) {
                  text = controlMatch[1];
                }
                return new Token_Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
              };
              return Lexer;
            }();
            var Namespace_Namespace = /* @__PURE__ */ function() {
              function Namespace(builtins, globalMacros) {
                if (builtins === void 0) {
                  builtins = {};
                }
                if (globalMacros === void 0) {
                  globalMacros = {};
                }
                this.current = void 0;
                this.builtins = void 0;
                this.undefStack = void 0;
                this.current = globalMacros;
                this.builtins = builtins;
                this.undefStack = [];
              }
              var _proto = Namespace.prototype;
              _proto.beginGroup = function beginGroup() {
                this.undefStack.push({});
              };
              _proto.endGroup = function endGroup() {
                if (this.undefStack.length === 0) {
                  throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
                }
                var undefs = this.undefStack.pop();
                for (var undef in undefs) {
                  if (undefs.hasOwnProperty(undef)) {
                    if (undefs[undef] === void 0) {
                      delete this.current[undef];
                    } else {
                      this.current[undef] = undefs[undef];
                    }
                  }
                }
              };
              _proto.has = function has(name2) {
                return this.current.hasOwnProperty(name2) || this.builtins.hasOwnProperty(name2);
              };
              _proto.get = function get3(name2) {
                if (this.current.hasOwnProperty(name2)) {
                  return this.current[name2];
                } else {
                  return this.builtins[name2];
                }
              };
              _proto.set = function set3(name2, value, global) {
                if (global === void 0) {
                  global = false;
                }
                if (global) {
                  for (var i = 0; i < this.undefStack.length; i++) {
                    delete this.undefStack[i][name2];
                  }
                  if (this.undefStack.length > 0) {
                    this.undefStack[this.undefStack.length - 1][name2] = value;
                  }
                } else {
                  var top = this.undefStack[this.undefStack.length - 1];
                  if (top && !top.hasOwnProperty(name2)) {
                    top[name2] = this.current[name2];
                  }
                }
                this.current[name2] = value;
              };
              return Namespace;
            }();
            var builtinMacros = {};
            var macros = builtinMacros;
            function defineMacro(name2, body) {
              builtinMacros[name2] = body;
            }
            defineMacro("\\@firstoftwo", function(context) {
              var args = context.consumeArgs(2);
              return {
                tokens: args[0],
                numArgs: 0
              };
            });
            defineMacro("\\@secondoftwo", function(context) {
              var args = context.consumeArgs(2);
              return {
                tokens: args[1],
                numArgs: 0
              };
            });
            defineMacro("\\@ifnextchar", function(context) {
              var args = context.consumeArgs(3);
              var nextToken = context.future();
              if (args[0].length === 1 && args[0][0].text === nextToken.text) {
                return {
                  tokens: args[1],
                  numArgs: 0
                };
              } else {
                return {
                  tokens: args[2],
                  numArgs: 0
                };
              }
            });
            defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
            defineMacro("\\TextOrMath", function(context) {
              var args = context.consumeArgs(2);
              if (context.mode === "text") {
                return {
                  tokens: args[0],
                  numArgs: 0
                };
              } else {
                return {
                  tokens: args[1],
                  numArgs: 0
                };
              }
            });
            var digitToNumber = {
              "0": 0,
              "1": 1,
              "2": 2,
              "3": 3,
              "4": 4,
              "5": 5,
              "6": 6,
              "7": 7,
              "8": 8,
              "9": 9,
              "a": 10,
              "A": 10,
              "b": 11,
              "B": 11,
              "c": 12,
              "C": 12,
              "d": 13,
              "D": 13,
              "e": 14,
              "E": 14,
              "f": 15,
              "F": 15
            };
            defineMacro("\\char", function(context) {
              var token = context.popToken();
              var base;
              var number3 = "";
              if (token.text === "'") {
                base = 8;
                token = context.popToken();
              } else if (token.text === '"') {
                base = 16;
                token = context.popToken();
              } else if (token.text === "`") {
                token = context.popToken();
                if (token.text[0] === "\\") {
                  number3 = token.text.charCodeAt(1);
                } else if (token.text === "EOF") {
                  throw new src_ParseError("\\char` missing argument");
                } else {
                  number3 = token.text.charCodeAt(0);
                }
              } else {
                base = 10;
              }
              if (base) {
                number3 = digitToNumber[token.text];
                if (number3 == null || number3 >= base) {
                  throw new src_ParseError("Invalid base-" + base + " digit " + token.text);
                }
                var digit;
                while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
                  number3 *= base;
                  number3 += digit;
                  context.popToken();
                }
              }
              return "\\@char{" + number3 + "}";
            });
            var macros_def = function def(context, global) {
              var arg = context.consumeArgs(1)[0];
              if (arg.length !== 1) {
                throw new src_ParseError("\\gdef's first argument must be a macro name");
              }
              var name2 = arg[0].text;
              var numArgs = 0;
              arg = context.consumeArgs(1)[0];
              while (arg.length === 1 && arg[0].text === "#") {
                arg = context.consumeArgs(1)[0];
                if (arg.length !== 1) {
                  throw new src_ParseError('Invalid argument number length "' + arg.length + '"');
                }
                if (!/^[1-9]$/.test(arg[0].text)) {
                  throw new src_ParseError('Invalid argument number "' + arg[0].text + '"');
                }
                numArgs++;
                if (parseInt(arg[0].text) !== numArgs) {
                  throw new src_ParseError('Argument number "' + arg[0].text + '" out of order');
                }
                arg = context.consumeArgs(1)[0];
              }
              context.macros.set(name2, {
                tokens: arg,
                numArgs
              }, global);
              return "";
            };
            defineMacro("\\gdef", function(context) {
              return macros_def(context, true);
            });
            defineMacro("\\def", function(context) {
              return macros_def(context, false);
            });
            defineMacro("\\global", function(context) {
              var next = context.consumeArgs(1)[0];
              if (next.length !== 1) {
                throw new src_ParseError("Invalid command after \\global");
              }
              var command = next[0].text;
              if (command === "\\def") {
                return macros_def(context, true);
              } else {
                throw new src_ParseError("Invalid command '" + command + "' after \\global");
              }
            });
            var macros_newcommand = function newcommand(context, existsOK, nonexistsOK) {
              var arg = context.consumeArgs(1)[0];
              if (arg.length !== 1) {
                throw new src_ParseError("\\newcommand's first argument must be a macro name");
              }
              var name2 = arg[0].text;
              var exists = context.isDefined(name2);
              if (exists && !existsOK) {
                throw new src_ParseError("\\newcommand{" + name2 + "} attempting to redefine " + (name2 + "; use \\renewcommand"));
              }
              if (!exists && !nonexistsOK) {
                throw new src_ParseError("\\renewcommand{" + name2 + "} when command " + name2 + " does not yet exist; use \\newcommand");
              }
              var numArgs = 0;
              arg = context.consumeArgs(1)[0];
              if (arg.length === 1 && arg[0].text === "[") {
                var argText = "";
                var token = context.expandNextToken();
                while (token.text !== "]" && token.text !== "EOF") {
                  argText += token.text;
                  token = context.expandNextToken();
                }
                if (!argText.match(/^\s*[0-9]+\s*$/)) {
                  throw new src_ParseError("Invalid number of arguments: " + argText);
                }
                numArgs = parseInt(argText);
                arg = context.consumeArgs(1)[0];
              }
              context.macros.set(name2, {
                tokens: arg,
                numArgs
              });
              return "";
            };
            defineMacro("\\newcommand", function(context) {
              return macros_newcommand(context, false, true);
            });
            defineMacro("\\renewcommand", function(context) {
              return macros_newcommand(context, true, false);
            });
            defineMacro("\\providecommand", function(context) {
              return macros_newcommand(context, true, true);
            });
            defineMacro("\\bgroup", "{");
            defineMacro("\\egroup", "}");
            defineMacro("\\lq", "`");
            defineMacro("\\rq", "'");
            defineMacro("\\aa", "\\r a");
            defineMacro("\\AA", "\\r A");
            defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
            defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
            defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
            defineMacro("\u212C", "\\mathscr{B}");
            defineMacro("\u2130", "\\mathscr{E}");
            defineMacro("\u2131", "\\mathscr{F}");
            defineMacro("\u210B", "\\mathscr{H}");
            defineMacro("\u2110", "\\mathscr{I}");
            defineMacro("\u2112", "\\mathscr{L}");
            defineMacro("\u2133", "\\mathscr{M}");
            defineMacro("\u211B", "\\mathscr{R}");
            defineMacro("\u212D", "\\mathfrak{C}");
            defineMacro("\u210C", "\\mathfrak{H}");
            defineMacro("\u2128", "\\mathfrak{Z}");
            defineMacro("\\Bbbk", "\\Bbb{k}");
            defineMacro("\xB7", "\\cdotp");
            defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
            defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
            defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
            defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
            defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
            defineMacro("\\ne", "\\neq");
            defineMacro("\u2260", "\\neq");
            defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
            defineMacro("\u2209", "\\notin");
            defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
            defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
            defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
            defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
            defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
            defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
            defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
            defineMacro("\u27C2", "\\perp");
            defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
            defineMacro("\u220C", "\\notni");
            defineMacro("\u231C", "\\ulcorner");
            defineMacro("\u231D", "\\urcorner");
            defineMacro("\u231E", "\\llcorner");
            defineMacro("\u231F", "\\lrcorner");
            defineMacro("\xA9", "\\copyright");
            defineMacro("\xAE", "\\textregistered");
            defineMacro("\uFE0F", "\\textregistered");
            defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
            defineMacro("\u22EE", "\\vdots");
            defineMacro("\\varGamma", "\\mathit{\\Gamma}");
            defineMacro("\\varDelta", "\\mathit{\\Delta}");
            defineMacro("\\varTheta", "\\mathit{\\Theta}");
            defineMacro("\\varLambda", "\\mathit{\\Lambda}");
            defineMacro("\\varXi", "\\mathit{\\Xi}");
            defineMacro("\\varPi", "\\mathit{\\Pi}");
            defineMacro("\\varSigma", "\\mathit{\\Sigma}");
            defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
            defineMacro("\\varPhi", "\\mathit{\\Phi}");
            defineMacro("\\varPsi", "\\mathit{\\Psi}");
            defineMacro("\\varOmega", "\\mathit{\\Omega}");
            defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");
            defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
            defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
            defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
            defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
            var dotsByToken = {
              ",": "\\dotsc",
              "\\not": "\\dotsb",
              // \keybin@ checks for the following:
              "+": "\\dotsb",
              "=": "\\dotsb",
              "<": "\\dotsb",
              ">": "\\dotsb",
              "-": "\\dotsb",
              "*": "\\dotsb",
              ":": "\\dotsb",
              // Symbols whose definition starts with \DOTSB:
              "\\DOTSB": "\\dotsb",
              "\\coprod": "\\dotsb",
              "\\bigvee": "\\dotsb",
              "\\bigwedge": "\\dotsb",
              "\\biguplus": "\\dotsb",
              "\\bigcap": "\\dotsb",
              "\\bigcup": "\\dotsb",
              "\\prod": "\\dotsb",
              "\\sum": "\\dotsb",
              "\\bigotimes": "\\dotsb",
              "\\bigoplus": "\\dotsb",
              "\\bigodot": "\\dotsb",
              "\\bigsqcup": "\\dotsb",
              "\\And": "\\dotsb",
              "\\longrightarrow": "\\dotsb",
              "\\Longrightarrow": "\\dotsb",
              "\\longleftarrow": "\\dotsb",
              "\\Longleftarrow": "\\dotsb",
              "\\longleftrightarrow": "\\dotsb",
              "\\Longleftrightarrow": "\\dotsb",
              "\\mapsto": "\\dotsb",
              "\\longmapsto": "\\dotsb",
              "\\hookrightarrow": "\\dotsb",
              "\\doteq": "\\dotsb",
              // Symbols whose definition starts with \mathbin:
              "\\mathbin": "\\dotsb",
              // Symbols whose definition starts with \mathrel:
              "\\mathrel": "\\dotsb",
              "\\relbar": "\\dotsb",
              "\\Relbar": "\\dotsb",
              "\\xrightarrow": "\\dotsb",
              "\\xleftarrow": "\\dotsb",
              // Symbols whose definition starts with \DOTSI:
              "\\DOTSI": "\\dotsi",
              "\\int": "\\dotsi",
              "\\oint": "\\dotsi",
              "\\iint": "\\dotsi",
              "\\iiint": "\\dotsi",
              "\\iiiint": "\\dotsi",
              "\\idotsint": "\\dotsi",
              // Symbols whose definition starts with \DOTSX:
              "\\DOTSX": "\\dotsx"
            };
            defineMacro("\\dots", function(context) {
              var thedots = "\\dotso";
              var next = context.expandAfterFuture().text;
              if (next in dotsByToken) {
                thedots = dotsByToken[next];
              } else if (next.substr(0, 4) === "\\not") {
                thedots = "\\dotsb";
              } else if (next in src_symbols.math) {
                if (utils.contains(["bin", "rel"], src_symbols.math[next].group)) {
                  thedots = "\\dotsb";
                }
              }
              return thedots;
            });
            var spaceAfterDots = {
              // \rightdelim@ checks for the following:
              ")": true,
              "]": true,
              "\\rbrack": true,
              "\\}": true,
              "\\rbrace": true,
              "\\rangle": true,
              "\\rceil": true,
              "\\rfloor": true,
              "\\rgroup": true,
              "\\rmoustache": true,
              "\\right": true,
              "\\bigr": true,
              "\\biggr": true,
              "\\Bigr": true,
              "\\Biggr": true,
              // \extra@ also tests for the following:
              "$": true,
              // \extrap@ checks for the following:
              ";": true,
              ".": true,
              ",": true
            };
            defineMacro("\\dotso", function(context) {
              var next = context.future().text;
              if (next in spaceAfterDots) {
                return "\\ldots\\,";
              } else {
                return "\\ldots";
              }
            });
            defineMacro("\\dotsc", function(context) {
              var next = context.future().text;
              if (next in spaceAfterDots && next !== ",") {
                return "\\ldots\\,";
              } else {
                return "\\ldots";
              }
            });
            defineMacro("\\cdots", function(context) {
              var next = context.future().text;
              if (next in spaceAfterDots) {
                return "\\@cdots\\,";
              } else {
                return "\\@cdots";
              }
            });
            defineMacro("\\dotsb", "\\cdots");
            defineMacro("\\dotsm", "\\cdots");
            defineMacro("\\dotsi", "\\!\\cdots");
            defineMacro("\\dotsx", "\\ldots\\,");
            defineMacro("\\DOTSI", "\\relax");
            defineMacro("\\DOTSB", "\\relax");
            defineMacro("\\DOTSX", "\\relax");
            defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
            defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
            defineMacro("\\thinspace", "\\,");
            defineMacro("\\>", "\\mskip{4mu}");
            defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
            defineMacro("\\medspace", "\\:");
            defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
            defineMacro("\\thickspace", "\\;");
            defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
            defineMacro("\\negthinspace", "\\!");
            defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
            defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
            defineMacro("\\enspace", "\\kern.5em ");
            defineMacro("\\enskip", "\\hskip.5em\\relax");
            defineMacro("\\quad", "\\hskip1em\\relax");
            defineMacro("\\qquad", "\\hskip2em\\relax");
            defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
            defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
            defineMacro("\\tag@literal", function(context) {
              if (context.macros.get("\\df@tag")) {
                throw new src_ParseError("Multiple \\tag");
              }
              return "\\gdef\\df@tag{\\text{#1}}";
            });
            defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
            defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
            defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
            defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
            defineMacro("\\pmb", "\\html@mathml{\\@binrel{#1}{\\mathrlap{#1}\\mathrlap{\\mkern0.4mu\\raisebox{0.4mu}{$#1$}}{\\mkern0.8mu#1}}}{\\mathbf{#1}}");
            defineMacro("\\\\", "\\newline");
            defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
            var latexRaiseA = fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1] + "em";
            defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptsize A}") + "\\kern-.15em\\TeX}{LaTeX}}");
            defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptsize A}") + "\\kern-.15em\\TeX}{KaTeX}}");
            defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
            defineMacro("\\@hspace", "\\hskip #1\\relax");
            defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
            defineMacro("\\ordinarycolon", ":");
            defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
            defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
            defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
            defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
            defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
            defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
            defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
            defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
            defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
            defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
            defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
            defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
            defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
            defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
            defineMacro("\u2237", "\\dblcolon");
            defineMacro("\u2239", "\\eqcolon");
            defineMacro("\u2254", "\\coloneqq");
            defineMacro("\u2255", "\\eqqcolon");
            defineMacro("\u2A74", "\\Coloneqq");
            defineMacro("\\ratio", "\\vcentcolon");
            defineMacro("\\coloncolon", "\\dblcolon");
            defineMacro("\\colonequals", "\\coloneqq");
            defineMacro("\\coloncolonequals", "\\Coloneqq");
            defineMacro("\\equalscolon", "\\eqqcolon");
            defineMacro("\\equalscoloncolon", "\\Eqqcolon");
            defineMacro("\\colonminus", "\\coloneq");
            defineMacro("\\coloncolonminus", "\\Coloneq");
            defineMacro("\\minuscolon", "\\eqcolon");
            defineMacro("\\minuscoloncolon", "\\Eqcolon");
            defineMacro("\\coloncolonapprox", "\\Colonapprox");
            defineMacro("\\coloncolonsim", "\\Colonsim");
            defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
            defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
            defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
            defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
            defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
            defineMacro("\\limsup", "\\DOTSB\\mathop{\\operatorname{lim\\,sup}}\\limits");
            defineMacro("\\liminf", "\\DOTSB\\mathop{\\operatorname{lim\\,inf}}\\limits");
            defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
            defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
            defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
            defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
            defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
            defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
            defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
            defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
            defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
            defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
            defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
            defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
            defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
            defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
            defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
            defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
            defineMacro("\u27E6", "\\llbracket");
            defineMacro("\u27E7", "\\rrbracket");
            defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
            defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
            defineMacro("\u2983", "\\lBrace");
            defineMacro("\u2984", "\\rBrace");
            defineMacro("\\darr", "\\downarrow");
            defineMacro("\\dArr", "\\Downarrow");
            defineMacro("\\Darr", "\\Downarrow");
            defineMacro("\\lang", "\\langle");
            defineMacro("\\rang", "\\rangle");
            defineMacro("\\uarr", "\\uparrow");
            defineMacro("\\uArr", "\\Uparrow");
            defineMacro("\\Uarr", "\\Uparrow");
            defineMacro("\\N", "\\mathbb{N}");
            defineMacro("\\R", "\\mathbb{R}");
            defineMacro("\\Z", "\\mathbb{Z}");
            defineMacro("\\alef", "\\aleph");
            defineMacro("\\alefsym", "\\aleph");
            defineMacro("\\Alpha", "\\mathrm{A}");
            defineMacro("\\Beta", "\\mathrm{B}");
            defineMacro("\\bull", "\\bullet");
            defineMacro("\\Chi", "\\mathrm{X}");
            defineMacro("\\clubs", "\\clubsuit");
            defineMacro("\\cnums", "\\mathbb{C}");
            defineMacro("\\Complex", "\\mathbb{C}");
            defineMacro("\\Dagger", "\\ddagger");
            defineMacro("\\diamonds", "\\diamondsuit");
            defineMacro("\\empty", "\\emptyset");
            defineMacro("\\Epsilon", "\\mathrm{E}");
            defineMacro("\\Eta", "\\mathrm{H}");
            defineMacro("\\exist", "\\exists");
            defineMacro("\\harr", "\\leftrightarrow");
            defineMacro("\\hArr", "\\Leftrightarrow");
            defineMacro("\\Harr", "\\Leftrightarrow");
            defineMacro("\\hearts", "\\heartsuit");
            defineMacro("\\image", "\\Im");
            defineMacro("\\infin", "\\infty");
            defineMacro("\\Iota", "\\mathrm{I}");
            defineMacro("\\isin", "\\in");
            defineMacro("\\Kappa", "\\mathrm{K}");
            defineMacro("\\larr", "\\leftarrow");
            defineMacro("\\lArr", "\\Leftarrow");
            defineMacro("\\Larr", "\\Leftarrow");
            defineMacro("\\lrarr", "\\leftrightarrow");
            defineMacro("\\lrArr", "\\Leftrightarrow");
            defineMacro("\\Lrarr", "\\Leftrightarrow");
            defineMacro("\\Mu", "\\mathrm{M}");
            defineMacro("\\natnums", "\\mathbb{N}");
            defineMacro("\\Nu", "\\mathrm{N}");
            defineMacro("\\Omicron", "\\mathrm{O}");
            defineMacro("\\plusmn", "\\pm");
            defineMacro("\\rarr", "\\rightarrow");
            defineMacro("\\rArr", "\\Rightarrow");
            defineMacro("\\Rarr", "\\Rightarrow");
            defineMacro("\\real", "\\Re");
            defineMacro("\\reals", "\\mathbb{R}");
            defineMacro("\\Reals", "\\mathbb{R}");
            defineMacro("\\Rho", "\\mathrm{P}");
            defineMacro("\\sdot", "\\cdot");
            defineMacro("\\sect", "\\S");
            defineMacro("\\spades", "\\spadesuit");
            defineMacro("\\sub", "\\subset");
            defineMacro("\\sube", "\\subseteq");
            defineMacro("\\supe", "\\supseteq");
            defineMacro("\\Tau", "\\mathrm{T}");
            defineMacro("\\thetasym", "\\vartheta");
            defineMacro("\\weierp", "\\wp");
            defineMacro("\\Zeta", "\\mathrm{Z}");
            defineMacro("\\argmin", "\\DOTSB\\mathop{\\operatorname{arg\\,min}}\\limits");
            defineMacro("\\argmax", "\\DOTSB\\mathop{\\operatorname{arg\\,max}}\\limits");
            defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
            defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
            defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
            defineMacro("\\red", "\\textcolor{##df0030}{#1}");
            defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
            defineMacro("\\gray", "\\textcolor{gray}{##1}");
            defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
            defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
            defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
            defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
            defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
            defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
            defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
            defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
            defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
            defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
            defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
            defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
            defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
            defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
            defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
            defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
            defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
            defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
            defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
            defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
            defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
            defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
            defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
            defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
            defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
            defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
            defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
            defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
            defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
            defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
            defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
            defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
            defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
            defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
            defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
            defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
            defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
            defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
            defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
            defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
            defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
            defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
            defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
            defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
            defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
            defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
            defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
            defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
            defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
            defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
            var implicitCommands = {
              "\\relax": true,
              // MacroExpander.js
              "^": true,
              // Parser.js
              "_": true,
              // Parser.js
              "\\limits": true,
              // Parser.js
              "\\nolimits": true
              // Parser.js
            };
            var MacroExpander_MacroExpander = /* @__PURE__ */ function() {
              function MacroExpander(input, settings, mode) {
                this.settings = void 0;
                this.expansionCount = void 0;
                this.lexer = void 0;
                this.macros = void 0;
                this.stack = void 0;
                this.mode = void 0;
                this.settings = settings;
                this.expansionCount = 0;
                this.feed(input);
                this.macros = new Namespace_Namespace(macros, settings.macros);
                this.mode = mode;
                this.stack = [];
              }
              var _proto = MacroExpander.prototype;
              _proto.feed = function feed(input) {
                this.lexer = new Lexer_Lexer(input, this.settings);
              };
              _proto.switchMode = function switchMode(newMode) {
                this.mode = newMode;
              };
              _proto.beginGroup = function beginGroup() {
                this.macros.beginGroup();
              };
              _proto.endGroup = function endGroup() {
                this.macros.endGroup();
              };
              _proto.future = function future() {
                if (this.stack.length === 0) {
                  this.pushToken(this.lexer.lex());
                }
                return this.stack[this.stack.length - 1];
              };
              _proto.popToken = function popToken() {
                this.future();
                return this.stack.pop();
              };
              _proto.pushToken = function pushToken(token) {
                this.stack.push(token);
              };
              _proto.pushTokens = function pushTokens(tokens) {
                var _this$stack;
                (_this$stack = this.stack).push.apply(_this$stack, tokens);
              };
              _proto.consumeSpaces = function consumeSpaces() {
                for (; ; ) {
                  var token = this.future();
                  if (token.text === " ") {
                    this.stack.pop();
                  } else {
                    break;
                  }
                }
              };
              _proto.consumeArgs = function consumeArgs(numArgs) {
                var args = [];
                for (var i = 0; i < numArgs; ++i) {
                  this.consumeSpaces();
                  var startOfArg = this.popToken();
                  if (startOfArg.text === "{") {
                    var arg = [];
                    var depth = 1;
                    while (depth !== 0) {
                      var tok = this.popToken();
                      arg.push(tok);
                      if (tok.text === "{") {
                        ++depth;
                      } else if (tok.text === "}") {
                        --depth;
                      } else if (tok.text === "EOF") {
                        throw new src_ParseError("End of input in macro argument", startOfArg);
                      }
                    }
                    arg.pop();
                    arg.reverse();
                    args[i] = arg;
                  } else if (startOfArg.text === "EOF") {
                    throw new src_ParseError("End of input expecting macro argument");
                  } else {
                    args[i] = [startOfArg];
                  }
                }
                return args;
              };
              _proto.expandOnce = function expandOnce() {
                var topToken = this.popToken();
                var name2 = topToken.text;
                var expansion = this._getExpansion(name2);
                if (expansion == null) {
                  this.pushToken(topToken);
                  return topToken;
                }
                this.expansionCount++;
                if (this.expansionCount > this.settings.maxExpand) {
                  throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
                }
                var tokens = expansion.tokens;
                if (expansion.numArgs) {
                  var args = this.consumeArgs(expansion.numArgs);
                  tokens = tokens.slice();
                  for (var i = tokens.length - 1; i >= 0; --i) {
                    var tok = tokens[i];
                    if (tok.text === "#") {
                      if (i === 0) {
                        throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                      }
                      tok = tokens[--i];
                      if (tok.text === "#") {
                        tokens.splice(i + 1, 1);
                      } else if (/^[1-9]$/.test(tok.text)) {
                        var _tokens;
                        (_tokens = tokens).splice.apply(_tokens, [i, 2].concat(args[+tok.text - 1]));
                      } else {
                        throw new src_ParseError("Not a valid argument number", tok);
                      }
                    }
                  }
                }
                this.pushTokens(tokens);
                return tokens;
              };
              _proto.expandAfterFuture = function expandAfterFuture() {
                this.expandOnce();
                return this.future();
              };
              _proto.expandNextToken = function expandNextToken() {
                for (; ; ) {
                  var expanded = this.expandOnce();
                  if (expanded instanceof Token_Token) {
                    if (expanded.text === "\\relax") {
                      this.stack.pop();
                    } else {
                      return this.stack.pop();
                    }
                  }
                }
                throw new Error();
              };
              _proto.expandMacro = function expandMacro(name2) {
                if (!this.macros.get(name2)) {
                  return void 0;
                }
                var output = [];
                var oldStackLength = this.stack.length;
                this.pushToken(new Token_Token(name2));
                while (this.stack.length > oldStackLength) {
                  var expanded = this.expandOnce();
                  if (expanded instanceof Token_Token) {
                    output.push(this.stack.pop());
                  }
                }
                return output;
              };
              _proto.expandMacroAsText = function expandMacroAsText(name2) {
                var tokens = this.expandMacro(name2);
                if (tokens) {
                  return tokens.map(function(token) {
                    return token.text;
                  }).join("");
                } else {
                  return tokens;
                }
              };
              _proto._getExpansion = function _getExpansion(name2) {
                var definition = this.macros.get(name2);
                if (definition == null) {
                  return definition;
                }
                var expansion = typeof definition === "function" ? definition(this) : definition;
                if (typeof expansion === "string") {
                  var numArgs = 0;
                  if (expansion.indexOf("#") !== -1) {
                    var stripped = expansion.replace(/##/g, "");
                    while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                      ++numArgs;
                    }
                  }
                  var bodyLexer = new Lexer_Lexer(expansion, this.settings);
                  var tokens = [];
                  var tok = bodyLexer.lex();
                  while (tok.text !== "EOF") {
                    tokens.push(tok);
                    tok = bodyLexer.lex();
                  }
                  tokens.reverse();
                  var expanded = {
                    tokens,
                    numArgs
                  };
                  return expanded;
                }
                return expansion;
              };
              _proto.isDefined = function isDefined(name2) {
                return this.macros.has(name2) || src_functions.hasOwnProperty(name2) || src_symbols.math.hasOwnProperty(name2) || src_symbols.text.hasOwnProperty(name2) || implicitCommands.hasOwnProperty(name2);
              };
              return MacroExpander;
            }();
            var unicodeAccents = {
              "\u0301": {
                text: "\\'",
                math: "\\acute"
              },
              "\u0300": {
                text: "\\`",
                math: "\\grave"
              },
              "\u0308": {
                text: '\\"',
                math: "\\ddot"
              },
              "\u0303": {
                text: "\\~",
                math: "\\tilde"
              },
              "\u0304": {
                text: "\\=",
                math: "\\bar"
              },
              "\u0306": {
                text: "\\u",
                math: "\\breve"
              },
              "\u030C": {
                text: "\\v",
                math: "\\check"
              },
              "\u0302": {
                text: "\\^",
                math: "\\hat"
              },
              "\u0307": {
                text: "\\.",
                math: "\\dot"
              },
              "\u030A": {
                text: "\\r",
                math: "\\mathring"
              },
              "\u030B": {
                text: "\\H"
              }
            };
            var unicodeSymbols = {
              "\xE1": "a\u0301",
              // á = \'{a}
              "\xE0": "a\u0300",
              // à = \`{a}
              "\xE4": "a\u0308",
              // ä = \"{a}
              "\u01DF": "a\u0308\u0304",
              // ǟ = \"\={a}
              "\xE3": "a\u0303",
              // ã = \~{a}
              "\u0101": "a\u0304",
              // ā = \={a}
              "\u0103": "a\u0306",
              // ă = \u{a}
              "\u1EAF": "a\u0306\u0301",
              // ắ = \u\'{a}
              "\u1EB1": "a\u0306\u0300",
              // ằ = \u\`{a}
              "\u1EB5": "a\u0306\u0303",
              // ẵ = \u\~{a}
              "\u01CE": "a\u030C",
              // ǎ = \v{a}
              "\xE2": "a\u0302",
              // â = \^{a}
              "\u1EA5": "a\u0302\u0301",
              // ấ = \^\'{a}
              "\u1EA7": "a\u0302\u0300",
              // ầ = \^\`{a}
              "\u1EAB": "a\u0302\u0303",
              // ẫ = \^\~{a}
              "\u0227": "a\u0307",
              // ȧ = \.{a}
              "\u01E1": "a\u0307\u0304",
              // ǡ = \.\={a}
              "\xE5": "a\u030A",
              // å = \r{a}
              "\u01FB": "a\u030A\u0301",
              // ǻ = \r\'{a}
              "\u1E03": "b\u0307",
              // ḃ = \.{b}
              "\u0107": "c\u0301",
              // ć = \'{c}
              "\u010D": "c\u030C",
              // č = \v{c}
              "\u0109": "c\u0302",
              // ĉ = \^{c}
              "\u010B": "c\u0307",
              // ċ = \.{c}
              "\u010F": "d\u030C",
              // ď = \v{d}
              "\u1E0B": "d\u0307",
              // ḋ = \.{d}
              "\xE9": "e\u0301",
              // é = \'{e}
              "\xE8": "e\u0300",
              // è = \`{e}
              "\xEB": "e\u0308",
              // ë = \"{e}
              "\u1EBD": "e\u0303",
              // ẽ = \~{e}
              "\u0113": "e\u0304",
              // ē = \={e}
              "\u1E17": "e\u0304\u0301",
              // ḗ = \=\'{e}
              "\u1E15": "e\u0304\u0300",
              // ḕ = \=\`{e}
              "\u0115": "e\u0306",
              // ĕ = \u{e}
              "\u011B": "e\u030C",
              // ě = \v{e}
              "\xEA": "e\u0302",
              // ê = \^{e}
              "\u1EBF": "e\u0302\u0301",
              // ế = \^\'{e}
              "\u1EC1": "e\u0302\u0300",
              // ề = \^\`{e}
              "\u1EC5": "e\u0302\u0303",
              // ễ = \^\~{e}
              "\u0117": "e\u0307",
              // ė = \.{e}
              "\u1E1F": "f\u0307",
              // ḟ = \.{f}
              "\u01F5": "g\u0301",
              // ǵ = \'{g}
              "\u1E21": "g\u0304",
              // ḡ = \={g}
              "\u011F": "g\u0306",
              // ğ = \u{g}
              "\u01E7": "g\u030C",
              // ǧ = \v{g}
              "\u011D": "g\u0302",
              // ĝ = \^{g}
              "\u0121": "g\u0307",
              // ġ = \.{g}
              "\u1E27": "h\u0308",
              // ḧ = \"{h}
              "\u021F": "h\u030C",
              // ȟ = \v{h}
              "\u0125": "h\u0302",
              // ĥ = \^{h}
              "\u1E23": "h\u0307",
              // ḣ = \.{h}
              "\xED": "i\u0301",
              // í = \'{i}
              "\xEC": "i\u0300",
              // ì = \`{i}
              "\xEF": "i\u0308",
              // ï = \"{i}
              "\u1E2F": "i\u0308\u0301",
              // ḯ = \"\'{i}
              "\u0129": "i\u0303",
              // ĩ = \~{i}
              "\u012B": "i\u0304",
              // ī = \={i}
              "\u012D": "i\u0306",
              // ĭ = \u{i}
              "\u01D0": "i\u030C",
              // ǐ = \v{i}
              "\xEE": "i\u0302",
              // î = \^{i}
              "\u01F0": "j\u030C",
              // ǰ = \v{j}
              "\u0135": "j\u0302",
              // ĵ = \^{j}
              "\u1E31": "k\u0301",
              // ḱ = \'{k}
              "\u01E9": "k\u030C",
              // ǩ = \v{k}
              "\u013A": "l\u0301",
              // ĺ = \'{l}
              "\u013E": "l\u030C",
              // ľ = \v{l}
              "\u1E3F": "m\u0301",
              // ḿ = \'{m}
              "\u1E41": "m\u0307",
              // ṁ = \.{m}
              "\u0144": "n\u0301",
              // ń = \'{n}
              "\u01F9": "n\u0300",
              // ǹ = \`{n}
              "\xF1": "n\u0303",
              // ñ = \~{n}
              "\u0148": "n\u030C",
              // ň = \v{n}
              "\u1E45": "n\u0307",
              // ṅ = \.{n}
              "\xF3": "o\u0301",
              // ó = \'{o}
              "\xF2": "o\u0300",
              // ò = \`{o}
              "\xF6": "o\u0308",
              // ö = \"{o}
              "\u022B": "o\u0308\u0304",
              // ȫ = \"\={o}
              "\xF5": "o\u0303",
              // õ = \~{o}
              "\u1E4D": "o\u0303\u0301",
              // ṍ = \~\'{o}
              "\u1E4F": "o\u0303\u0308",
              // ṏ = \~\"{o}
              "\u022D": "o\u0303\u0304",
              // ȭ = \~\={o}
              "\u014D": "o\u0304",
              // ō = \={o}
              "\u1E53": "o\u0304\u0301",
              // ṓ = \=\'{o}
              "\u1E51": "o\u0304\u0300",
              // ṑ = \=\`{o}
              "\u014F": "o\u0306",
              // ŏ = \u{o}
              "\u01D2": "o\u030C",
              // ǒ = \v{o}
              "\xF4": "o\u0302",
              // ô = \^{o}
              "\u1ED1": "o\u0302\u0301",
              // ố = \^\'{o}
              "\u1ED3": "o\u0302\u0300",
              // ồ = \^\`{o}
              "\u1ED7": "o\u0302\u0303",
              // ỗ = \^\~{o}
              "\u022F": "o\u0307",
              // ȯ = \.{o}
              "\u0231": "o\u0307\u0304",
              // ȱ = \.\={o}
              "\u0151": "o\u030B",
              // ő = \H{o}
              "\u1E55": "p\u0301",
              // ṕ = \'{p}
              "\u1E57": "p\u0307",
              // ṗ = \.{p}
              "\u0155": "r\u0301",
              // ŕ = \'{r}
              "\u0159": "r\u030C",
              // ř = \v{r}
              "\u1E59": "r\u0307",
              // ṙ = \.{r}
              "\u015B": "s\u0301",
              // ś = \'{s}
              "\u1E65": "s\u0301\u0307",
              // ṥ = \'\.{s}
              "\u0161": "s\u030C",
              // š = \v{s}
              "\u1E67": "s\u030C\u0307",
              // ṧ = \v\.{s}
              "\u015D": "s\u0302",
              // ŝ = \^{s}
              "\u1E61": "s\u0307",
              // ṡ = \.{s}
              "\u1E97": "t\u0308",
              // ẗ = \"{t}
              "\u0165": "t\u030C",
              // ť = \v{t}
              "\u1E6B": "t\u0307",
              // ṫ = \.{t}
              "\xFA": "u\u0301",
              // ú = \'{u}
              "\xF9": "u\u0300",
              // ù = \`{u}
              "\xFC": "u\u0308",
              // ü = \"{u}
              "\u01D8": "u\u0308\u0301",
              // ǘ = \"\'{u}
              "\u01DC": "u\u0308\u0300",
              // ǜ = \"\`{u}
              "\u01D6": "u\u0308\u0304",
              // ǖ = \"\={u}
              "\u01DA": "u\u0308\u030C",
              // ǚ = \"\v{u}
              "\u0169": "u\u0303",
              // ũ = \~{u}
              "\u1E79": "u\u0303\u0301",
              // ṹ = \~\'{u}
              "\u016B": "u\u0304",
              // ū = \={u}
              "\u1E7B": "u\u0304\u0308",
              // ṻ = \=\"{u}
              "\u016D": "u\u0306",
              // ŭ = \u{u}
              "\u01D4": "u\u030C",
              // ǔ = \v{u}
              "\xFB": "u\u0302",
              // û = \^{u}
              "\u016F": "u\u030A",
              // ů = \r{u}
              "\u0171": "u\u030B",
              // ű = \H{u}
              "\u1E7D": "v\u0303",
              // ṽ = \~{v}
              "\u1E83": "w\u0301",
              // ẃ = \'{w}
              "\u1E81": "w\u0300",
              // ẁ = \`{w}
              "\u1E85": "w\u0308",
              // ẅ = \"{w}
              "\u0175": "w\u0302",
              // ŵ = \^{w}
              "\u1E87": "w\u0307",
              // ẇ = \.{w}
              "\u1E98": "w\u030A",
              // ẘ = \r{w}
              "\u1E8D": "x\u0308",
              // ẍ = \"{x}
              "\u1E8B": "x\u0307",
              // ẋ = \.{x}
              "\xFD": "y\u0301",
              // ý = \'{y}
              "\u1EF3": "y\u0300",
              // ỳ = \`{y}
              "\xFF": "y\u0308",
              // ÿ = \"{y}
              "\u1EF9": "y\u0303",
              // ỹ = \~{y}
              "\u0233": "y\u0304",
              // ȳ = \={y}
              "\u0177": "y\u0302",
              // ŷ = \^{y}
              "\u1E8F": "y\u0307",
              // ẏ = \.{y}
              "\u1E99": "y\u030A",
              // ẙ = \r{y}
              "\u017A": "z\u0301",
              // ź = \'{z}
              "\u017E": "z\u030C",
              // ž = \v{z}
              "\u1E91": "z\u0302",
              // ẑ = \^{z}
              "\u017C": "z\u0307",
              // ż = \.{z}
              "\xC1": "A\u0301",
              // Á = \'{A}
              "\xC0": "A\u0300",
              // À = \`{A}
              "\xC4": "A\u0308",
              // Ä = \"{A}
              "\u01DE": "A\u0308\u0304",
              // Ǟ = \"\={A}
              "\xC3": "A\u0303",
              // Ã = \~{A}
              "\u0100": "A\u0304",
              // Ā = \={A}
              "\u0102": "A\u0306",
              // Ă = \u{A}
              "\u1EAE": "A\u0306\u0301",
              // Ắ = \u\'{A}
              "\u1EB0": "A\u0306\u0300",
              // Ằ = \u\`{A}
              "\u1EB4": "A\u0306\u0303",
              // Ẵ = \u\~{A}
              "\u01CD": "A\u030C",
              // Ǎ = \v{A}
              "\xC2": "A\u0302",
              // Â = \^{A}
              "\u1EA4": "A\u0302\u0301",
              // Ấ = \^\'{A}
              "\u1EA6": "A\u0302\u0300",
              // Ầ = \^\`{A}
              "\u1EAA": "A\u0302\u0303",
              // Ẫ = \^\~{A}
              "\u0226": "A\u0307",
              // Ȧ = \.{A}
              "\u01E0": "A\u0307\u0304",
              // Ǡ = \.\={A}
              "\xC5": "A\u030A",
              // Å = \r{A}
              "\u01FA": "A\u030A\u0301",
              // Ǻ = \r\'{A}
              "\u1E02": "B\u0307",
              // Ḃ = \.{B}
              "\u0106": "C\u0301",
              // Ć = \'{C}
              "\u010C": "C\u030C",
              // Č = \v{C}
              "\u0108": "C\u0302",
              // Ĉ = \^{C}
              "\u010A": "C\u0307",
              // Ċ = \.{C}
              "\u010E": "D\u030C",
              // Ď = \v{D}
              "\u1E0A": "D\u0307",
              // Ḋ = \.{D}
              "\xC9": "E\u0301",
              // É = \'{E}
              "\xC8": "E\u0300",
              // È = \`{E}
              "\xCB": "E\u0308",
              // Ë = \"{E}
              "\u1EBC": "E\u0303",
              // Ẽ = \~{E}
              "\u0112": "E\u0304",
              // Ē = \={E}
              "\u1E16": "E\u0304\u0301",
              // Ḗ = \=\'{E}
              "\u1E14": "E\u0304\u0300",
              // Ḕ = \=\`{E}
              "\u0114": "E\u0306",
              // Ĕ = \u{E}
              "\u011A": "E\u030C",
              // Ě = \v{E}
              "\xCA": "E\u0302",
              // Ê = \^{E}
              "\u1EBE": "E\u0302\u0301",
              // Ế = \^\'{E}
              "\u1EC0": "E\u0302\u0300",
              // Ề = \^\`{E}
              "\u1EC4": "E\u0302\u0303",
              // Ễ = \^\~{E}
              "\u0116": "E\u0307",
              // Ė = \.{E}
              "\u1E1E": "F\u0307",
              // Ḟ = \.{F}
              "\u01F4": "G\u0301",
              // Ǵ = \'{G}
              "\u1E20": "G\u0304",
              // Ḡ = \={G}
              "\u011E": "G\u0306",
              // Ğ = \u{G}
              "\u01E6": "G\u030C",
              // Ǧ = \v{G}
              "\u011C": "G\u0302",
              // Ĝ = \^{G}
              "\u0120": "G\u0307",
              // Ġ = \.{G}
              "\u1E26": "H\u0308",
              // Ḧ = \"{H}
              "\u021E": "H\u030C",
              // Ȟ = \v{H}
              "\u0124": "H\u0302",
              // Ĥ = \^{H}
              "\u1E22": "H\u0307",
              // Ḣ = \.{H}
              "\xCD": "I\u0301",
              // Í = \'{I}
              "\xCC": "I\u0300",
              // Ì = \`{I}
              "\xCF": "I\u0308",
              // Ï = \"{I}
              "\u1E2E": "I\u0308\u0301",
              // Ḯ = \"\'{I}
              "\u0128": "I\u0303",
              // Ĩ = \~{I}
              "\u012A": "I\u0304",
              // Ī = \={I}
              "\u012C": "I\u0306",
              // Ĭ = \u{I}
              "\u01CF": "I\u030C",
              // Ǐ = \v{I}
              "\xCE": "I\u0302",
              // Î = \^{I}
              "\u0130": "I\u0307",
              // İ = \.{I}
              "\u0134": "J\u0302",
              // Ĵ = \^{J}
              "\u1E30": "K\u0301",
              // Ḱ = \'{K}
              "\u01E8": "K\u030C",
              // Ǩ = \v{K}
              "\u0139": "L\u0301",
              // Ĺ = \'{L}
              "\u013D": "L\u030C",
              // Ľ = \v{L}
              "\u1E3E": "M\u0301",
              // Ḿ = \'{M}
              "\u1E40": "M\u0307",
              // Ṁ = \.{M}
              "\u0143": "N\u0301",
              // Ń = \'{N}
              "\u01F8": "N\u0300",
              // Ǹ = \`{N}
              "\xD1": "N\u0303",
              // Ñ = \~{N}
              "\u0147": "N\u030C",
              // Ň = \v{N}
              "\u1E44": "N\u0307",
              // Ṅ = \.{N}
              "\xD3": "O\u0301",
              // Ó = \'{O}
              "\xD2": "O\u0300",
              // Ò = \`{O}
              "\xD6": "O\u0308",
              // Ö = \"{O}
              "\u022A": "O\u0308\u0304",
              // Ȫ = \"\={O}
              "\xD5": "O\u0303",
              // Õ = \~{O}
              "\u1E4C": "O\u0303\u0301",
              // Ṍ = \~\'{O}
              "\u1E4E": "O\u0303\u0308",
              // Ṏ = \~\"{O}
              "\u022C": "O\u0303\u0304",
              // Ȭ = \~\={O}
              "\u014C": "O\u0304",
              // Ō = \={O}
              "\u1E52": "O\u0304\u0301",
              // Ṓ = \=\'{O}
              "\u1E50": "O\u0304\u0300",
              // Ṑ = \=\`{O}
              "\u014E": "O\u0306",
              // Ŏ = \u{O}
              "\u01D1": "O\u030C",
              // Ǒ = \v{O}
              "\xD4": "O\u0302",
              // Ô = \^{O}
              "\u1ED0": "O\u0302\u0301",
              // Ố = \^\'{O}
              "\u1ED2": "O\u0302\u0300",
              // Ồ = \^\`{O}
              "\u1ED6": "O\u0302\u0303",
              // Ỗ = \^\~{O}
              "\u022E": "O\u0307",
              // Ȯ = \.{O}
              "\u0230": "O\u0307\u0304",
              // Ȱ = \.\={O}
              "\u0150": "O\u030B",
              // Ő = \H{O}
              "\u1E54": "P\u0301",
              // Ṕ = \'{P}
              "\u1E56": "P\u0307",
              // Ṗ = \.{P}
              "\u0154": "R\u0301",
              // Ŕ = \'{R}
              "\u0158": "R\u030C",
              // Ř = \v{R}
              "\u1E58": "R\u0307",
              // Ṙ = \.{R}
              "\u015A": "S\u0301",
              // Ś = \'{S}
              "\u1E64": "S\u0301\u0307",
              // Ṥ = \'\.{S}
              "\u0160": "S\u030C",
              // Š = \v{S}
              "\u1E66": "S\u030C\u0307",
              // Ṧ = \v\.{S}
              "\u015C": "S\u0302",
              // Ŝ = \^{S}
              "\u1E60": "S\u0307",
              // Ṡ = \.{S}
              "\u0164": "T\u030C",
              // Ť = \v{T}
              "\u1E6A": "T\u0307",
              // Ṫ = \.{T}
              "\xDA": "U\u0301",
              // Ú = \'{U}
              "\xD9": "U\u0300",
              // Ù = \`{U}
              "\xDC": "U\u0308",
              // Ü = \"{U}
              "\u01D7": "U\u0308\u0301",
              // Ǘ = \"\'{U}
              "\u01DB": "U\u0308\u0300",
              // Ǜ = \"\`{U}
              "\u01D5": "U\u0308\u0304",
              // Ǖ = \"\={U}
              "\u01D9": "U\u0308\u030C",
              // Ǚ = \"\v{U}
              "\u0168": "U\u0303",
              // Ũ = \~{U}
              "\u1E78": "U\u0303\u0301",
              // Ṹ = \~\'{U}
              "\u016A": "U\u0304",
              // Ū = \={U}
              "\u1E7A": "U\u0304\u0308",
              // Ṻ = \=\"{U}
              "\u016C": "U\u0306",
              // Ŭ = \u{U}
              "\u01D3": "U\u030C",
              // Ǔ = \v{U}
              "\xDB": "U\u0302",
              // Û = \^{U}
              "\u016E": "U\u030A",
              // Ů = \r{U}
              "\u0170": "U\u030B",
              // Ű = \H{U}
              "\u1E7C": "V\u0303",
              // Ṽ = \~{V}
              "\u1E82": "W\u0301",
              // Ẃ = \'{W}
              "\u1E80": "W\u0300",
              // Ẁ = \`{W}
              "\u1E84": "W\u0308",
              // Ẅ = \"{W}
              "\u0174": "W\u0302",
              // Ŵ = \^{W}
              "\u1E86": "W\u0307",
              // Ẇ = \.{W}
              "\u1E8C": "X\u0308",
              // Ẍ = \"{X}
              "\u1E8A": "X\u0307",
              // Ẋ = \.{X}
              "\xDD": "Y\u0301",
              // Ý = \'{Y}
              "\u1EF2": "Y\u0300",
              // Ỳ = \`{Y}
              "\u0178": "Y\u0308",
              // Ÿ = \"{Y}
              "\u1EF8": "Y\u0303",
              // Ỹ = \~{Y}
              "\u0232": "Y\u0304",
              // Ȳ = \={Y}
              "\u0176": "Y\u0302",
              // Ŷ = \^{Y}
              "\u1E8E": "Y\u0307",
              // Ẏ = \.{Y}
              "\u0179": "Z\u0301",
              // Ź = \'{Z}
              "\u017D": "Z\u030C",
              // Ž = \v{Z}
              "\u1E90": "Z\u0302",
              // Ẑ = \^{Z}
              "\u017B": "Z\u0307",
              // Ż = \.{Z}
              "\u03AC": "\u03B1\u0301",
              // ά = \'{α}
              "\u1F70": "\u03B1\u0300",
              // ὰ = \`{α}
              "\u1FB1": "\u03B1\u0304",
              // ᾱ = \={α}
              "\u1FB0": "\u03B1\u0306",
              // ᾰ = \u{α}
              "\u03AD": "\u03B5\u0301",
              // έ = \'{ε}
              "\u1F72": "\u03B5\u0300",
              // ὲ = \`{ε}
              "\u03AE": "\u03B7\u0301",
              // ή = \'{η}
              "\u1F74": "\u03B7\u0300",
              // ὴ = \`{η}
              "\u03AF": "\u03B9\u0301",
              // ί = \'{ι}
              "\u1F76": "\u03B9\u0300",
              // ὶ = \`{ι}
              "\u03CA": "\u03B9\u0308",
              // ϊ = \"{ι}
              "\u0390": "\u03B9\u0308\u0301",
              // ΐ = \"\'{ι}
              "\u1FD2": "\u03B9\u0308\u0300",
              // ῒ = \"\`{ι}
              "\u1FD1": "\u03B9\u0304",
              // ῑ = \={ι}
              "\u1FD0": "\u03B9\u0306",
              // ῐ = \u{ι}
              "\u03CC": "\u03BF\u0301",
              // ό = \'{ο}
              "\u1F78": "\u03BF\u0300",
              // ὸ = \`{ο}
              "\u03CD": "\u03C5\u0301",
              // ύ = \'{υ}
              "\u1F7A": "\u03C5\u0300",
              // ὺ = \`{υ}
              "\u03CB": "\u03C5\u0308",
              // ϋ = \"{υ}
              "\u03B0": "\u03C5\u0308\u0301",
              // ΰ = \"\'{υ}
              "\u1FE2": "\u03C5\u0308\u0300",
              // ῢ = \"\`{υ}
              "\u1FE1": "\u03C5\u0304",
              // ῡ = \={υ}
              "\u1FE0": "\u03C5\u0306",
              // ῠ = \u{υ}
              "\u03CE": "\u03C9\u0301",
              // ώ = \'{ω}
              "\u1F7C": "\u03C9\u0300",
              // ὼ = \`{ω}
              "\u038E": "\u03A5\u0301",
              // Ύ = \'{Υ}
              "\u1FEA": "\u03A5\u0300",
              // Ὺ = \`{Υ}
              "\u03AB": "\u03A5\u0308",
              // Ϋ = \"{Υ}
              "\u1FE9": "\u03A5\u0304",
              // Ῡ = \={Υ}
              "\u1FE8": "\u03A5\u0306",
              // Ῠ = \u{Υ}
              "\u038F": "\u03A9\u0301",
              // Ώ = \'{Ω}
              "\u1FFA": "\u03A9\u0300"
              // Ὼ = \`{Ω}
            };
            var Parser_Parser = /* @__PURE__ */ function() {
              function Parser(input, settings) {
                this.mode = void 0;
                this.gullet = void 0;
                this.settings = void 0;
                this.leftrightDepth = void 0;
                this.nextToken = void 0;
                this.mode = "math";
                this.gullet = new MacroExpander_MacroExpander(input, settings, this.mode);
                this.settings = settings;
                this.leftrightDepth = 0;
              }
              var _proto = Parser.prototype;
              _proto.expect = function expect(text, consume) {
                if (consume === void 0) {
                  consume = true;
                }
                if (this.nextToken.text !== text) {
                  throw new src_ParseError("Expected '" + text + "', got '" + this.nextToken.text + "'", this.nextToken);
                }
                if (consume) {
                  this.consume();
                }
              };
              _proto.consume = function consume() {
                this.nextToken = this.gullet.expandNextToken();
              };
              _proto.switchMode = function switchMode(newMode) {
                this.mode = newMode;
                this.gullet.switchMode(newMode);
              };
              _proto.parse = function parse() {
                this.gullet.beginGroup();
                if (this.settings.colorIsTextColor) {
                  this.gullet.macros.set("\\color", "\\textcolor");
                }
                this.consume();
                var parse2 = this.parseExpression(false);
                this.expect("EOF", false);
                this.gullet.endGroup();
                return parse2;
              };
              _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {
                var body = [];
                while (true) {
                  if (this.mode === "math") {
                    this.consumeSpaces();
                  }
                  var lex = this.nextToken;
                  if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
                    break;
                  }
                  if (breakOnTokenText && lex.text === breakOnTokenText) {
                    break;
                  }
                  if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                    break;
                  }
                  var atom = this.parseAtom(breakOnTokenText);
                  if (!atom) {
                    break;
                  }
                  body.push(atom);
                }
                if (this.mode === "text") {
                  this.formLigatures(body);
                }
                return this.handleInfixNodes(body);
              };
              _proto.handleInfixNodes = function handleInfixNodes(body) {
                var overIndex = -1;
                var funcName;
                for (var i = 0; i < body.length; i++) {
                  var node = checkNodeType(body[i], "infix");
                  if (node) {
                    if (overIndex !== -1) {
                      throw new src_ParseError("only one infix operator per group", node.token);
                    }
                    overIndex = i;
                    funcName = node.replaceWith;
                  }
                }
                if (overIndex !== -1 && funcName) {
                  var numerNode;
                  var denomNode;
                  var numerBody = body.slice(0, overIndex);
                  var denomBody = body.slice(overIndex + 1);
                  if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                    numerNode = numerBody[0];
                  } else {
                    numerNode = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: numerBody
                    };
                  }
                  if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                    denomNode = denomBody[0];
                  } else {
                    denomNode = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: denomBody
                    };
                  }
                  var _node;
                  if (funcName === "\\\\abovefrac") {
                    _node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
                  } else {
                    _node = this.callFunction(funcName, [numerNode, denomNode], []);
                  }
                  return [_node];
                } else {
                  return body;
                }
              };
              _proto.handleSupSubscript = function handleSupSubscript(name2) {
                var symbolToken = this.nextToken;
                var symbol = symbolToken.text;
                this.consume();
                this.consumeSpaces();
                var group = this.parseGroup(name2, false, Parser.SUPSUB_GREEDINESS);
                if (!group) {
                  throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
                }
                return group;
              };
              _proto.handleUnsupportedCmd = function handleUnsupportedCmd() {
                var text = this.nextToken.text;
                var textordArray = [];
                for (var i = 0; i < text.length; i++) {
                  textordArray.push({
                    type: "textord",
                    mode: "text",
                    text: text[i]
                  });
                }
                var textNode = {
                  type: "text",
                  mode: this.mode,
                  body: textordArray
                };
                var colorNode = {
                  type: "color",
                  mode: this.mode,
                  color: this.settings.errorColor,
                  body: [textNode]
                };
                this.consume();
                return colorNode;
              };
              _proto.parseAtom = function parseAtom(breakOnTokenText) {
                var base = this.parseGroup("atom", false, null, breakOnTokenText);
                if (this.mode === "text") {
                  return base;
                }
                var superscript;
                var subscript;
                while (true) {
                  this.consumeSpaces();
                  var lex = this.nextToken;
                  if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                    var opNode = checkNodeType(base, "op");
                    if (opNode) {
                      var limits = lex.text === "\\limits";
                      opNode.limits = limits;
                      opNode.alwaysHandleSupSub = true;
                    } else {
                      throw new src_ParseError("Limit controls must follow a math operator", lex);
                    }
                    this.consume();
                  } else if (lex.text === "^") {
                    if (superscript) {
                      throw new src_ParseError("Double superscript", lex);
                    }
                    superscript = this.handleSupSubscript("superscript");
                  } else if (lex.text === "_") {
                    if (subscript) {
                      throw new src_ParseError("Double subscript", lex);
                    }
                    subscript = this.handleSupSubscript("subscript");
                  } else if (lex.text === "'") {
                    if (superscript) {
                      throw new src_ParseError("Double superscript", lex);
                    }
                    var prime = {
                      type: "textord",
                      mode: this.mode,
                      text: "\\prime"
                    };
                    var primes = [prime];
                    this.consume();
                    while (this.nextToken.text === "'") {
                      primes.push(prime);
                      this.consume();
                    }
                    if (this.nextToken.text === "^") {
                      primes.push(this.handleSupSubscript("superscript"));
                    }
                    superscript = {
                      type: "ordgroup",
                      mode: this.mode,
                      body: primes
                    };
                  } else {
                    break;
                  }
                }
                if (superscript || subscript) {
                  return {
                    type: "supsub",
                    mode: this.mode,
                    base,
                    sup: superscript,
                    sub: subscript
                  };
                } else {
                  return base;
                }
              };
              _proto.parseFunction = function parseFunction(breakOnTokenText, name2, greediness) {
                var token = this.nextToken;
                var func = token.text;
                var funcData = src_functions[func];
                if (!funcData) {
                  return null;
                }
                if (greediness != null && funcData.greediness <= greediness) {
                  throw new src_ParseError("Got function '" + func + "' with no arguments" + (name2 ? " as " + name2 : ""), token);
                } else if (this.mode === "text" && !funcData.allowedInText) {
                  throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
                } else if (this.mode === "math" && funcData.allowedInMath === false) {
                  throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
                }
                if (funcData.argTypes && funcData.argTypes[0] === "url") {
                  this.gullet.lexer.setCatcode("%", 13);
                }
                if (funcData.consumeMode) {
                  var oldMode = this.mode;
                  this.switchMode(funcData.consumeMode);
                  this.consume();
                  this.switchMode(oldMode);
                } else {
                  this.consume();
                }
                var _this$parseArguments = this.parseArguments(func, funcData), args = _this$parseArguments.args, optArgs = _this$parseArguments.optArgs;
                return this.callFunction(func, args, optArgs, token, breakOnTokenText);
              };
              _proto.callFunction = function callFunction(name2, args, optArgs, token, breakOnTokenText) {
                var context = {
                  funcName: name2,
                  parser: this,
                  token,
                  breakOnTokenText
                };
                var func = src_functions[name2];
                if (func && func.handler) {
                  return func.handler(context, args, optArgs);
                } else {
                  throw new src_ParseError("No function handler for " + name2);
                }
              };
              _proto.parseArguments = function parseArguments(func, funcData) {
                var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
                if (totalArgs === 0) {
                  return {
                    args: [],
                    optArgs: []
                  };
                }
                var baseGreediness = funcData.greediness;
                var args = [];
                var optArgs = [];
                for (var i = 0; i < totalArgs; i++) {
                  var argType = funcData.argTypes && funcData.argTypes[i];
                  var isOptional = i < funcData.numOptionalArgs;
                  if (i > 0 && !isOptional) {
                    this.consumeSpaces();
                  }
                  if (i === 0 && !isOptional && this.mode === "math") {
                    this.consumeSpaces();
                  }
                  var nextToken = this.nextToken;
                  var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional, baseGreediness);
                  if (!arg) {
                    if (isOptional) {
                      optArgs.push(null);
                      continue;
                    }
                    throw new src_ParseError("Expected group after '" + func + "'", nextToken);
                  }
                  (isOptional ? optArgs : args).push(arg);
                }
                return {
                  args,
                  optArgs
                };
              };
              _proto.parseGroupOfType = function parseGroupOfType(name2, type, optional, greediness) {
                switch (type) {
                  case "color":
                    return this.parseColorGroup(optional);
                  case "size":
                    return this.parseSizeGroup(optional);
                  case "url":
                    return this.parseUrlGroup(optional);
                  case "math":
                  case "text":
                    return this.parseGroup(name2, optional, greediness, void 0, type);
                  case "raw": {
                    if (optional && this.nextToken.text === "{") {
                      return null;
                    }
                    var token = this.parseStringGroup("raw", optional, true);
                    if (token) {
                      return {
                        type: "raw",
                        mode: "text",
                        string: token.text
                      };
                    } else {
                      throw new src_ParseError("Expected raw group", this.nextToken);
                    }
                  }
                  case "original":
                  case null:
                  case void 0:
                    return this.parseGroup(name2, optional, greediness);
                  default:
                    throw new src_ParseError("Unknown group type as " + name2, this.nextToken);
                }
              };
              _proto.consumeSpaces = function consumeSpaces() {
                while (this.nextToken.text === " ") {
                  this.consume();
                }
              };
              _proto.parseStringGroup = function parseStringGroup(modeName, optional, raw) {
                var groupBegin = optional ? "[" : "{";
                var groupEnd = optional ? "]" : "}";
                var nextToken = this.nextToken;
                if (nextToken.text !== groupBegin) {
                  if (optional) {
                    return null;
                  } else if (raw && nextToken.text !== "EOF" && /[^{}[\]]/.test(nextToken.text)) {
                    this.gullet.lexer.setCatcode("%", 14);
                    this.consume();
                    return nextToken;
                  }
                }
                var outerMode = this.mode;
                this.mode = "text";
                this.expect(groupBegin);
                var str = "";
                var firstToken = this.nextToken;
                var nested = 0;
                var lastToken = firstToken;
                while (raw && nested > 0 || this.nextToken.text !== groupEnd) {
                  switch (this.nextToken.text) {
                    case "EOF":
                      throw new src_ParseError("Unexpected end of input in " + modeName, firstToken.range(lastToken, str));
                    case groupBegin:
                      nested++;
                      break;
                    case groupEnd:
                      nested--;
                      break;
                  }
                  lastToken = this.nextToken;
                  str += lastToken.text;
                  this.consume();
                }
                this.mode = outerMode;
                this.gullet.lexer.setCatcode("%", 14);
                this.expect(groupEnd);
                return firstToken.range(lastToken, str);
              };
              _proto.parseRegexGroup = function parseRegexGroup(regex, modeName) {
                var outerMode = this.mode;
                this.mode = "text";
                var firstToken = this.nextToken;
                var lastToken = firstToken;
                var str = "";
                while (this.nextToken.text !== "EOF" && regex.test(str + this.nextToken.text)) {
                  lastToken = this.nextToken;
                  str += lastToken.text;
                  this.consume();
                }
                if (str === "") {
                  throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
                }
                this.mode = outerMode;
                return firstToken.range(lastToken, str);
              };
              _proto.parseColorGroup = function parseColorGroup(optional) {
                var res = this.parseStringGroup("color", optional);
                if (!res) {
                  return null;
                }
                var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
                if (!match) {
                  throw new src_ParseError("Invalid color: '" + res.text + "'", res);
                }
                var color3 = match[0];
                if (/^[0-9a-f]{6}$/i.test(color3)) {
                  color3 = "#" + color3;
                }
                return {
                  type: "color-token",
                  mode: this.mode,
                  color: color3
                };
              };
              _proto.parseSizeGroup = function parseSizeGroup(optional) {
                var res;
                var isBlank = false;
                if (!optional && this.nextToken.text !== "{") {
                  res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
                } else {
                  res = this.parseStringGroup("size", optional);
                }
                if (!res) {
                  return null;
                }
                if (!optional && res.text.length === 0) {
                  res.text = "0pt";
                  isBlank = true;
                }
                var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
                if (!match) {
                  throw new src_ParseError("Invalid size: '" + res.text + "'", res);
                }
                var data = {
                  number: +(match[1] + match[2]),
                  // sign + magnitude, cast to number
                  unit: match[3]
                };
                if (!validUnit(data)) {
                  throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
                }
                return {
                  type: "size",
                  mode: this.mode,
                  value: data,
                  isBlank
                };
              };
              _proto.parseUrlGroup = function parseUrlGroup(optional) {
                var res = this.parseStringGroup("url", optional, true);
                if (!res) {
                  return null;
                }
                var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
                var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
                protocol = protocol != null ? protocol[1] : "_relative";
                var allowed = this.settings.allowedProtocols;
                if (!utils.contains(allowed, "*") && !utils.contains(allowed, protocol)) {
                  throw new src_ParseError("Forbidden protocol '" + protocol + "'", res);
                }
                return {
                  type: "url",
                  mode: this.mode,
                  url
                };
              };
              _proto.parseGroup = function parseGroup(name2, optional, greediness, breakOnTokenText, mode) {
                var outerMode = this.mode;
                var firstToken = this.nextToken;
                var text = firstToken.text;
                if (mode) {
                  this.switchMode(mode);
                }
                var groupEnd;
                var result;
                if (optional ? text === "[" : text === "{" || text === "\\begingroup") {
                  groupEnd = Parser.endOfGroup[text];
                  this.gullet.beginGroup();
                  this.consume();
                  var expression = this.parseExpression(false, groupEnd);
                  var lastToken = this.nextToken;
                  this.gullet.endGroup();
                  result = {
                    type: "ordgroup",
                    mode: this.mode,
                    loc: SourceLocation.range(firstToken, lastToken),
                    body: expression,
                    // A group formed by \begingroup...\endgroup is a semi-simple group
                    // which doesn't affect spacing in math mode, i.e., is transparent.
                    // https://tex.stackexchange.com/questions/1930/when-should-one-
                    // use-begingroup-instead-of-bgroup
                    semisimple: text === "\\begingroup" || void 0
                  };
                } else if (optional) {
                  result = null;
                } else {
                  result = this.parseFunction(breakOnTokenText, name2, greediness) || this.parseSymbol();
                  if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
                    if (this.settings.throwOnError) {
                      throw new src_ParseError("Undefined control sequence: " + text, firstToken);
                    }
                    result = this.handleUnsupportedCmd();
                  }
                }
                if (mode) {
                  this.switchMode(outerMode);
                }
                if (groupEnd) {
                  this.expect(groupEnd);
                }
                return result;
              };
              _proto.formLigatures = function formLigatures(group) {
                var n = group.length - 1;
                for (var i = 0; i < n; ++i) {
                  var a = group[i];
                  var v = a.text;
                  if (v === "-" && group[i + 1].text === "-") {
                    if (i + 1 < n && group[i + 2].text === "-") {
                      group.splice(i, 3, {
                        type: "textord",
                        mode: "text",
                        loc: SourceLocation.range(a, group[i + 2]),
                        text: "---"
                      });
                      n -= 2;
                    } else {
                      group.splice(i, 2, {
                        type: "textord",
                        mode: "text",
                        loc: SourceLocation.range(a, group[i + 1]),
                        text: "--"
                      });
                      n -= 1;
                    }
                  }
                  if ((v === "'" || v === "`") && group[i + 1].text === v) {
                    group.splice(i, 2, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation.range(a, group[i + 1]),
                      text: v + v
                    });
                    n -= 1;
                  }
                }
              };
              _proto.parseSymbol = function parseSymbol() {
                var nucleus = this.nextToken;
                var text = nucleus.text;
                if (/^\\verb[^a-zA-Z]/.test(text)) {
                  this.consume();
                  var arg = text.slice(5);
                  var star = arg.charAt(0) === "*";
                  if (star) {
                    arg = arg.slice(1);
                  }
                  if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                    throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
                  }
                  arg = arg.slice(1, -1);
                  return {
                    type: "verb",
                    mode: "text",
                    body: arg,
                    star
                  };
                }
                if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {
                  if (this.settings.strict && this.mode === "math") {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text[0] + '" used in math mode', nucleus);
                  }
                  text = unicodeSymbols[text[0]] + text.substr(1);
                }
                var match = combiningDiacriticalMarksEndRegex.exec(text);
                if (match) {
                  text = text.substring(0, match.index);
                  if (text === "i") {
                    text = "\u0131";
                  } else if (text === "j") {
                    text = "\u0237";
                  }
                }
                var symbol;
                if (src_symbols[this.mode][text]) {
                  if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text) >= 0) {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text[0] + '" used in math mode', nucleus);
                  }
                  var group = src_symbols[this.mode][text].group;
                  var loc = SourceLocation.range(nucleus);
                  var s;
                  if (ATOMS.hasOwnProperty(group)) {
                    var family = group;
                    s = {
                      type: "atom",
                      mode: this.mode,
                      family,
                      loc,
                      text
                    };
                  } else {
                    s = {
                      type: group,
                      mode: this.mode,
                      loc,
                      text
                    };
                  }
                  symbol = s;
                } else if (text.charCodeAt(0) >= 128) {
                  if (this.settings.strict) {
                    if (!supportedCodepoint(text.charCodeAt(0))) {
                      this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text[0] + '"' + (" (" + text.charCodeAt(0) + ")"), nucleus);
                    } else if (this.mode === "math") {
                      this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text[0] + '" used in math mode', nucleus);
                    }
                  }
                  symbol = {
                    type: "textord",
                    mode: this.mode,
                    loc: SourceLocation.range(nucleus),
                    text
                  };
                } else {
                  return null;
                }
                this.consume();
                if (match) {
                  for (var i = 0; i < match[0].length; i++) {
                    var accent = match[0][i];
                    if (!unicodeAccents[accent]) {
                      throw new src_ParseError("Unknown accent ' " + accent + "'", nucleus);
                    }
                    var command = unicodeAccents[accent][this.mode];
                    if (!command) {
                      throw new src_ParseError("Accent " + accent + " unsupported in " + this.mode + " mode", nucleus);
                    }
                    symbol = {
                      type: "accent",
                      mode: this.mode,
                      loc: SourceLocation.range(nucleus),
                      label: command,
                      isStretchy: false,
                      isShifty: true,
                      base: symbol
                    };
                  }
                }
                return symbol;
              };
              return Parser;
            }();
            Parser_Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
            Parser_Parser.endOfGroup = {
              "[": "]",
              "{": "}",
              "\\begingroup": "\\endgroup"
              /**
               * Parses an "expression", which is a list of atoms.
               *
               * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
               *                 happens when functions have higher precendence han infix
               *                 nodes in implicit parses.
               *
               * `breakOnTokenText`: The text of the token that the expression should end
               *                     with, or `null` if something else should end the
               *                     expression.
               */
            };
            Parser_Parser.SUPSUB_GREEDINESS = 1;
            var parseTree_parseTree = function parseTree(toParse, settings) {
              if (!(typeof toParse === "string" || toParse instanceof String)) {
                throw new TypeError("KaTeX can only parse string typed expression");
              }
              var parser = new Parser_Parser(toParse, settings);
              delete parser.gullet.macros.current["\\df@tag"];
              var tree = parser.parse();
              if (parser.gullet.macros.get("\\df@tag")) {
                if (!settings.displayMode) {
                  throw new src_ParseError("\\tag works only in display equations");
                }
                parser.gullet.feed("\\df@tag");
                tree = [{
                  type: "tag",
                  mode: "text",
                  body: tree,
                  tag: parser.parse()
                }];
              }
              return tree;
            };
            var src_parseTree = parseTree_parseTree;
            var katex_render = function render(expression, baseNode, options) {
              baseNode.textContent = "";
              var node = katex_renderToDomTree(expression, options).toNode();
              baseNode.appendChild(node);
            };
            if (typeof document !== "undefined") {
              if (document.compatMode !== "CSS1Compat") {
                typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
                katex_render = function render() {
                  throw new src_ParseError("KaTeX doesn't work in quirks mode.");
                };
              }
            }
            var renderToString2 = function renderToString3(expression, options) {
              var markup = katex_renderToDomTree(expression, options).toMarkup();
              return markup;
            };
            var katex_generateParseTree = function generateParseTree(expression, options) {
              var settings = new src_Settings(options);
              return src_parseTree(expression, settings);
            };
            var katex_renderError = function renderError(error, expression, options) {
              if (options.throwOnError || !(error instanceof src_ParseError)) {
                throw error;
              }
              var node = buildCommon.makeSpan(["katex-error"], [new domTree_SymbolNode(expression)]);
              node.setAttribute("title", error.toString());
              node.setAttribute("style", "color:" + options.errorColor);
              return node;
            };
            var katex_renderToDomTree = function renderToDomTree(expression, options) {
              var settings = new src_Settings(options);
              try {
                var tree = src_parseTree(expression, settings);
                return buildTree_buildTree(tree, expression, settings);
              } catch (error) {
                return katex_renderError(error, expression, settings);
              }
            };
            var katex_renderToHTMLTree = function renderToHTMLTree(expression, options) {
              var settings = new src_Settings(options);
              try {
                var tree = src_parseTree(expression, settings);
                return buildTree_buildHTMLTree(tree, expression, settings);
              } catch (error) {
                return katex_renderError(error, expression, settings);
              }
            };
            var katex_0 = {
              /**
               * Current KaTeX version
               */
              version: "0.10.2",
              /**
               * Renders the given LaTeX into an HTML+MathML combination, and adds
               * it as a child to the specified DOM node.
               */
              render: katex_render,
              /**
               * Renders the given LaTeX into an HTML+MathML combination string,
               * for sending to the client.
               */
              renderToString: renderToString2,
              /**
               * KaTeX error, usually during parsing.
               */
              ParseError: src_ParseError,
              /**
               * Parses the given LaTeX into KaTeX's internal parse tree structure,
               * without rendering to HTML or MathML.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __parse: katex_generateParseTree,
              /**
               * Renders the given LaTeX into an HTML+MathML internal DOM tree
               * representation, without flattening that representation to a string.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __renderToDomTree: katex_renderToDomTree,
              /**
               * Renders the given LaTeX into an HTML internal DOM tree representation,
               * without MathML and without flattening that representation to a string.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __renderToHTMLTree: katex_renderToHTMLTree,
              /**
               * extends internal font metrics object with a new object
               * each key in the new object represents a font name
              */
              __setFontMetrics: setFontMetrics,
              /**
               * adds a new symbol to builtin symbols table
               */
              __defineSymbol: defineSymbol,
              /**
               * adds a new macro to builtin macro list
               */
              __defineMacro: defineMacro,
              /**
               * Expose the dom tree node types, which can be useful for type checking nodes.
               *
               * NOTE: This method is not currently recommended for public use.
               * The internal tree representation is unstable and is very likely
               * to change. Use at your own risk.
               */
              __domTree: {
                Span: domTree_Span,
                Anchor: domTree_Anchor,
                SymbolNode: domTree_SymbolNode,
                SvgNode,
                PathNode: domTree_PathNode,
                LineNode
              }
            };
            var katex_webpack = __webpack_exports__["default"] = katex_0;
          }
          /******/
        ])["default"]
      );
    });
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter5() {
      EventEmitter5.init.call(this);
    }
    module.exports = EventEmitter5;
    module.exports.once = once;
    EventEmitter5.EventEmitter = EventEmitter5;
    EventEmitter5.prototype._events = void 0;
    EventEmitter5.prototype._eventsCount = 0;
    EventEmitter5.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter5, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter5.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter5.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter5.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter5.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter5.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter5.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter5.prototype.on = EventEmitter5.prototype.addListener;
    EventEmitter5.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter5.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter5.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter5.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
    EventEmitter5.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter5.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter5.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter5.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter5.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter5.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy3 = new Array(n);
      for (var i = 0; i < n; ++i)
        copy3[i] = arr[i];
      return copy3;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/mousetrap/mousetrap.js
var require_mousetrap = __commonJS({
  "node_modules/mousetrap/mousetrap.js"(exports, module) {
    (function(window2, document2, undefined2) {
      if (!window2) {
        return;
      }
      var _MAP = {
        8: "backspace",
        9: "tab",
        13: "enter",
        16: "shift",
        17: "ctrl",
        18: "alt",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "ins",
        46: "del",
        91: "meta",
        93: "meta",
        224: "meta"
      };
      var _KEYCODE_MAP = {
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
      };
      var _SHIFT_MAP = {
        "~": "`",
        "!": "1",
        "@": "2",
        "#": "3",
        "$": "4",
        "%": "5",
        "^": "6",
        "&": "7",
        "*": "8",
        "(": "9",
        ")": "0",
        "_": "-",
        "+": "=",
        ":": ";",
        '"': "'",
        "<": ",",
        ">": ".",
        "?": "/",
        "|": "\\"
      };
      var _SPECIAL_ALIASES = {
        "option": "alt",
        "command": "meta",
        "return": "enter",
        "escape": "esc",
        "plus": "+",
        "mod": /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
      };
      var _REVERSE_MAP;
      for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = "f" + i;
      }
      for (i = 0; i <= 9; ++i) {
        _MAP[i + 96] = i.toString();
      }
      function _addEvent(object, type, callback) {
        if (object.addEventListener) {
          object.addEventListener(type, callback, false);
          return;
        }
        object.attachEvent("on" + type, callback);
      }
      function _characterFromEvent(e) {
        if (e.type == "keypress") {
          var character = String.fromCharCode(e.which);
          if (!e.shiftKey) {
            character = character.toLowerCase();
          }
          return character;
        }
        if (_MAP[e.which]) {
          return _MAP[e.which];
        }
        if (_KEYCODE_MAP[e.which]) {
          return _KEYCODE_MAP[e.which];
        }
        return String.fromCharCode(e.which).toLowerCase();
      }
      function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(",") === modifiers2.sort().join(",");
      }
      function _eventModifiers(e) {
        var modifiers = [];
        if (e.shiftKey) {
          modifiers.push("shift");
        }
        if (e.altKey) {
          modifiers.push("alt");
        }
        if (e.ctrlKey) {
          modifiers.push("ctrl");
        }
        if (e.metaKey) {
          modifiers.push("meta");
        }
        return modifiers;
      }
      function _preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
          return;
        }
        e.returnValue = false;
      }
      function _stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
          return;
        }
        e.cancelBubble = true;
      }
      function _isModifier(key) {
        return key == "shift" || key == "ctrl" || key == "alt" || key == "meta";
      }
      function _getReverseMap() {
        if (!_REVERSE_MAP) {
          _REVERSE_MAP = {};
          for (var key in _MAP) {
            if (key > 95 && key < 112) {
              continue;
            }
            if (_MAP.hasOwnProperty(key)) {
              _REVERSE_MAP[_MAP[key]] = key;
            }
          }
        }
        return _REVERSE_MAP;
      }
      function _pickBestAction(key, modifiers, action) {
        if (!action) {
          action = _getReverseMap()[key] ? "keydown" : "keypress";
        }
        if (action == "keypress" && modifiers.length) {
          action = "keydown";
        }
        return action;
      }
      function _keysFromString(combination) {
        if (combination === "+") {
          return ["+"];
        }
        combination = combination.replace(/\+{2}/g, "+plus");
        return combination.split("+");
      }
      function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i2;
        var modifiers = [];
        keys = _keysFromString(combination);
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (_SPECIAL_ALIASES[key]) {
            key = _SPECIAL_ALIASES[key];
          }
          if (action && action != "keypress" && _SHIFT_MAP[key]) {
            key = _SHIFT_MAP[key];
            modifiers.push("shift");
          }
          if (_isModifier(key)) {
            modifiers.push(key);
          }
        }
        action = _pickBestAction(key, modifiers, action);
        return {
          key,
          modifiers,
          action
        };
      }
      function _belongsTo(element, ancestor) {
        if (element === null || element === document2) {
          return false;
        }
        if (element === ancestor) {
          return true;
        }
        return _belongsTo(element.parentNode, ancestor);
      }
      function Mousetrap6(targetElement) {
        var self2 = this;
        targetElement = targetElement || document2;
        if (!(self2 instanceof Mousetrap6)) {
          return new Mousetrap6(targetElement);
        }
        self2.target = targetElement;
        self2._callbacks = {};
        self2._directMap = {};
        var _sequenceLevels = {};
        var _resetTimer;
        var _ignoreNextKeyup = false;
        var _ignoreNextKeypress = false;
        var _nextExpectedAction = false;
        function _resetSequences(doNotReset) {
          doNotReset = doNotReset || {};
          var activeSequences = false, key;
          for (key in _sequenceLevels) {
            if (doNotReset[key]) {
              activeSequences = true;
              continue;
            }
            _sequenceLevels[key] = 0;
          }
          if (!activeSequences) {
            _nextExpectedAction = false;
          }
        }
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
          var i2;
          var callback;
          var matches = [];
          var action = e.type;
          if (!self2._callbacks[character]) {
            return [];
          }
          if (action == "keyup" && _isModifier(character)) {
            modifiers = [character];
          }
          for (i2 = 0; i2 < self2._callbacks[character].length; ++i2) {
            callback = self2._callbacks[character][i2];
            if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
              continue;
            }
            if (action != callback.action) {
              continue;
            }
            if (action == "keypress" && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
              var deleteCombo = !sequenceName && callback.combo == combination;
              var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
              if (deleteCombo || deleteSequence) {
                self2._callbacks[character].splice(i2, 1);
              }
              matches.push(callback);
            }
          }
          return matches;
        }
        function _fireCallback(callback, e, combo, sequence) {
          if (self2.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
            return;
          }
          if (callback(e, combo) === false) {
            _preventDefault(e);
            _stopPropagation(e);
          }
        }
        self2._handleKey = function(character, modifiers, e) {
          var callbacks = _getMatches(character, modifiers, e);
          var i2;
          var doNotReset = {};
          var maxLevel = 0;
          var processedSequenceCallback = false;
          for (i2 = 0; i2 < callbacks.length; ++i2) {
            if (callbacks[i2].seq) {
              maxLevel = Math.max(maxLevel, callbacks[i2].level);
            }
          }
          for (i2 = 0; i2 < callbacks.length; ++i2) {
            if (callbacks[i2].seq) {
              if (callbacks[i2].level != maxLevel) {
                continue;
              }
              processedSequenceCallback = true;
              doNotReset[callbacks[i2].seq] = 1;
              _fireCallback(callbacks[i2].callback, e, callbacks[i2].combo, callbacks[i2].seq);
              continue;
            }
            if (!processedSequenceCallback) {
              _fireCallback(callbacks[i2].callback, e, callbacks[i2].combo);
            }
          }
          var ignoreThisKeypress = e.type == "keypress" && _ignoreNextKeypress;
          if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
            _resetSequences(doNotReset);
          }
          _ignoreNextKeypress = processedSequenceCallback && e.type == "keydown";
        };
        function _handleKeyEvent(e) {
          if (typeof e.which !== "number") {
            e.which = e.keyCode;
          }
          var character = _characterFromEvent(e);
          if (!character) {
            return;
          }
          if (e.type == "keyup" && _ignoreNextKeyup === character) {
            _ignoreNextKeyup = false;
            return;
          }
          self2.handleKey(character, _eventModifiers(e), e);
        }
        function _resetSequenceTimer() {
          clearTimeout(_resetTimer);
          _resetTimer = setTimeout(_resetSequences, 1e3);
        }
        function _bindSequence(combo, keys, callback, action) {
          _sequenceLevels[combo] = 0;
          function _increaseSequence(nextAction) {
            return function() {
              _nextExpectedAction = nextAction;
              ++_sequenceLevels[combo];
              _resetSequenceTimer();
            };
          }
          function _callbackAndReset(e) {
            _fireCallback(callback, e, combo);
            if (action !== "keyup") {
              _ignoreNextKeyup = _characterFromEvent(e);
            }
            setTimeout(_resetSequences, 10);
          }
          for (var i2 = 0; i2 < keys.length; ++i2) {
            var isFinal = i2 + 1 === keys.length;
            var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i2 + 1]).action);
            _bindSingle(keys[i2], wrappedCallback, action, combo, i2);
          }
        }
        function _bindSingle(combination, callback, action, sequenceName, level) {
          self2._directMap[combination + ":" + action] = callback;
          combination = combination.replace(/\s+/g, " ");
          var sequence = combination.split(" ");
          var info;
          if (sequence.length > 1) {
            _bindSequence(combination, sequence, callback, action);
            return;
          }
          info = _getKeyInfo(combination, action);
          self2._callbacks[info.key] = self2._callbacks[info.key] || [];
          _getMatches(info.key, info.modifiers, { type: info.action }, sequenceName, combination, level);
          self2._callbacks[info.key][sequenceName ? "unshift" : "push"]({
            callback,
            modifiers: info.modifiers,
            action: info.action,
            seq: sequenceName,
            level,
            combo: combination
          });
        }
        self2._bindMultiple = function(combinations, callback, action) {
          for (var i2 = 0; i2 < combinations.length; ++i2) {
            _bindSingle(combinations[i2], callback, action);
          }
        };
        _addEvent(targetElement, "keypress", _handleKeyEvent);
        _addEvent(targetElement, "keydown", _handleKeyEvent);
        _addEvent(targetElement, "keyup", _handleKeyEvent);
      }
      Mousetrap6.prototype.bind = function(keys, callback, action) {
        var self2 = this;
        keys = keys instanceof Array ? keys : [keys];
        self2._bindMultiple.call(self2, keys, callback, action);
        return self2;
      };
      Mousetrap6.prototype.unbind = function(keys, action) {
        var self2 = this;
        return self2.bind.call(self2, keys, function() {
        }, action);
      };
      Mousetrap6.prototype.trigger = function(keys, action) {
        var self2 = this;
        if (self2._directMap[keys + ":" + action]) {
          self2._directMap[keys + ":" + action]({}, keys);
        }
        return self2;
      };
      Mousetrap6.prototype.reset = function() {
        var self2 = this;
        self2._callbacks = {};
        self2._directMap = {};
        return self2;
      };
      Mousetrap6.prototype.stopCallback = function(e, element) {
        var self2 = this;
        if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
          return false;
        }
        if (_belongsTo(element, self2.target)) {
          return false;
        }
        if ("composedPath" in e && typeof e.composedPath === "function") {
          var initialEventTarget = e.composedPath()[0];
          if (initialEventTarget !== e.target) {
            element = initialEventTarget;
          }
        }
        return element.tagName == "INPUT" || element.tagName == "SELECT" || element.tagName == "TEXTAREA" || element.isContentEditable;
      };
      Mousetrap6.prototype.handleKey = function() {
        var self2 = this;
        return self2._handleKey.apply(self2, arguments);
      };
      Mousetrap6.addKeycodes = function(object) {
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            _MAP[key] = object[key];
          }
        }
        _REVERSE_MAP = null;
      };
      Mousetrap6.init = function() {
        var documentMousetrap = Mousetrap6(document2);
        for (var method in documentMousetrap) {
          if (method.charAt(0) !== "_") {
            Mousetrap6[method] = /* @__PURE__ */ function(method2) {
              return function() {
                return documentMousetrap[method2].apply(documentMousetrap, arguments);
              };
            }(method);
          }
        }
      };
      Mousetrap6.init();
      window2.Mousetrap = Mousetrap6;
      if (typeof module !== "undefined" && module.exports) {
        module.exports = Mousetrap6;
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Mousetrap6;
        });
      }
    })(typeof window !== "undefined" ? window : null, typeof window !== "undefined" ? document : null);
  }
});

// node_modules/canvas2svg/canvas2svg.js
var require_canvas2svg = __commonJS({
  "node_modules/canvas2svg/canvas2svg.js"(exports, module) {
    (function() {
      "use strict";
      var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;
      function format2(str, args) {
        var keys = Object.keys(args), i;
        for (i = 0; i < keys.length; i++) {
          str = str.replace(new RegExp("\\{" + keys[i] + "\\}", "gi"), args[keys[i]]);
        }
        return str;
      }
      function randomString2(holder) {
        var chars, randomstring, i;
        if (!holder) {
          throw new Error("cannot create a random attribute name for an undefined object");
        }
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
        randomstring = "";
        do {
          randomstring = "";
          for (i = 0; i < 12; i++) {
            randomstring += chars[Math.floor(Math.random() * chars.length)];
          }
        } while (holder[randomstring]);
        return randomstring;
      }
      function createNamedToNumberedLookup(items, radix) {
        var i, entity, lookup = {}, base10, base16;
        items = items.split(",");
        radix = radix || 10;
        for (i = 0; i < items.length; i += 2) {
          entity = "&" + items[i + 1] + ";";
          base10 = parseInt(items[i], radix);
          lookup[entity] = "&#" + base10 + ";";
        }
        lookup["\\xa0"] = "&#160;";
        return lookup;
      }
      function getTextAnchor(textAlign) {
        var mapping = { "left": "start", "right": "end", "center": "middle", "start": "start", "end": "end" };
        return mapping[textAlign] || mapping.start;
      }
      function getDominantBaseline(textBaseline) {
        var mapping = { "alphabetic": "alphabetic", "hanging": "hanging", "top": "text-before-edge", "bottom": "text-after-edge", "middle": "central" };
        return mapping[textBaseline] || mapping.alphabetic;
      }
      namedEntities = createNamedToNumberedLookup(
        "50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro",
        32
      );
      STYLES = {
        "strokeStyle": {
          svgAttr: "stroke",
          //corresponding svg attribute
          canvas: "#000000",
          //canvas default
          svg: "none",
          //svg default
          apply: "stroke"
          //apply on stroke() or fill()
        },
        "fillStyle": {
          svgAttr: "fill",
          canvas: "#000000",
          svg: null,
          //svg default is black, but we need to special case this to handle canvas stroke without fill
          apply: "fill"
        },
        "lineCap": {
          svgAttr: "stroke-linecap",
          canvas: "butt",
          svg: "butt",
          apply: "stroke"
        },
        "lineJoin": {
          svgAttr: "stroke-linejoin",
          canvas: "miter",
          svg: "miter",
          apply: "stroke"
        },
        "miterLimit": {
          svgAttr: "stroke-miterlimit",
          canvas: 10,
          svg: 4,
          apply: "stroke"
        },
        "lineWidth": {
          svgAttr: "stroke-width",
          canvas: 1,
          svg: 1,
          apply: "stroke"
        },
        "globalAlpha": {
          svgAttr: "opacity",
          canvas: 1,
          svg: 1,
          apply: "fill stroke"
        },
        "font": {
          //font converts to multiple svg attributes, there is custom logic for this
          canvas: "10px sans-serif"
        },
        "shadowColor": {
          canvas: "#000000"
        },
        "shadowOffsetX": {
          canvas: 0
        },
        "shadowOffsetY": {
          canvas: 0
        },
        "shadowBlur": {
          canvas: 0
        },
        "textAlign": {
          canvas: "start"
        },
        "textBaseline": {
          canvas: "alphabetic"
        }
      };
      CanvasGradient = function(gradientNode, ctx2) {
        this.__root = gradientNode;
        this.__ctx = ctx2;
      };
      CanvasGradient.prototype.addColorStop = function(offset, color3) {
        var stop = this.__ctx.__createElement("stop"), regex, matches;
        stop.setAttribute("offset", offset);
        if (color3.indexOf("rgba") !== -1) {
          regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
          matches = regex.exec(color3);
          stop.setAttribute("stop-color", format2("rgb({r},{g},{b})", { r: matches[1], g: matches[2], b: matches[3] }));
          stop.setAttribute("stop-opacity", matches[4]);
        } else {
          stop.setAttribute("stop-color", color3);
        }
        this.__root.appendChild(stop);
      };
      CanvasPattern = function(pattern, ctx2) {
        this.__root = pattern;
        this.__ctx = ctx2;
      };
      ctx = function(o) {
        var defaultOptions = { width: 500, height: 500, enableMirroring: false }, options;
        if (arguments.length > 1) {
          options = defaultOptions;
          options.width = arguments[0];
          options.height = arguments[1];
        } else if (!o) {
          options = defaultOptions;
        } else {
          options = o;
        }
        if (!(this instanceof ctx)) {
          return new ctx(options);
        }
        this.width = options.width || defaultOptions.width;
        this.height = options.height || defaultOptions.height;
        this.enableMirroring = options.enableMirroring !== void 0 ? options.enableMirroring : defaultOptions.enableMirroring;
        this.canvas = this;
        this.__document = options.document || document;
        this.__canvas = this.__document.createElement("canvas");
        this.__ctx = this.__canvas.getContext("2d");
        this.__setDefaultStyles();
        this.__stack = [this.__getStyleState()];
        this.__groupStack = [];
        this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this.__root.setAttribute("version", 1.1);
        this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
        this.__root.setAttribute("width", this.width);
        this.__root.setAttribute("height", this.height);
        this.__ids = {};
        this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
        this.__root.appendChild(this.__defs);
        this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
        this.__root.appendChild(this.__currentElement);
      };
      ctx.prototype.__createElement = function(elementName, properties, resetFill) {
        if (typeof properties === "undefined") {
          properties = {};
        }
        var element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName), keys = Object.keys(properties), i, key;
        if (resetFill) {
          element.setAttribute("fill", "none");
          element.setAttribute("stroke", "none");
        }
        for (i = 0; i < keys.length; i++) {
          key = keys[i];
          element.setAttribute(key, properties[key]);
        }
        return element;
      };
      ctx.prototype.__setDefaultStyles = function() {
        var keys = Object.keys(STYLES), i, key;
        for (i = 0; i < keys.length; i++) {
          key = keys[i];
          this[key] = STYLES[key].canvas;
        }
      };
      ctx.prototype.__applyStyleState = function(styleState) {
        var keys = Object.keys(styleState), i, key;
        for (i = 0; i < keys.length; i++) {
          key = keys[i];
          this[key] = styleState[key];
        }
      };
      ctx.prototype.__getStyleState = function() {
        var i, styleState = {}, keys = Object.keys(STYLES), key;
        for (i = 0; i < keys.length; i++) {
          key = keys[i];
          styleState[key] = this[key];
        }
        return styleState;
      };
      ctx.prototype.__applyStyleToCurrentElement = function(type) {
        var keys = Object.keys(STYLES), i, style, value, id2, regex, matches;
        for (i = 0; i < keys.length; i++) {
          style = STYLES[keys[i]];
          value = this[keys[i]];
          if (style.apply) {
            if (style.apply.indexOf("fill") !== -1 && value instanceof CanvasPattern) {
              if (value.__ctx) {
                while (value.__ctx.__defs.childNodes.length) {
                  id2 = value.__ctx.__defs.childNodes[0].getAttribute("id");
                  this.__ids[id2] = id2;
                  this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
                }
              }
              this.__currentElement.setAttribute("fill", format2("url(#{id})", { id: value.__root.getAttribute("id") }));
            } else if (style.apply.indexOf("fill") !== -1 && value instanceof CanvasGradient) {
              this.__currentElement.setAttribute("fill", format2("url(#{id})", { id: value.__root.getAttribute("id") }));
            } else if (style.apply.indexOf(type) !== -1 && style.svg !== value) {
              if ((style.svgAttr === "stroke" || style.svgAttr === "fill") && value.indexOf("rgba") !== -1) {
                regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                matches = regex.exec(value);
                this.__currentElement.setAttribute(style.svgAttr, format2("rgb({r},{g},{b})", { r: matches[1], g: matches[2], b: matches[3] }));
                this.__currentElement.setAttribute(style.svgAttr + "-opacity", matches[4]);
              } else {
                this.__currentElement.setAttribute(style.svgAttr, value);
              }
            }
          }
        }
      };
      ctx.prototype.__closestGroupOrSvg = function(node) {
        node = node || this.__currentElement;
        if (node.nodeName === "g" || node.nodeName === "svg") {
          return node;
        } else {
          return this.__closestGroupOrSvg(node.parentNode);
        }
      };
      ctx.prototype.getSerializedSvg = function(fixNamedEntities) {
        var serialized = new XMLSerializer().serializeToString(this.__root), keys, i, key, value, regexp, xmlns;
        xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
        if (xmlns.test(serialized)) {
          serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink');
        }
        if (fixNamedEntities) {
          keys = Object.keys(namedEntities);
          for (i = 0; i < keys.length; i++) {
            key = keys[i];
            value = namedEntities[key];
            regexp = new RegExp(key, "gi");
            if (regexp.test(serialized)) {
              serialized = serialized.replace(regexp, value);
            }
          }
        }
        return serialized;
      };
      ctx.prototype.getSvg = function() {
        return this.__root;
      };
      ctx.prototype.save = function() {
        var group = this.__createElement("g"), parent = this.__closestGroupOrSvg();
        this.__groupStack.push(parent);
        parent.appendChild(group);
        this.__currentElement = group;
        this.__stack.push(this.__getStyleState());
      };
      ctx.prototype.restore = function() {
        this.__currentElement = this.__groupStack.pop();
        var state = this.__stack.pop();
        this.__applyStyleState(state);
      };
      ctx.prototype.__addTransform = function(t) {
        var parent = this.__closestGroupOrSvg();
        if (parent.childNodes.length > 0) {
          var group = this.__createElement("g");
          parent.appendChild(group);
          this.__currentElement = group;
        }
        var transform2 = this.__currentElement.getAttribute("transform");
        if (transform2) {
          transform2 += " ";
        } else {
          transform2 = "";
        }
        transform2 += t;
        this.__currentElement.setAttribute("transform", transform2);
      };
      ctx.prototype.scale = function(x, y) {
        if (y === void 0) {
          y = x;
        }
        this.__addTransform(format2("scale({x},{y})", { x, y }));
      };
      ctx.prototype.rotate = function(angle) {
        var degrees2 = angle * 180 / Math.PI;
        this.__addTransform(format2("rotate({angle},{cx},{cy})", { angle: degrees2, cx: 0, cy: 0 }));
      };
      ctx.prototype.translate = function(x, y) {
        this.__addTransform(format2("translate({x},{y})", { x, y }));
      };
      ctx.prototype.transform = function(a, b, c, d, e, f) {
        this.__addTransform(format2("matrix({a},{b},{c},{d},{e},{f})", { a, b, c, d, e, f }));
      };
      ctx.prototype.beginPath = function() {
        var path, parent;
        this.__currentDefaultPath = "";
        this.__currentPosition = {};
        path = this.__createElement("path", {}, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(path);
        this.__currentElement = path;
      };
      ctx.prototype.__applyCurrentDefaultPath = function() {
        if (this.__currentElement.nodeName === "path") {
          var d = this.__currentDefaultPath;
          this.__currentElement.setAttribute("d", d);
        } else {
          throw new Error("Attempted to apply path command to node " + this.__currentElement.nodeName);
        }
      };
      ctx.prototype.__addPathCommand = function(command) {
        this.__currentDefaultPath += " ";
        this.__currentDefaultPath += command;
      };
      ctx.prototype.moveTo = function(x, y) {
        if (this.__currentElement.nodeName !== "path") {
          this.beginPath();
        }
        this.__currentPosition = { x, y };
        this.__addPathCommand(format2("M {x} {y}", { x, y }));
      };
      ctx.prototype.closePath = function() {
        this.__addPathCommand("Z");
      };
      ctx.prototype.lineTo = function(x, y) {
        this.__currentPosition = { x, y };
        if (this.__currentDefaultPath.indexOf("M") > -1) {
          this.__addPathCommand(format2("L {x} {y}", { x, y }));
        } else {
          this.__addPathCommand(format2("M {x} {y}", { x, y }));
        }
      };
      ctx.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.__currentPosition = { x, y };
        this.__addPathCommand(format2(
          "C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}",
          { cp1x, cp1y, cp2x, cp2y, x, y }
        ));
      };
      ctx.prototype.quadraticCurveTo = function(cpx, cpy, x, y) {
        this.__currentPosition = { x, y };
        this.__addPathCommand(format2("Q {cpx} {cpy} {x} {y}", { cpx, cpy, x, y }));
      };
      var normalize2 = function(vector) {
        var len = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
        return [vector[0] / len, vector[1] / len];
      };
      ctx.prototype.arcTo = function(x1, y1, x2, y2, radius) {
        var x0 = this.__currentPosition && this.__currentPosition.x;
        var y0 = this.__currentPosition && this.__currentPosition.y;
        if (typeof x0 == "undefined" || typeof y0 == "undefined") {
          return;
        }
        if (radius < 0) {
          throw new Error("IndexSizeError: The radius provided (" + radius + ") is negative.");
        }
        if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius === 0) {
          this.lineTo(x1, y1);
          return;
        }
        var unit_vec_p1_p0 = normalize2([x0 - x1, y0 - y1]);
        var unit_vec_p1_p2 = normalize2([x2 - x1, y2 - y1]);
        if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
          this.lineTo(x1, y1);
          return;
        }
        var cos = unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1];
        var theta = Math.acos(Math.abs(cos));
        var unit_vec_p1_origin = normalize2([
          unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
          unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
        ]);
        var len_p1_origin = radius / Math.sin(theta / 2);
        var x = x1 + len_p1_origin * unit_vec_p1_origin[0];
        var y = y1 + len_p1_origin * unit_vec_p1_origin[1];
        var unit_vec_origin_start_tangent = [
          -unit_vec_p1_p0[1],
          unit_vec_p1_p0[0]
        ];
        var unit_vec_origin_end_tangent = [
          unit_vec_p1_p2[1],
          -unit_vec_p1_p2[0]
        ];
        var getAngle = function(vector) {
          var x3 = vector[0];
          var y3 = vector[1];
          if (y3 >= 0) {
            return Math.acos(x3);
          } else {
            return -Math.acos(x3);
          }
        };
        var startAngle = getAngle(unit_vec_origin_start_tangent);
        var endAngle = getAngle(unit_vec_origin_end_tangent);
        this.lineTo(
          x + unit_vec_origin_start_tangent[0] * radius,
          y + unit_vec_origin_start_tangent[1] * radius
        );
        this.arc(x, y, radius, startAngle, endAngle);
      };
      ctx.prototype.stroke = function() {
        if (this.__currentElement.nodeName === "path") {
          this.__currentElement.setAttribute("paint-order", "fill stroke markers");
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement("stroke");
      };
      ctx.prototype.fill = function() {
        if (this.__currentElement.nodeName === "path") {
          this.__currentElement.setAttribute("paint-order", "stroke fill markers");
        }
        this.__applyCurrentDefaultPath();
        this.__applyStyleToCurrentElement("fill");
      };
      ctx.prototype.rect = function(x, y, width, height) {
        if (this.__currentElement.nodeName !== "path") {
          this.beginPath();
        }
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.lineTo(x, y);
        this.closePath();
      };
      ctx.prototype.fillRect = function(x, y, width, height) {
        var rect, parent;
        rect = this.__createElement("rect", {
          x,
          y,
          width,
          height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement("fill");
      };
      ctx.prototype.strokeRect = function(x, y, width, height) {
        var rect, parent;
        rect = this.__createElement("rect", {
          x,
          y,
          width,
          height
        }, true);
        parent = this.__closestGroupOrSvg();
        parent.appendChild(rect);
        this.__currentElement = rect;
        this.__applyStyleToCurrentElement("stroke");
      };
      ctx.prototype.clearRect = function(x, y, width, height) {
        var rect, parent = this.__closestGroupOrSvg();
        rect = this.__createElement("rect", {
          x,
          y,
          width,
          height,
          fill: "#FFFFFF"
        }, true);
        parent.appendChild(rect);
      };
      ctx.prototype.createLinearGradient = function(x1, y1, x2, y2) {
        var grad = this.__createElement("linearGradient", {
          id: randomString2(this.__ids),
          x1: x1 + "px",
          x2: x2 + "px",
          y1: y1 + "px",
          y2: y2 + "px",
          "gradientUnits": "userSpaceOnUse"
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);
      };
      ctx.prototype.createRadialGradient = function(x0, y0, r0, x1, y1, r1) {
        var grad = this.__createElement("radialGradient", {
          id: randomString2(this.__ids),
          cx: x1 + "px",
          cy: y1 + "px",
          r: r1 + "px",
          fx: x0 + "px",
          fy: y0 + "px",
          "gradientUnits": "userSpaceOnUse"
        }, false);
        this.__defs.appendChild(grad);
        return new CanvasGradient(grad, this);
      };
      ctx.prototype.__parseFont = function() {
        var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\"\sa-z]+?)\s*$/i;
        var fontPart = regex.exec(this.font);
        var data = {
          style: fontPart[1] || "normal",
          size: fontPart[4] || "10px",
          family: fontPart[6] || "sans-serif",
          weight: fontPart[3] || "normal",
          decoration: fontPart[2] || "normal",
          href: null
        };
        if (this.__fontUnderline === "underline") {
          data.decoration = "underline";
        }
        if (this.__fontHref) {
          data.href = this.__fontHref;
        }
        return data;
      };
      ctx.prototype.__wrapTextLink = function(font, element) {
        if (font.href) {
          var a = this.__createElement("a");
          a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", font.href);
          a.appendChild(element);
          return a;
        }
        return element;
      };
      ctx.prototype.__applyText = function(text, x, y, action) {
        var font = this.__parseFont(), parent = this.__closestGroupOrSvg(), textElement = this.__createElement("text", {
          "font-family": font.family,
          "font-size": font.size,
          "font-style": font.style,
          "font-weight": font.weight,
          "text-decoration": font.decoration,
          "x": x,
          "y": y,
          "text-anchor": getTextAnchor(this.textAlign),
          "dominant-baseline": getDominantBaseline(this.textBaseline)
        }, true);
        textElement.appendChild(this.__document.createTextNode(text));
        this.__currentElement = textElement;
        this.__applyStyleToCurrentElement(action);
        parent.appendChild(this.__wrapTextLink(font, textElement));
      };
      ctx.prototype.fillText = function(text, x, y) {
        this.__applyText(text, x, y, "fill");
      };
      ctx.prototype.strokeText = function(text, x, y) {
        this.__applyText(text, x, y, "stroke");
      };
      ctx.prototype.measureText = function(text) {
        this.__ctx.font = this.font;
        return this.__ctx.measureText(text);
      };
      ctx.prototype.arc = function(x, y, radius, startAngle, endAngle, counterClockwise) {
        if (startAngle === endAngle) {
          return;
        }
        startAngle = startAngle % (2 * Math.PI);
        endAngle = endAngle % (2 * Math.PI);
        if (startAngle === endAngle) {
          endAngle = (endAngle + 2 * Math.PI - 1e-3 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
        }
        var endX = x + radius * Math.cos(endAngle), endY = y + radius * Math.sin(endAngle), startX = x + radius * Math.cos(startAngle), startY = y + radius * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;
        if (diff < 0) {
          diff += 2 * Math.PI;
        }
        if (counterClockwise) {
          largeArcFlag = diff > Math.PI ? 0 : 1;
        } else {
          largeArcFlag = diff > Math.PI ? 1 : 0;
        }
        this.lineTo(startX, startY);
        this.__addPathCommand(format2(
          "A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
          { rx: radius, ry: radius, xAxisRotation: 0, largeArcFlag, sweepFlag, endX, endY }
        ));
        this.__currentPosition = { x: endX, y: endY };
      };
      ctx.prototype.clip = function() {
        var group = this.__closestGroupOrSvg(), clipPath = this.__createElement("clipPath"), id2 = randomString2(this.__ids), newGroup = this.__createElement("g");
        group.removeChild(this.__currentElement);
        clipPath.setAttribute("id", id2);
        clipPath.appendChild(this.__currentElement);
        this.__defs.appendChild(clipPath);
        group.setAttribute("clip-path", format2("url(#{id})", { id: id2 }));
        group.appendChild(newGroup);
        this.__currentElement = newGroup;
      };
      ctx.prototype.drawImage = function() {
        var args = Array.prototype.slice.call(arguments), image = args[0], dx, dy, dw, dh, sx = 0, sy = 0, sw, sh, parent, svg, defs, group, currentElement, svgImage, canvas, context, id2;
        if (args.length === 3) {
          dx = args[1];
          dy = args[2];
          sw = image.width;
          sh = image.height;
          dw = sw;
          dh = sh;
        } else if (args.length === 5) {
          dx = args[1];
          dy = args[2];
          dw = args[3];
          dh = args[4];
          sw = image.width;
          sh = image.height;
        } else if (args.length === 9) {
          sx = args[1];
          sy = args[2];
          sw = args[3];
          sh = args[4];
          dx = args[5];
          dy = args[6];
          dw = args[7];
          dh = args[8];
        } else {
          throw new Error("Inavlid number of arguments passed to drawImage: " + arguments.length);
        }
        parent = this.__closestGroupOrSvg();
        currentElement = this.__currentElement;
        if (image instanceof ctx) {
          svg = image.getSvg();
          defs = svg.childNodes[0];
          while (defs.childNodes.length) {
            id2 = defs.childNodes[0].getAttribute("id");
            this.__ids[id2] = id2;
            this.__defs.appendChild(defs.childNodes[0]);
          }
          group = svg.childNodes[1];
          parent.appendChild(group);
          this.__currentElement = group;
          this.translate(dx, dy);
          this.__currentElement = currentElement;
        } else if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
          svgImage = this.__createElement("image");
          svgImage.setAttribute("width", dw);
          svgImage.setAttribute("height", dh);
          svgImage.setAttribute("preserveAspectRatio", "none");
          if (sx || sy || sw !== image.width || sh !== image.height) {
            canvas = this.__document.createElement("canvas");
            canvas.width = dw;
            canvas.height = dh;
            context = canvas.getContext("2d");
            context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
            image = canvas;
          }
          svgImage.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
          );
          parent.appendChild(svgImage);
          this.__currentElement = svgImage;
          this.translate(dx, dy);
          this.__currentElement = currentElement;
        }
      };
      ctx.prototype.createPattern = function(image, repetition) {
        var pattern = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"), id2 = randomString2(this.__ids), img;
        pattern.setAttribute("id", id2);
        pattern.setAttribute("width", image.width);
        pattern.setAttribute("height", image.height);
        if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
          img = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
          img.setAttribute("width", image.width);
          img.setAttribute("height", image.height);
          img.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
          );
          pattern.appendChild(img);
          this.__defs.appendChild(pattern);
        } else if (image instanceof ctx) {
          pattern.appendChild(image.__root.childNodes[1]);
          this.__defs.appendChild(pattern);
        }
        return new CanvasPattern(pattern, this);
      };
      ctx.prototype.drawFocusRing = function() {
      };
      ctx.prototype.createImageData = function() {
      };
      ctx.prototype.getImageData = function() {
      };
      ctx.prototype.putImageData = function() {
      };
      ctx.prototype.globalCompositeOperation = function() {
      };
      ctx.prototype.setTransform = function() {
      };
      if (typeof window === "object") {
        window.C2S = ctx;
      }
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = ctx;
      }
    })();
  }
});

// src/Util.js
var Util_exports = {};
__export(Util_exports, {
  assignFields: () => assignFields,
  checkAllCommandsDefined: () => checkAllCommandsDefined,
  checkArgumentsDefined: () => checkArgumentsDefined,
  copyFields: () => copyFields,
  download: () => download,
  getArguments: () => getArguments,
  getDummyConstantFunction: () => getDummyConstantFunction,
  getDummyInvalidOperation: () => getDummyInvalidOperation,
  getObjectWithFields: () => getObjectWithFields,
  infinity: () => infinity2,
  limited_logger: () => limited_logger,
  setDummyMethods: () => setDummyMethods,
  setPrivateMethodsToInvalidOperation: () => setPrivateMethodsToInvalidOperation,
  setRemainingMethods: () => setRemainingMethods
});
var infinity2 = 1e4;
function limited_logger(max_msgs) {
  let log_fn = function logger(msg) {
    if (log_fn.msgs_so_far < log_fn.max_msgs) {
      console.log(msg);
      log_fn.msgs_so_far++;
    }
  };
  log_fn.max_msgs = max_msgs;
  log_fn.msgs_so_far = 0;
  return log_fn;
}
function download(filename, text) {
  let element = document.createElement("a");
  element.setAttribute(
    "href",
    "data:text/plain;charset=utf-8," + encodeURIComponent(text)
  );
  element.setAttribute("download", filename);
  element.style.display = "none";
  document.body.appendChild(element);
  element.click();
  document.body.removeChild(element);
}
function getDummyConstantFunction(out) {
  return function() {
    return out;
  };
}
function getDummyInvalidOperation(dummy, functionName) {
  return function() {
    throw new ReferenceError(
      `Invalid operation: cannot use method ${functionName} on a dummy ${dummy.prototype.constructor.name}.`
    );
  };
}
function setDummyMethods(dummy, predicate, property_name_to_method) {
  Object.getOwnPropertyNames(dummy.prototype).filter(predicate).forEach(function(p) {
    dummy[p] = property_name_to_method(p);
  });
}
function setRemainingMethods(dummy, predicate, property_name_to_method) {
  Object.getOwnPropertyNames(dummy.prototype).filter((p) => !dummy.hasOwnProperty(p)).filter(predicate).forEach(function(p) {
    dummy[p] = property_name_to_method(p);
  });
}
function setPrivateMethodsToInvalidOperation(dummy) {
  setDummyMethods(
    dummy,
    (p) => p[0] === "_",
    (p) => getDummyInvalidOperation(dummy, p)
  );
}
function checkAllCommandsDefined(dummy) {
  let undefinedFields = Object.getOwnPropertyNames(dummy.prototype).filter(
    (p) => !dummy.hasOwnProperty(p)
  );
  if (undefinedFields.length > 0) {
    let className = dummy.prototype.constructor.name;
    console.log(
      `Not all fields of ${className} have been defined in ${className} dummy. The list of undefined fields is:
${undefinedFields}`
    );
  }
}
function getArguments(func) {
  return (func + "").replace(/[/][/].*$/gm, "").replace(/\s+/g, "").replace(/[/][*][^/*]*[*][/]/g, "").split("){", 1)[0].replace(/^[^(]*[(]/, "").replace(/=[^,]+/g, "").split(",").filter(Boolean);
}
function checkArgumentsDefined(func, args) {
  for (let i = 0; i < args.length; i++) {
    if (args[i] === void 0) {
      let argName = getArguments(func)[i];
      throw Error(`Argument ${argName} of ${func.name} is undefined`);
    }
  }
}
function getObjectWithFields(obj, fieldNames) {
  let out = new Object();
  for (let field of fieldNames) {
    out[field] = obj[field];
  }
  return out;
}
function assignFields(dest, source2, fieldNames) {
  for (let field of fieldNames) {
    dest[field] = source2[field];
  }
  return dest;
}
function copyFields(dest, source2) {
  for (let kv of Object.entries(source2)) {
    let key = kv[0];
    let value = kv[1];
    if (Array.isArray(value)) {
      value = value.slice();
    }
    dest[key] = value;
  }
  return dest;
}
Map.prototype.getOrElse = function(key, value) {
  return this.has(key) ? this.get(key) : value;
};

// src/SaveLoad.js
var SaveLoad_exports = {};
__export(SaveLoad_exports, {
  deleteFromLocalStore: () => deleteFromLocalStore,
  download: () => download2,
  loadFromLocalStore: () => loadFromLocalStore,
  loadFromServer: () => loadFromServer,
  loadKeysFromLocalStoreWithPrefix: () => loadKeysFromLocalStoreWithPrefix,
  saveToLocalStore: () => saveToLocalStore,
  sseqDatabase: () => sseqDatabase,
  upload: () => upload
});
function download2(filename, text, mime = "text/plain") {
  if (text.constructor !== String) {
    text = JSON.stringify(text);
  }
  let element = document.createElement("a");
  element.setAttribute(
    "href",
    `data:${mime};charset=utf-8,` + encodeURIComponent(text)
  );
  element.setAttribute("download", filename);
  element.style.display = "none";
  document.body.appendChild(element);
  element.click();
  document.body.removeChild(element);
}
function upload() {
  return new Promise((resolve, reject) => {
    let element = document.createElement("input");
    element.setAttribute("type", "file");
    element.setAttribute("multiple", "");
    element.style.display = "none";
    let reader = new FileReader();
    let i = 0;
    let fileList = [];
    element.onchange = function() {
      for (let f of element.files) {
        fileList.push({ name: f.name });
      }
      reader.readAsText(element.files[0]);
    };
    reader.onloadend = function() {
      fileList[i].content = reader.result;
      i++;
      if (i < element.files.length) {
        reader.readAsText(element.files[i]);
      } else {
        resolve(fileList);
        document.body.removeChild(element);
      }
    };
    document.body.appendChild(element);
    element.click();
  });
}
function saveToLocalStore(key, value, collection) {
  if (value.constructor !== String) {
    value = JSON.stringify(value);
  }
  return sseqDatabase.open().catch((err) => console.log(err)).then(() => sseqDatabase.createKey(key, value, collection)).then(() => console.log("Successfully saved."));
}
function nextString(str) {
  if (str.length === 0) {
    return "\xA6";
  }
  return str.substring(0, str.length - 1) + String.fromCharCode(str.charCodeAt(str.length - 1) + 1);
}
async function loadKeysFromLocalStoreWithPrefix(prefix) {
  let endStr = nextString(prefix);
  await sseqDatabase.open();
  return await sseqDatabase.fetchKeyRange(prefix, endStr);
}
async function loadFromLocalStore(key) {
  await sseqDatabase.open();
  let response = await sseqDatabase.fetchKey(key);
  if (!response || !response.value) {
    return void 0;
  }
  let obj = JSON.parse(response.value);
  obj.name = response.key;
  return obj;
}
async function deleteFromLocalStore(key) {
  await sseqDatabase.open();
  await sseqDatabase.deleteKey(key);
  return;
}
async function loadFromServer(path) {
  let response = await fetch(path);
  return await response.json();
}
var sseqDatabase = {};
var datastore = null;
sseqDatabase.open = function() {
  return new Promise(function(resolve, reject) {
    if (datastore) {
      resolve();
      return;
    }
    const version = 6;
    const request = indexedDB.open("sseq", version);
    request.onupgradeneeded = function(e) {
      const db = e.target.result;
      e.target.transaction.onerror = sseqDatabase.onerror;
      if (db.objectStoreNames.contains("sseq")) {
        db.deleteObjectStore("sseq");
      }
      const store = db.createObjectStore("sseq", {
        keyPath: "key"
      });
      store.createIndex("key", "key", { unique: true });
      store.createIndex("collection", "collection", { unique: false });
    };
    request.onsuccess = function(e) {
      datastore = e.target.result;
      resolve();
    };
    request.onerror = reject;
  });
};
sseqDatabase.fetchAllKeys = function() {
  return new Promise(function(resolve, reject) {
    const transaction = datastore.transaction(["sseq"], "readwrite");
    const objStore = transaction.objectStore("sseq");
    const keyRange = IDBKeyRange.lowerBound(0);
    const cursorRequest = objStore.openCursor(keyRange);
    const todos = [];
    transaction.oncomplete = function(e) {
      resolve(todos);
    };
    cursorRequest.onsuccess = function(e) {
      let result = e.target.result;
      if (!!result === false) {
        return;
      }
      todos.push(result.value);
      result.continue();
    };
    cursorRequest.onerror = reject;
  });
};
sseqDatabase.fetchKey = function(key) {
  return new Promise(function(resolve, reject) {
    const transaction = datastore.transaction(["sseq"], "readwrite");
    const objStore = transaction.objectStore("sseq");
    const keyRange = IDBKeyRange.lowerBound(0);
    const objectStoreRequest = objStore.index("key").get(key);
    objectStoreRequest.onsuccess = function(e) {
      resolve(objectStoreRequest.result);
    };
    objectStoreRequest.onerror = reject;
  });
};
sseqDatabase.fetchKeyRange = function(min2, max2) {
  return new Promise(function(resolve, reject) {
    const transaction = datastore.transaction(["sseq"], "readwrite");
    const objStore = transaction.objectStore("sseq");
    const keyRange = IDBKeyRange.bound(min2, max2, true, false);
    const cursorRequest = objStore.openCursor(keyRange);
    const todos = [];
    transaction.oncomplete = function(e) {
      resolve(todos);
    };
    cursorRequest.onsuccess = function(e) {
      let result = e.target.result;
      if (!!result === false) {
        return;
      }
      todos.push(result.value);
      result.continue();
    };
    cursorRequest.onerror = reject;
  });
};
sseqDatabase.fetchCollection = function(collection) {
  return new Promise(function(resolve, reject) {
    const transaction = datastore.transaction(["sseq"], "readwrite");
    const objStore = transaction.objectStore("sseq");
    console.log(collection);
    const cursorRequest = objStore.index("collection").openCursor(collection);
    const todos = [];
    transaction.oncomplete = function(e) {
      resolve(todos);
    };
    cursorRequest.onsuccess = function(e) {
      let result = e.target.result;
      if (!!result == false) {
        return;
      }
      todos.push(result.value);
      result.continue();
    };
    cursorRequest.onerror = reject;
  });
};
sseqDatabase.createKey = function(key, value, collection) {
  return new Promise(function(resolve, reject) {
    const db = datastore;
    const transaction = db.transaction(["sseq"], "readwrite");
    const objStore = transaction.objectStore("sseq");
    const timestamp = (/* @__PURE__ */ new Date()).getTime();
    const item = {
      key,
      value,
      collection,
      timestamp
    };
    const request = objStore.put(item);
    request.onsuccess = function(e) {
      resolve(item);
    };
    request.onerror = reject;
  });
};
sseqDatabase.deleteKey = function(id2) {
  return new Promise(function(resolve, reject) {
    const db = datastore;
    const transaction = db.transaction(["sseq"], "readwrite");
    const objStore = transaction.objectStore("sseq");
    const request = objStore.delete(id2);
    request.onsuccess = function(e) {
      resolve();
    };
    request.onerror = reject;
  });
};

// src/Interface.js
var Interface_exports = {};
__export(Interface_exports, {
  PopupForm: () => PopupForm,
  Undo: () => Undo,
  ensureMath: () => ensureMath,
  renderLatex: () => renderLatex,
  renderMath: () => renderMath
});
var katex = __toESM(require_katex());
function applyAttributesToElement(element, attributes) {
  if (!element || !attributes) {
    return;
  }
  for (let kv of Object.entries(attributes)) {
    element.setAttribute(kv[0], kv[1]);
  }
}
function ensureMath(str) {
  if (str.startsWith("\\(") || str.startsWith("$")) {
    return str;
  }
  if (!str) {
    return "";
  }
  return "$" + str + "$";
}
function renderLatex(html) {
  html = html.replace(/\n/g, "\n<hr>\n");
  let html_list = html.split(/(?:\\\[)|(?:\\\()|(?:\\\))|(?:\\\])|(?:\$)/);
  for (let i = 1; i < html_list.length; i += 2) {
    html_list[i] = katex.renderToString(html_list[i]);
  }
  return html_list.join("\n");
}
var renderMath = (x) => renderLatex(ensureMath(x));
var fixFormHTML = {};
fixFormHTML.radio = function(doc, field) {
  let elts = doc.getElementsByName(field.name);
  let items = field.options.items;
  for (let i = 0; i < elts.length; i++) {
    applyAttributesToElement(elts[i], items[i].attributes);
  }
};
var PopupForm = class _PopupForm {
  // This copies form.record into form.save_record to avoid a race condition between:
  //    the onClose writes over form.record with form.original
  //    the success code writes over form.original with form.record.
  static backupRecord(form) {
    form.save_record = {};
    Object.assign(form.save_record, form.record);
  }
  // Write over form.original and form.record with form.save_record. Better have called backupRecord first!
  static saveRecord(form) {
    Object.assign(form.original, form.save_record);
    Object.assign(form.record, form.save_record);
  }
  // Write over form.record with form.original. Goes in the onClose handler.
  static restoreRecord(form) {
    Object.assign(form.record, form.original);
  }
  constructor(form_options, popup_options) {
    let form_obj = Object.assign({}, _PopupForm.default_form_obj, form_options);
    this.form_obj = form_obj;
    let name2 = form_obj.name;
    form_obj.actions = {};
    form_obj.actions[this.form_obj.accept_button_name] = function() {
      w2ui[name2].save();
      _PopupForm.backupRecord(w2ui[name2]);
      let errs = w2ui[name2].validate();
      if (errs.length > 0) {
        return;
      }
      _PopupForm.saveRecord(w2ui[name2]);
      w2ui[name2].onSuccess();
      w2popup.close();
    };
    form_obj.actions["Cancel"] = function cancel() {
      w2popup.close();
    };
    $().w2form(this.form_obj);
    let form = w2ui[name2];
    this.form = form;
    this.fixFormHTML(form);
    Object.assign(form.original, form_obj.record);
    this.popup_obj = Object.assign(
      {},
      _PopupForm.default_popup_obj,
      popup_options
    );
    this.popup_obj.onToggle = function(event2) {
      $(form.box).hide();
      event2.onComplete = function() {
        $(form.box).show();
        form.resize();
      };
    };
    this.popup_obj.onKeydown = function(event2) {
      if (event2.originalEvent.key === "Enter") {
        if (document.getElementsByClassName("w2ui-error").length > 0) {
          return;
        }
        form.actions[form_obj.accept_button_name]();
      }
    };
    this.popup_obj.onClose = function(event2) {
      _PopupForm.restoreRecord(form);
    };
    this.userOnOpen = this.popup_obj.onOpen;
    this.popup_obj.onOpen = (event2) => {
      let hide_popup = document.createElement("style");
      hide_popup.innerText = "#w2ui-popup, #w2ui-lock { opacity :  0 !important }";
      document.body.appendChild(hide_popup);
      event2.onComplete = () => {
        $("#w2ui-popup #form").w2render(form);
        if (this.userOnOpen) {
          this.userOnOpen(event2);
        }
        document.body.removeChild(hide_popup);
      };
    };
    this.open = this.open.bind(this);
  }
  open() {
    if ($("#w2ui-popup").length > 0) {
      return;
    }
    $().w2popup(this.popup_obj);
  }
  fixFormHTML() {
    let doc = new DOMParser().parseFromString(this.form.formHTML, "text/html");
    for (let f of this.form.fields) {
      if (f.attributes) {
        applyAttributesToElement(
          doc.getElementsByName(f.name)[0],
          f.attributes
        );
      }
      if (fixFormHTML[f.type]) {
        fixFormHTML[f.type](doc, f);
      }
    }
    this.form.formHTML = new XMLSerializer().serializeToString(doc);
  }
};
PopupForm.default_form_obj = {
  style: "border: 0px; background-color: transparent;"
};
PopupForm.default_popup_obj = {
  body: '<div id="form" style="width: 100%; height: 100%;"></div>',
  style: "padding: 15px 0px 0px 0px opacity: 0",
  width: 500,
  height: 220
};
var Undo = class {
  constructor(sseq2) {
    this.sseq = sseq2;
    this.undoStack = [];
    this.undoObjStack = [];
    this.redoStack = [];
    this.redoObjStack = [];
    this.undo = this.undo.bind(this);
    this.redo = this.redo.bind(this);
  }
  startMutationTracking() {
    this.mutationMap = /* @__PURE__ */ new Map();
  }
  addMutationsToUndoStack(event_obj) {
    this.add(this.mutationMap, event_obj);
    this.mutationMap = void 0;
  }
  addMutation(obj, pre, post) {
    if (!this.mutationMap) {
      return;
    }
    if (this.mutationMap.get(obj)) {
      pre = this.mutationMap.get(obj).before;
    }
    this.mutationMap.set(obj, { obj, before: pre, after: post });
  }
  add(mutations, event_obj) {
    this.undoStack.push({ type: "normal", mutations });
    this.undoObjStack.push(event_obj);
    this.redoStack = [];
    this.redoObjStack = [];
  }
  addValueChange(target, prop, before, after, callback) {
    let e = {
      type: "value",
      target,
      prop,
      before,
      after,
      callback
    };
    this.undoStack.push(e);
    this.undoObjStack.push(e);
    this.redoStack = [];
    this.redoObjStack = [];
  }
  addManual(e, e_obj) {
    this.undoStack.push(e);
    this.undoObjStack.push(e_obj);
    this.redoStack = [];
    this.redoObjStack = [];
  }
  clear() {
    this.undoStack = [];
    this.redoStack = [];
  }
  undo() {
    if (this.undoStack.length === 0) {
      return;
    }
    let e = this.undoStack.pop();
    this.redoStack.push(e);
    let obj = this.undoObjStack.pop();
    this.redoObjStack.push(obj);
    switch (e.type) {
      case "normal":
        this.undoNormal(e);
        break;
      case "value":
        e.target[e.prop] = e.before;
        if (e.callback) e.callback();
        break;
    }
    this.sseq.emit("update");
  }
  undoNormal(obj) {
    let mutations = obj.mutations;
    for (let m of mutations.values()) {
      if (m.obj.undoFromMemento) {
        m.obj.undoFromMemento(m.before);
      } else {
        m.obj.restoreFromMemento(m.before);
      }
    }
  }
  redo() {
    if (this.redoStack.length === 0) {
      return;
    }
    let e = this.redoStack.pop();
    this.undoStack.push(e);
    let obj = this.redoObjStack.pop();
    this.undoObjStack.push(obj);
    switch (e.type) {
      case "normal":
        this.redoNormal(e);
        break;
      case "value":
        e.target[e.prop] = e.after;
        if (e.callback) e.callback();
        break;
    }
    this.sseq.emit("update");
  }
  redoNormal(obj) {
    let mutations = obj.mutations;
    for (let m of mutations.values()) {
      if (m.obj.redoFromMemento) {
        m.obj.redoFromMemento(m.after);
      } else {
        m.obj.restoreFromMemento(m.after);
      }
    }
  }
  addLock(msg) {
    let d = /* @__PURE__ */ new Date();
    if (msg === void 0) {
      msg = `Undo events before save at ${d.getFullYear()}-${d.getMonth()}-${d.getDay()} ${d.getHours()}:${d.getMinutes().toString().padStart(2, "0")}?`;
    }
    this.undoStack.push({
      type: "lock",
      msg,
      date: d,
      undoFunction: lockFunction.bind(this)
    });
  }
  getEventObjects() {
    return this.undoObjStack;
  }
  toJSON() {
    return this.undoStack.map(function(e) {
      if (e.type === "normal") {
        return {
          type: "normal",
          mutations: Array.from(e.mutations.entries()).map(([k, v]) => [
            k.recid,
            v.before
          ])
        };
      } else {
        return e;
      }
    });
  }
};
Undo.undoFunctions = {};
Undo.redoFunctions = {};
Undo.undoFunctions["lock"] = lockFunction;
Undo.redoFunctions["lock"] = function() {
};
function lockFunction(obj) {
  w2confirm(obj.msg).yes(() => {
    this.redoStack.pop();
  }).no(() => {
    let e = this.redoStack.pop();
    this.undoStack.push(e);
  });
}
Undo.defaultLockMessage = "Undo events before loaded page?";

// src/Shape.js
var Shape_exports = {};
__export(Shape_exports, {
  circle: () => circle,
  circlen: () => circlen,
  square: () => square
});
var Shapes = {};
Shapes.circle = {
  draw: function(context, x, y, size, path2d = true) {
    context.beginPath();
    context.arc(x, y, size * 0.1, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
    let path = new Path2D();
    path.arc(x, y, size * 0.2, 0, 2 * Math.PI);
    return path;
  }
};
Shapes.circlen = {
  draw: function(context, x, y, size, node) {
    context.beginPath();
    context.arc(x, y, size * 0.1, 0, 2 * Math.PI);
    context.fill();
    context.stroke();
    context.textAlign = "center";
    context.fillStyle = "black";
    let fontsize = 0.15 * size | 0;
    context.font = `${fontsize}px Arial`;
    context.fillText(node.order, x, y + size * 0.06);
    let path = new Path2D();
    path.arc(x, y, size * 0.2, 0, 2 * Math.PI);
    return path;
  }
};
Shapes.square = {
  draw: function(context, x, y, size) {
    let hwidth = 0.1 * size;
    context.beginPath();
    context.rect(x - hwidth, y - hwidth, 2 * hwidth, 2 * hwidth);
    context.fill();
    context.stroke();
    let path = new Path2D();
    path.rect(x - 2 * hwidth, y - 2 * hwidth, 4 * hwidth, 4 * hwidth);
    return path;
  }
};
for (let k of Object.getOwnPropertyNames(Shapes)) {
  Shapes[k].name = k;
}
var circle = Shapes.circle;
var circlen = Shapes.circlen;
var square = Shapes.square;

// src/Display.js
var import_events = __toESM(require_events());

// node_modules/d3-selection/src/index.js
var src_exports = {};
__export(src_exports, {
  clientPoint: () => point_default,
  create: () => create_default,
  creator: () => creator_default,
  customEvent: () => customEvent,
  event: () => event,
  local: () => local,
  matcher: () => matcher_default,
  mouse: () => mouse_default,
  namespace: () => namespace_default,
  namespaces: () => namespaces_default,
  select: () => select_default2,
  selectAll: () => selectAll_default2,
  selection: () => selection_default,
  selector: () => selector_default,
  selectorAll: () => selectorAll_default,
  style: () => styleValue,
  touch: () => touch_default,
  touches: () => touches_default,
  window: () => window_default
});

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name2) {
  var prefix = name2 += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name2.slice(0, i)) !== "xmlns") name2 = name2.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name2 } : name2;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name2) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name2) {
  var fullname = namespace_default(name2);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function selectAll_default(select) {
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-selection/src/selection/data.js
var keyPrefix = "$";
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}
function data_default(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) {
      data[++j] = d;
    });
    return data;
  }
  var bind5 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant_default(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind5(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(selection2) {
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() {
    nodes[++i] = this;
  });
  return nodes;
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  var size = 0;
  this.each(function() {
    ++size;
  });
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name2, value) {
  return function() {
    this.setAttribute(name2, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name2);
    else this.setAttribute(name2, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name2, value) {
  var fullname = namespace_default(name2);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant(name2, value, priority) {
  return function() {
    this.style.setProperty(name2, value, priority);
  };
}
function styleFunction(name2, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name2);
    else this.style.setProperty(name2, v, priority);
  };
}
function style_default(name2, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
}
function styleValue(node, name2) {
  return node.style.getPropertyValue(name2) || window_default(node).getComputedStyle(node, null).getPropertyValue(name2);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name2) {
  return function() {
    delete this[name2];
  };
}
function propertyConstant(name2, value) {
  return function() {
    this[name2] = value;
  };
}
function propertyFunction(name2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name2];
    else this[name2] = v;
  };
}
function property_default(name2, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name2) {
    var i = this._names.indexOf(name2);
    if (i < 0) {
      this._names.push(name2);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name2) {
    var i = this._names.indexOf(name2);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name2) {
    return this._names.indexOf(name2) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name2, value) {
  var names = classArray(name2 + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name2) {
  var create2 = typeof name2 === "function" ? name2 : creator_default(name2);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name2, before) {
  var create2 = typeof name2 === "function" ? name2 : creator_default(name2), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
var filterEvents = {};
var event = null;
if (typeof document !== "undefined") {
  element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
  }
}
var element;
function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event2) {
    var related = event2.relatedTarget;
    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event2);
    }
  };
}
function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event;
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0) name2 = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name2 };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = { type: typename.type, name: typename.name, value, listener, capture };
    if (!on) this.__on = [o];
    else on.push(o);
  };
}
function on_default(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}
function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
  var window2 = window_default(node), event2 = window2.CustomEvent;
  if (typeof event2 === "function") {
    event2 = new event2(type, params);
  } else {
    event2 = window2.document.createEvent("Event");
    if (params) event2.initEvent(type, params.bubbles, params.cancelable), event2.detail = params.detail;
    else event2.initEvent(type, false, false);
  }
  node.dispatchEvent(event2);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function dispatch_default(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/create.js
function create_default(name2) {
  return select_default2(creator_default(name2).call(document.documentElement));
}

// node_modules/d3-selection/src/local.js
var nextId = 0;
function local() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id2 = this._;
    while (!(id2 in node)) if (!(node = node.parentNode)) return;
    return node[id2];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default() {
  var current = event, source2;
  while (source2 = current.sourceEvent) current = source2;
  return current;
}

// node_modules/d3-selection/src/point.js
function point_default(node, event2) {
  var svg = node.ownerSVGElement || node;
  if (svg.createSVGPoint) {
    var point2 = svg.createSVGPoint();
    point2.x = event2.clientX, point2.y = event2.clientY;
    point2 = point2.matrixTransform(node.getScreenCTM().inverse());
    return [point2.x, point2.y];
  }
  var rect = node.getBoundingClientRect();
  return [event2.clientX - rect.left - node.clientLeft, event2.clientY - rect.top - node.clientTop];
}

// node_modules/d3-selection/src/mouse.js
function mouse_default(node) {
  var event2 = sourceEvent_default();
  if (event2.changedTouches) event2 = event2.changedTouches[0];
  return point_default(node, event2);
}

// node_modules/d3-selection/src/selectAll.js
function selectAll_default2(selector) {
  return typeof selector === "string" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([selector == null ? [] : selector], root);
}

// node_modules/d3-selection/src/touch.js
function touch_default(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent_default().changedTouches;
  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point_default(node, touch);
    }
  }
  return null;
}

// node_modules/d3-selection/src/touches.js
function touches_default(node, touches) {
  if (touches == null) touches = sourceEvent_default().touches;
  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point_default(node, touches[i]);
  }
  return points;
}

// node_modules/d3-zoom/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  zoom: () => zoom_default2,
  zoomIdentity: () => identity2,
  zoomTransform: () => transform
});

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: function() {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames2(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0) name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames2(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy3 = {}, _ = this._;
    for (var t in _) copy3[t] = _[t].slice();
    return new Dispatch(copy3);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get(type, name2) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name2) {
      return c.value;
    }
  }
}
function set(type, name2, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name2) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name: name2, value: callback });
  return type;
}
var dispatch_default2 = dispatch;

// node_modules/d3-drag/src/noevent.js
function noevent_default() {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, true);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent_default, true);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, true);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}

// node_modules/d3-zoom/node_modules/d3-interpolate/src/zoom.js
var rho = Math.SQRT2;
var rho2 = 2;
var rho4 = 4;
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
function zoom_default(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  } else {
    var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }
  i.duration = S * 1e3;
  return i;
}

// node_modules/d3-timer/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  interval: () => interval_default,
  now: () => now,
  timeout: () => timeout_default,
  timer: () => timer,
  timerFlush: () => timerFlush
});

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t = new Timer();
  t.restart(callback, delay, time2);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t2, time2 = Infinity;
  while (t12) {
    if (t12._call) {
      if (time2 > t12._time) time2 = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t2 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t2 : taskHead = t2;
    }
  }
  taskTail = t02;
  sleep(time2);
}
function sleep(time2) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity) timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t;
}

// node_modules/d3-timer/src/interval.js
function interval_default(callback, delay, time2) {
  var t = new Timer(), total = delay;
  if (delay == null) return t.restart(callback, delay, time2), t;
  delay = +delay, time2 = time2 == null ? now() : +time2;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time2);
    callback(elapsed);
  }, delay, time2);
  return t;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default2("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name2, id2, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name: name2,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id2) {
  var schedule = get2(node, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get2(node, id2) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed) start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name) continue;
      if (o.state === STARTED) return timeout_default(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING) return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules) return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name2) {
  var schedules = node.__transition, schedule, active, empty2 = true, i;
  if (!schedules) return;
  name2 = name2 == null ? null : name2 + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name2) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty2) delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name2) {
  return this.each(function() {
    interrupt_default(this, name2);
  });
}

// node_modules/d3-transition/node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-transition/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2) h = (g - b) / s + (g < b) * 6;
    else if (g === max2) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t2 = t12 * t12, t3 = t2 * t12;
  return ((1 - 3 * t12 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t12 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/constant.js
function constant_default2(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color3 = gamma(y);
  function rgb3(start2, end) {
    var r = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color3(start2.g, end.g), b = color3(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb3.gamma = rgbGamma;
  return rgb3;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color3;
    for (i = 0; i < n; ++i) {
      color3 = rgb(colors[i]);
      r[i] = color3.r || 0;
      g[i] = color3.g || 0;
      b[i] = color3.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color3.opacity = 1;
    return function(t) {
      color3.r = r(t);
      color3.g = g(t);
      color3.b = b(t);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-transition/node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/transform/parse.js
var cssNode;
var cssRoot;
var cssView;
var svgNode;
function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose_default(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-transition/node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name2) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name2, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name2, value) {
  var id2 = this._id;
  name2 += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name2) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
}
function tweenValue(transition2, name2, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name2] = value.apply(this, arguments);
  });
  return function(node) {
    return get2(node, id2).value[name2];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name2, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name2, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name2);
    string0 = this.getAttribute(name2);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name2, value) {
  var fullname = namespace_default(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name2, i) {
  return function(t) {
    this.setAttribute(name2, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween(name2, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && attrInterpolate(name2, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name2, value) {
  var key = "attr." + name2;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace_default(name2);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name2) {
  return (name2 + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name2, listener) {
  var on0, on1, sit = start(name2) ? init : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name2, listener);
    schedule.on = on1;
  };
}
function on_default2(name2, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name2 = this._name, id2 = this._id;
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name2, id2, i, subgroup, get2(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name2, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default3(select) {
  var name2 = this._name, id2 = this._id;
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule_default(child, name2, id2, k, children, inherit2);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name2, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name2, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant2(name2, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name2, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name2) {
  var on0, on1, listener0, key = "style." + name2, event2 = "end." + key, remove2;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name2)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event2, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name2, value, priority) {
  var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove2(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction2(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant2(name2, i, value), priority).on("end.style." + name2, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name2, i, priority) {
  return function(t) {
    this.style.setProperty(name2, i.call(this, t), priority);
  };
}
function styleTween(name2, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name2, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name2, value, priority) {
  var key = "style." + (name2 += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name2 = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get2(node, id0);
        schedule_default(node, name2, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name2, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name2, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name2;
  this._id = id2;
}
function transition(name2) {
  return selection_default().transition(name2);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default3,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  end: end_default
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}
function transition_default2(name2) {
  var id2, timing;
  if (name2 instanceof Transition) {
    id2 = name2._id, name2 = name2._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name2, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name2, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-zoom/src/constant.js
function constant_default3(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-zoom/src/event.js
function ZoomEvent(target, type, transform2) {
  this.target = target;
  this.type = type;
  this.transform = transform2;
}

// node_modules/d3-zoom/src/transform.js
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity2 = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity2;
  return node.__zoom;
}

// node_modules/d3-zoom/src/noevent.js
function nopropagation() {
  event.stopImmediatePropagation();
}
function noevent_default2() {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-zoom/src/zoom.js
function defaultFilter() {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity2;
}
function defaultWheelDelta() {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom_default2() {
  var filter = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default, listeners = dispatch_default2("start", "zoom", "end"), touchstarting, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point2) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule(collection, transform2, point2);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k, p) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };
  zoom.scaleTo = function(selection2, k, p) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t02 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t02, k1), p0, p1), e, translateExtent);
    }, p);
  };
  zoom.translateBy = function(selection2, x, y) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };
  zoom.translateTo = function(selection2, x, y, p) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity2.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x = p0[0] - p1[0] * transform2.k, y = p0[1] - p1[1] * transform2.k;
    return x === transform2.x && y === transform2.y ? transform2 : new Transform(transform2.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule(transition2, transform2, point2) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args), e = extent.apply(that, args), p = point2 == null ? centroid(e) : typeof point2 === "function" ? point2.apply(that, args) : point2, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1) t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };
  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = mouse_default(this);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k) return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt_default(this);
      g.start();
    }
    noevent_default2();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true), v = select_default2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = mouse_default(this), x0 = event.clientX, y0 = event.clientY;
    nodrag_default(event.view);
    nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt_default(this);
    g.start();
    function mousemoved() {
      noevent_default2();
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse_default(g.that), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event.view, g.moved);
      noevent_default2();
      g.end();
    }
  }
  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t02 = this.__zoom, p0 = mouse_default(this), p1 = t02.invert(p0), k1 = t02.k * (event.shiftKey ? 0.5 : 2), t12 = constrain(translate(scale(t02, k1), p0, p1), extent.apply(this, arguments), translateExtent);
    noevent_default2();
    if (duration > 0) select_default2(this).transition().duration(duration).call(schedule, t12, p0);
    else select_default2(this).call(zoom.transform, t12);
  }
  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches, n = touches.length, g = gesture(this, arguments, event.changedTouches.length === n), started, i, t, p;
    nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = touch_default(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt_default(this);
      g.start();
    }
  }
  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent_default2();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches[i], p = touch_default(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        var p = select_default2(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }
  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant_default3(+_), zoom) : wheelDelta;
  };
  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant_default3(!!_), zoom) : filter;
  };
  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default3(!!_), zoom) : touchable;
  };
  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default3([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };
  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };
  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  return zoom;
}

// node_modules/d3-scale/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  scaleBand: () => band,
  scaleDiverging: () => diverging,
  scaleDivergingLog: () => divergingLog,
  scaleDivergingPow: () => divergingPow,
  scaleDivergingSqrt: () => divergingSqrt,
  scaleDivergingSymlog: () => divergingSymlog,
  scaleIdentity: () => identity4,
  scaleImplicit: () => implicit,
  scaleLinear: () => linear3,
  scaleLog: () => log,
  scaleOrdinal: () => ordinal,
  scalePoint: () => point,
  scalePow: () => pow,
  scaleQuantile: () => quantile2,
  scaleQuantize: () => quantize,
  scaleRadial: () => radial,
  scaleSequential: () => sequential,
  scaleSequentialLog: () => sequentialLog,
  scaleSequentialPow: () => sequentialPow,
  scaleSequentialQuantile: () => sequentialQuantile,
  scaleSequentialSqrt: () => sequentialSqrt,
  scaleSequentialSymlog: () => sequentialSymlog,
  scaleSqrt: () => sqrt,
  scaleSymlog: () => symlog,
  scaleThreshold: () => threshold,
  scaleTime: () => time,
  scaleUtc: () => utcTime,
  tickFormat: () => tickFormat
});

// node_modules/d3-array/src/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare = f;
  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }
  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function ascendingComparator(f) {
  return (d, x) => ascending_default(f(d), x);
}

// node_modules/d3-array/src/number.js
function number_default2(x) {
  return x === null ? NaN : +x;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector_default(number_default2).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function ticks_default(start2, stop, count) {
  var reverse, i = -1, n, ticks, step;
  stop = +stop, start2 = +start2, count = +count;
  if (start2 === stop && count > 0) return [start2];
  if (reverse = stop < start2) n = start2, start2 = stop, stop = n;
  if ((step = tickIncrement(start2, stop, count)) === 0 || !isFinite(step)) return [];
  if (step > 0) {
    let r0 = Math.round(start2 / step), r1 = Math.round(stop / step);
    if (r0 * step < start2) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start2 * step), r1 = Math.round(stop * step);
    if (r0 / step < start2) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }
  if (reverse) ticks.reverse();
  return ticks;
}
function tickIncrement(start2, stop, count) {
  var step = (stop - start2) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start2, stop, count) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start2 ? -step1 : step1;
}

// node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}

// node_modules/d3-array/src/min.js
function min(values, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending_default) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }
    const t = array[k];
    let i = left;
    let j = right;
    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);
    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }
    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array;
}
function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}

// node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return min(values);
  if (p >= 1) return max(values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p, valueof = number_default2) {
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/range.js
function range_default(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range3 = new Array(n);
  while (++i < n) {
    range3[i] = start2 + i * step;
  }
  return range3;
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range3) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range3).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index = /* @__PURE__ */ new Map(), domain = [], range3 = [], unknown = implicit;
  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range3[(i - 1) % range3.length];
  }
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = /* @__PURE__ */ new Map();
    for (const value of _) {
      const key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), scale) : range3.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range3).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse = r1 < r0, start2 = reverse ? r1 : r0, stop = reverse ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values = range_default(n).map(function(i) {
      return start2 + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy3 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy3());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-color/src/define.js
function define_default2(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend2(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color2() {
}
var darker2 = 0.7;
var brighter2 = 1 / darker2;
var reI2 = "\\s*([+-]?\\d+)\\s*";
var reN2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex2 = /^#([0-9a-f]{3,8})$/;
var reRgbInteger2 = new RegExp("^rgb\\(" + [reI2, reI2, reI2] + "\\)$");
var reRgbPercent2 = new RegExp("^rgb\\(" + [reP2, reP2, reP2] + "\\)$");
var reRgbaInteger2 = new RegExp("^rgba\\(" + [reI2, reI2, reI2, reN2] + "\\)$");
var reRgbaPercent2 = new RegExp("^rgba\\(" + [reP2, reP2, reP2, reN2] + "\\)$");
var reHslPercent2 = new RegExp("^hsl\\(" + [reN2, reP2, reP2] + "\\)$");
var reHslaPercent2 = new RegExp("^hsla\\(" + [reN2, reP2, reP2, reN2] + "\\)$");
var named2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default2(Color2, color2, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex2,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex2,
  formatHsl: color_formatHsl2,
  formatRgb: color_formatRgb2,
  toString: color_formatRgb2
});
function color_formatHex2() {
  return this.rgb().formatHex();
}
function color_formatHsl2() {
  return hslConvert2(this).formatHsl();
}
function color_formatRgb2() {
  return this.rgb().formatRgb();
}
function color2(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex2.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn2(m) : l === 3 ? new Rgb2(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba2(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba2(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger2.exec(format2)) ? new Rgb2(m[1], m[2], m[3], 1) : (m = reRgbPercent2.exec(format2)) ? new Rgb2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger2.exec(format2)) ? rgba2(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent2.exec(format2)) ? rgba2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent2.exec(format2)) ? hsla2(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent2.exec(format2)) ? hsla2(m[1], m[2] / 100, m[3] / 100, m[4]) : named2.hasOwnProperty(format2) ? rgbn2(named2[format2]) : format2 === "transparent" ? new Rgb2(NaN, NaN, NaN, 0) : null;
}
function rgbn2(n) {
  return new Rgb2(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba2(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb2(r, g, b, a);
}
function rgbConvert2(o) {
  if (!(o instanceof Color2)) o = color2(o);
  if (!o) return new Rgb2();
  o = o.rgb();
  return new Rgb2(o.r, o.g, o.b, o.opacity);
}
function rgb2(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert2(r) : new Rgb2(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb2(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default2(Rgb2, rgb2, extend2(Color2, {
  brighter: function(k) {
    k = k == null ? brighter2 : Math.pow(brighter2, k);
    return new Rgb2(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker2 : Math.pow(darker2, k);
    return new Rgb2(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex2,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex2,
  formatRgb: rgb_formatRgb2,
  toString: rgb_formatRgb2
}));
function rgb_formatHex2() {
  return "#" + hex2(this.r) + hex2(this.g) + hex2(this.b);
}
function rgb_formatRgb2() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex2(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla2(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl2(h, s, l, a);
}
function hslConvert2(o) {
  if (o instanceof Hsl2) return new Hsl2(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color2)) o = color2(o);
  if (!o) return new Hsl2();
  if (o instanceof Hsl2) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2) h = (g - b) / s + (g < b) * 6;
    else if (g === max2) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl2(h, s, l, o.opacity);
}
function hsl2(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert2(h) : new Hsl2(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl2(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default2(Hsl2, hsl2, extend2(Color2, {
  brighter: function(k) {
    k = k == null ? brighter2 : Math.pow(brighter2, k);
    return new Hsl2(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker2 : Math.pow(darker2, k);
    return new Hsl2(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb2(
      hsl2rgb2(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb2(h, m1, m2),
      hsl2rgb2(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb2(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-interpolate/src/basis.js
function basis2(t12, v0, v1, v2, v3) {
  var t2 = t12 * t12, t3 = t2 * t12;
  return ((1 - 3 * t12 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t12 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default2(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis2((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default2(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis2((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default4 = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear2(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential2(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma2(y) {
  return (y = +y) === 1 ? nogamma2 : function(a, b) {
    return b - a ? exponential2(a, b, y) : constant_default4(isNaN(a) ? b : a);
  };
}
function nogamma2(a, b) {
  var d = b - a;
  return d ? linear2(a, d) : constant_default4(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default2 = function rgbGamma2(y) {
  var color3 = gamma2(y);
  function rgb3(start2, end) {
    var r = color3((start2 = rgb2(start2)).r, (end = rgb2(end)).r), g = color3(start2.g, end.g), b = color3(start2.b, end.b), opacity = nogamma2(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb3.gamma = rgbGamma2;
  return rgb3;
}(1);
function rgbSpline2(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color3;
    for (i = 0; i < n; ++i) {
      color3 = rgb2(colors[i]);
      r[i] = color3.r || 0;
      g[i] = color3.g || 0;
      b[i] = color3.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color3.opacity = 1;
    return function(t) {
      color3.r = r(t);
      color3.g = g(t);
      color3.b = b(t);
      return color3 + "";
    };
  };
}
var rgbBasis2 = rgbSpline2(basis_default2);
var rgbBasisClosed2 = rgbSpline2(basisClosed_default2);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i) x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default3(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB2 = new RegExp(reA2.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one2(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default2(a, b) {
  var bi = reA2.lastIndex = reB2.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA2.exec(a)) && (bm = reB2.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default3(am, bm) });
    }
    bi = reB2.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one2(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default4(b) : (t === "number" ? number_default3 : t === "string" ? (c = color2(b)) ? (b = c, rgb_default2) : string_default2 : b instanceof color2 ? rgb_default2 : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default3)(a, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate, values) {
  if (values === void 0) values = interpolate, interpolate = value_default;
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}

// node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-scale/src/number.js
function number(x) {
  return +x;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x) {
  return x;
}
function normalize(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range3, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range3, interpolate) {
  var j = Math.min(domain.length, range3.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range3 = range3.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range3[i], range3[i + 1]);
  }
  return function(x) {
    var i2 = bisect_default(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source2, target) {
  return target.domain(source2.domain()).range(source2.range()).interpolate(source2.interpolate()).clamp(source2.clamp()).unknown(source2.unknown());
}
function transformer() {
  var domain = unit, range3 = unit, interpolate = value_default, transform2, untransform, unknown, clamp = identity3, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range3.length);
    if (clamp !== identity3) clamp = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise2(domain.map(transform2), range3, interpolate)))(transform2(clamp(x)));
  }
  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise2(range3, domain.map(transform2), number_default3)))(y)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
  };
  scale.rangeRound = function(_) {
    return range3 = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity3, rescale()) : clamp !== identity3;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t, u) {
    transform2 = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity3, identity3);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal_default,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded_default(x * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x) {
  return x;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero3 || fill === "0" && align === "=") zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero3) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent_default(max2) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count, specifier) {
  var step = tickStep(start2, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count) {
    var d = domain();
    return ticks_default(d[0], d[d.length - 1], count == null ? 10 : count);
  };
  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };
  scale.nice = function(count) {
    if (count == null) count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear3() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear3());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/identity.js
function identity4(domain) {
  var unknown;
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : x;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number), scale) : domain.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return identity4(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number) : [0, 1];
  return linearish(scale);
}

// node_modules/d3-scale/src/nice.js
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval2.floor(x0);
  domain[i1] = interval2.ceil(x1);
  return domain;
}

// node_modules/d3-scale/src/log.js
function transformLog(x) {
  return Math.log(x);
}
function transformExp(x) {
  return Math.exp(x);
}
function transformLogn(x) {
  return -Math.log(-x);
}
function transformExpn(x) {
  return -Math.exp(-x);
}
function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function(x) {
    return Math.pow(base, x);
  };
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function(x) {
    return Math.log(x) / base;
  });
}
function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}
function loggish(transform2) {
  var scale = transform2(transformLog, transformExp), domain = scale.domain, base = 10, logs, pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = function(count) {
    var d = domain(), u = d[0], v = d[d.length - 1], r;
    if (r = v < u) i = u, u = v, v = i;
    var i = logs(u), j = logs(v), p, k, t, n = count == null ? 10 : +count, z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      else for (; i <= j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks_default(u, v, n);
    } else {
      z = ticks_default(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length);
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };
  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) {
        return pows(Math.floor(logs(x)));
      },
      ceil: function(x) {
        return pows(Math.ceil(logs(x)));
      }
    }));
  };
  return scale;
}
function log() {
  var scale = loggish(transformer()).domain([1, 10]);
  scale.copy = function() {
    return copy(scale, log()).base(scale.base());
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/symlog.js
function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}
function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}
function symlogish(transform2) {
  var c = 1, scale = transform2(transformSymlog(c), transformSymexp(c));
  scale.constant = function(_) {
    return arguments.length ? transform2(transformSymlog(c = +_), transformSymexp(c)) : c;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer());
  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}
function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}
function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}
function powish(transform2) {
  var scale = transform2(identity3, identity3), exponent = 1;
  function rescale() {
    return exponent === 1 ? transform2(identity3, identity3) : exponent === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent), transformPow(1 / exponent));
  }
  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };
  return linearish(scale);
}
function pow() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/radial.js
function square2(x) {
  return Math.sign(x) * x * x;
}
function unsquare(x) {
  return Math.sign(x) * Math.sqrt(Math.abs(x));
}
function radial() {
  var squared = continuous(), range3 = [0, 1], round = false, unknown;
  function scale(x) {
    var y = unsquare(squared(x));
    return isNaN(y) ? unknown : round ? Math.round(y) : y;
  }
  scale.invert = function(y) {
    return squared.invert(square2(y));
  };
  scale.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale) : squared.domain();
  };
  scale.range = function(_) {
    return arguments.length ? (squared.range((range3 = Array.from(_, number)).map(square2)), scale) : range3.slice();
  };
  scale.rangeRound = function(_) {
    return scale.range(_).round(true);
  };
  scale.round = function(_) {
    return arguments.length ? (round = !!_, scale) : round;
  };
  scale.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return radial(squared.domain(), range3).round(round).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range3 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range3.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
    return scale;
  }
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range3[bisect_default(thresholds, x)];
  }
  scale.invertExtent = function(y) {
    var i = range3.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending_default);
    return rescale();
  };
  scale.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile2().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x0 = 0, x1 = 1, n = 1, domain = [0.5], range3 = [0, 1], unknown;
  function scale(x) {
    return x != null && x <= x ? range3[bisect_default(domain, x, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale.range = function(_) {
    return arguments.length ? (n = (range3 = Array.from(_)).length - 1, rescale()) : range3.slice();
  };
  scale.invertExtent = function(y) {
    var i = range3.indexOf(y);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x0, x1]).range(range3).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}

// node_modules/d3-scale/src/threshold.js
function threshold() {
  var domain = [0.5], range3 = [0, 1], unknown, n = 1;
  function scale(x) {
    return x != null && x <= x ? range3[bisect_default(domain, x, 0, n)] : unknown;
  }
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range3.length - 1), scale) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), n = Math.min(domain.length, range3.length - 1), scale) : range3.slice();
  };
  scale.invertExtent = function(y) {
    var i = range3.indexOf(y);
    return [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function newInterval(floori, offseti, count, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step) {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = function(start2, stop, step) {
    var range3 = [], previous;
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0)) return range3;
    do
      range3.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range3;
  };
  interval2.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count) {
    interval2.count = function(start2, end) {
      t0.setTime(+start2), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };
    interval2.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step === 0;
      } : function(d) {
        return interval2.count(0, d) % step === 0;
      });
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start2, end) {
  return end - start2;
});
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k) * k);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k);
  }, function(start2, end) {
    return (end - start2) / k;
  });
};
var millisecond_default = millisecond;
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond);
}, function(start2, end) {
  return (end - start2) / durationSecond;
}, function(date2) {
  return date2.getUTCSeconds();
});
var second_default = second;
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start2, end) {
  return (end - start2) / durationMinute;
}, function(date2) {
  return date2.getMinutes();
});
var minute_default = minute;
var minutes = minute.range;

// node_modules/d3-time/src/hour.js
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start2, end) {
  return (end - start2) / durationHour;
}, function(date2) {
  return date2.getHours();
});
var hour_default = hour;
var hours = hour.range;

// node_modules/d3-time/src/day.js
var day = newInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
var day_default = day;
var days = day.range;

// node_modules/d3-time/src/week.js
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start2, end) {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// node_modules/d3-time/src/month.js
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start2, end) {
  return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
var month_default = month;
var months = month.range;

// node_modules/d3-time/src/year.js
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start2, end) {
  return end.getFullYear() - start2.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
var year_default = year;
var years = year.range;

// node_modules/d3-time/src/utcMinute.js
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start2, end) {
  return (end - start2) / durationMinute;
}, function(date2) {
  return date2.getUTCMinutes();
});
var utcMinute_default = utcMinute;
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/utcHour.js
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start2, end) {
  return (end - start2) / durationHour;
}, function(date2) {
  return date2.getUTCHours();
});
var utcHour_default = utcHour;
var utcHours = utcHour.range;

// node_modules/d3-time/src/utcDay.js
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start2, end) {
  return (end - start2) / durationDay;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
var utcDay_default = utcDay;
var utcDays = utcDay.range;

// node_modules/d3-time/src/utcWeek.js
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start2, end) {
    return (end - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/utcMonth.js
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start2, end) {
  return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
var utcMonth_default = utcMonth;
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/utcYear.js
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start2, end) {
  return end.getUTCFullYear() - start2.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
var utcYear_default = utcYear;
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [second_default, 1, durationSecond],
    [second_default, 5, 5 * durationSecond],
    [second_default, 15, 15 * durationSecond],
    [second_default, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks(start2, stop, count) {
    const reverse = stop < start2;
    if (reverse) [start2, stop] = [stop, start2];
    const interval2 = count && typeof count.range === "function" ? count : tickInterval(start2, stop, count);
    const ticks2 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse ? ticks2.reverse() : ticks2;
  }
  function tickInterval(start2, stop, count) {
    const target = Math.abs(stop - start2) / count;
    const i = bisector_default(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length) return year2.every(tickStep(start2 / durationYear, stop / durationYear, count));
    if (i === 0) return millisecond_default.every(Math.max(tickStep(start2, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default);
var [timeTicks, timeTickInterval] = ticker(year_default, month_default, sunday, day_default, hour_default, minute_default);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y, m, d) {
  return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad2 = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad2 = c === "e" ? " " : "0";
          if (format2 = formats2[c]) c = format2(date2, pad2);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay_default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = day_default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c, parse;
    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + day_default.count(year_default(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year_default(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year_default(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay_default.count(utcYear_default(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear_default(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear_default(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-scale/src/time.js
function date(t) {
  return new Date(t);
}
function number2(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y) {
    return new Date(invert(y));
  };
  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number2)) : domain().map(date);
  };
  scale.ticks = function(interval2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/utcTime.js
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default, second_default, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

// node_modules/d3-scale/src/sequential.js
function transformer2() {
  var x0 = 0, x1 = 1, t02, t12, k10, transform2, interpolator = identity3, clamp = false, unknown;
  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform2(x) - t02) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t02 = transform2(x0 = +x0), t12 = transform2(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x0, x1];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range3(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }
  scale.range = range3(value_default);
  scale.rangeRound = range3(round_default);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform2 = t, t02 = t(x0), t12 = t(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale;
  };
}
function copy2(source2, target) {
  return target.domain(source2.domain()).interpolator(source2.interpolator()).clamp(source2.clamp()).unknown(source2.unknown());
}
function sequential() {
  var scale = linearish(transformer2()(identity3));
  scale.copy = function() {
    return copy2(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = loggish(transformer2()).domain([1, 10]);
  scale.copy = function() {
    return copy2(scale, sequentialLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = symlogish(transformer2());
  scale.copy = function() {
    return copy2(scale, sequentialSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = powish(transformer2());
  scale.copy = function() {
    return copy2(scale, sequentialPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

// node_modules/d3-scale/src/sequentialQuantile.js
function sequentialQuantile() {
  var domain = [], interpolator = identity3;
  function scale(x) {
    if (x != null && !isNaN(x = +x)) return interpolator((bisect_default(domain, x, 1) - 1) / (domain.length - 1));
  }
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending_default);
    return scale;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  scale.range = function() {
    return domain.map((d, i) => interpolator(i / (domain.length - 1)));
  };
  scale.quantiles = function(n) {
    return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));
  };
  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale, arguments);
}

// node_modules/d3-scale/src/diverging.js
function transformer3() {
  var x0 = 0, x1 = 0.5, x2 = 1, s = 1, t02, t12, t2, k10, k21, interpolator = identity3, transform2, clamp = false, unknown;
  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform2(x)) - t12) * (s * x < s * t12 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t02 = transform2(x0 = +x0), t12 = transform2(x1 = +x1), t2 = transform2(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s = t12 < t02 ? -1 : 1, scale) : [x0, x1, x2];
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };
  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };
  function range3(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale.range = range3(value_default);
  scale.rangeRound = range3(round_default);
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t) {
    transform2 = t, t02 = t(x0), t12 = t(x1), t2 = t(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s = t12 < t02 ? -1 : 1;
    return scale;
  };
}
function diverging() {
  var scale = linearish(transformer3()(identity3));
  scale.copy = function() {
    return copy2(scale, diverging());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer3()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy2(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer3());
  scale.copy = function() {
    return copy2(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

// src/Display.js
var d3 = Object.assign({}, src_exports, src_exports3, src_exports4, src_exports2);
var gridGo = "go";
var gridChess = "chess";
var Display = class extends import_events.EventEmitter {
  // container is either an id (e.g. "#main") or a DOM object
  constructor(container, sseq2) {
    super();
    this.leftMargin = 40;
    this.rightMargin = 5;
    this.topMargin = 45;
    this.bottomMargin = 50;
    this.domainOffset = 1 / 2;
    this.gridStyle = gridGo;
    this.gridColor = "#c6c6c6";
    this.gridStrokeWidth = 0.3;
    this.TICK_STEP_LOG_BASE = 1.1;
    this.hiddenStructlines = /* @__PURE__ */ new Set();
    this.updateQueue = 0;
    this.container = d3.select(container);
    this.container_DOM = this.container.node();
    this.container.selectAll().remove();
    this.xScaleInit = d3.scaleLinear();
    this.yScaleInit = d3.scaleLinear();
    this.canvas = document.createElement("canvas");
    this.canvas.style.padding = "0px";
    this.canvas.style.position = "absolute";
    this.canvas.style.top = "0";
    this.canvas.style.left = "0";
    this.container_DOM.appendChild(this.canvas);
    this.context = this.canvas.getContext("2d");
    this.updateBatch = this.updateBatch.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.previousPage = this.previousPage.bind(this);
    this._onMousemove = this._onMousemove.bind(this);
    this._onClick = this._onClick.bind(this);
    this.zoom = d3.zoom().scaleExtent([0, 4]);
    this.zoom.on("zoom", this.updateBatch);
    this.zoomD3Element = d3.select(this.canvas);
    this.zoomD3Element.call(this.zoom).on("dblclick.zoom", null);
    this.canvas.addEventListener("mousemove", this._onMousemove);
    this.canvas.addEventListener("click", this._onClick);
    window.addEventListener("resize", () => this.resize());
    if (sseq2) this.setSseq(sseq2);
  }
  /**
   *
   * @param width Optional width. Default to 97% of width of bounding element.
   * @param height Optional height. Default to 97% of height of bounding element.
   */
  resize(width, height) {
    if (!this.sseq) return;
    let oldxmin = this.xminFloat;
    let oldymin = this.yminFloat;
    this._initializeCanvas(width, height);
    this._updateScale();
    let dx = this.xminFloat - oldxmin;
    let dy = this.yminFloat - oldymin;
    this.zoom.on("zoom", null);
    this.zoom.translateBy(
      this.zoomD3Element,
      this.dxScale(dx),
      this.dyScale(dy)
    );
    this.zoom.on("zoom", this.updateBatch);
    this.updateBatch();
  }
  /**
   * Initialization method called in constructor.
   * @private
   */
  _initializeCanvas(width, height) {
    const boundingRectangle = this.container_DOM.getBoundingClientRect();
    const canvasWidth = width || 0.99 * boundingRectangle.width;
    const canvasHeight = height || 0.97 * boundingRectangle.height;
    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;
    this.canvas.width = canvasWidth;
    this.canvas.height = canvasHeight;
    this.clipWidth = this.canvasWidth - this.rightMargin;
    this.clipHeight = this.canvasHeight - this.bottomMargin;
    this.plotWidth = this.canvasWidth - this.leftMargin - this.rightMargin;
    this.plotHeight = this.canvasHeight - this.bottomMargin - this.topMargin;
    this.xScaleInit = this.xScaleInit.range([this.leftMargin, this.clipWidth]);
    this.yScaleInit = this.yScaleInit.range([this.clipHeight, this.topMargin]);
  }
  /**
   * Set the spectral sequence to display.
   * @param ss
   */
  setSseq(sseq2) {
    if (this.sseq) {
      this.sseq.removeListener("update", this.updateBatch);
    }
    this.sseq = sseq2;
    if (this.sseq.initial_page_idx) {
      this.page_idx = this.sseq.initial_page_idx;
    } else {
      this.page_idx = this.sseq.min_page_idx;
    }
    if (this.page_idx >= this.sseq.page_list.length) {
      console.log(
        `Warning: min_page_idx ${this.sseq.min_page_idx} greater than page list length ${this.sseq.page_list.length}. Using 0 for min_page_idx instead.`
      );
      this.page_idx = 0;
      this.min_page_idx = 0;
    }
    this.setPage();
    this._initializeScale();
    this._initializeCanvas();
    if (sseq2.gridStyle) {
      this.gridStyle = sseq2.gridStyle;
    }
    this.sseq.on("update", this.updateBatch);
    this.update();
  }
  _initializeScale() {
    this.xScaleInit.domain([
      this.sseq.initialxRange[0] - this.domainOffset,
      this.sseq.initialxRange[1] + this.domainOffset
    ]);
    this.yScaleInit.domain([
      this.sseq.initialyRange[0] - this.domainOffset,
      this.sseq.initialyRange[1] + this.domainOffset
    ]);
  }
  nextPage() {
    if (this.page_idx < this.sseq.page_list.length - 1) {
      this.setPage(this.page_idx + 1);
      this.update();
    }
  }
  previousPage() {
    if (this.page_idx > this.sseq.min_page_idx) {
      this.setPage(this.page_idx - 1);
      this.update();
    }
  }
  /**
   * Update this.page and this.pageRange to reflect the value of page_idx.
   * Eventually I should make a display that indicates the current page again, then this can also say what that is.
   */
  setPage(idx) {
    if (!this.sseq) return;
    if (idx !== void 0) {
      this.page_idx = idx;
    }
    this.pageRange = this.sseq.page_list[this.page_idx];
    if (Array.isArray(this.pageRange)) {
      this.page = this.pageRange[0];
    } else {
      this.page = this.pageRange;
    }
    this.emit("page-change", this.pageRange, this.page_idx);
  }
  /**
   * The main updateAll routine.
   */
  updateBatch() {
    this.update(true);
  }
  update(batch = false) {
    if (!this.sseq) return;
    this.updateQueue++;
    let drawFunc = () => {
      this.updateQueue--;
      if (this.updateQueue != 0) return;
      this._drawSseq(this.context);
      if (d3.event) {
        this._onMousemove(d3.event);
      } else {
        this._onMousemove();
      }
    };
    if (batch) {
      requestAnimationFrame(drawFunc);
    } else {
      drawFunc();
    }
  }
  clipContext(ctx) {
    ctx.beginPath();
    ctx.globalAlpha = 0;
    ctx.rect(this.leftMargin, this.topMargin, this.plotWidth, this.plotHeight);
    ctx.stroke();
    ctx.clip();
    ctx.globalAlpha = 1;
  }
  _drawSseq(ctx = this.context) {
    if (!this.sseq) return;
    this._updateScale();
    this._updateGridAndTickStep();
    ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    this._drawTicks(ctx);
    this._drawAxes(ctx);
    ctx.save();
    this.clipContext(ctx);
    let [nodes, edges] = this.sseq.getDrawnElements(
      this.pageRange,
      this.xmin - 1,
      this.xmax + 1,
      this.ymin - 1,
      this.ymax + 1
    );
    this._drawGrid(ctx);
    this.emit("draw_background");
    this._updateNodes(nodes);
    this._drawEdges(ctx, edges);
    this._drawNodes(ctx);
    if (this.sseq.edgeLayerSVG) this.drawSVG(ctx, this.sseq.edgeLayerSVG);
    ctx.restore();
    this.emit("draw");
  }
  /**
   * @private
   */
  _updateScale() {
    let zoomD3Element = this.zoomD3Element;
    let transform2 = d3.zoomTransform(zoomD3Element.node());
    let scale = transform2.k;
    let xScale = transform2.rescaleX(this.xScaleInit);
    let yScale = transform2.rescaleY(this.yScaleInit);
    this.zoom.on("zoom", null);
    let xScaleMaxed = false, yScaleMaxed = false;
    if (this.sseq.xRange) {
      if (xScale(
        this.sseq.xRange[1] - this.sseq.xRange[0] + 2 * this.domainOffset
      ) - xScale(0) < this.plotWidth) {
        xScaleMaxed = true;
      } else if (xScale(this.sseq.xRange[0] - this.domainOffset) > this.leftMargin) {
        this.zoom.translateBy(
          zoomD3Element,
          (this.leftMargin - xScale(this.sseq.xRange[0] - this.domainOffset)) / scale,
          0
        );
      } else if (xScale(this.sseq.xRange[1] + this.domainOffset) < this.clipWidth) {
        this.zoom.translateBy(
          zoomD3Element,
          (this.clipWidth - xScale(this.sseq.xRange[1] + this.domainOffset)) / scale,
          0
        );
      }
    }
    if (this.sseq.yRange) {
      if (yScale(0) - yScale(
        this.sseq.yRange[1] - this.sseq.yRange[0] + 2 * this.domainOffset
      ) < this.plotHeight) {
        yScaleMaxed = true;
      } else if (yScale(this.sseq.yRange[0] - this.domainOffset) < this.clipHeight) {
        this.zoom.translateBy(
          zoomD3Element,
          0,
          (this.clipHeight - yScale(this.sseq.yRange[0] - this.domainOffset)) / scale
        );
      } else if (yScale(this.sseq.yRange[1] + this.domainOffset) > this.topMargin) {
        this.zoom.translateBy(
          zoomD3Element,
          0,
          this.topMargin - yScale(this.sseq.yRange[1] + this.domainOffset) / scale
        );
      }
    }
    if (xScaleMaxed && yScaleMaxed) {
      if (this.oldScalesMaxed && scale < this.scale) {
        this.zoom.transform(zoomD3Element, this.transform);
        this.zoom.on("zoom", this.updateBatch);
        return;
      } else {
        this.oldScalesMaxed = true;
      }
    } else {
      this.oldScalesMaxed = false;
    }
    this.transform = d3.zoomTransform(zoomD3Element.node());
    this.scale = this.transform.k;
    this.xScale = this.transform.rescaleX(this.xScaleInit);
    this.yScale = this.transform.rescaleY(this.yScaleInit);
    if (xScaleMaxed) {
      this.xScale.domain([
        this.sseq.xRange[0] - this.domainOffset,
        this.sseq.xRange[1] + this.domainOffset
      ]);
    }
    if (yScaleMaxed) {
      this.yScale.domain([
        this.sseq.yRange[0] - this.domainOffset,
        this.sseq.yRange[1] + this.domainOffset
      ]);
    }
    this.xminFloat = this.xScale.invert(this.leftMargin);
    this.xmaxFloat = this.xScale.invert(this.clipWidth);
    this.yminFloat = this.yScale.invert(this.clipHeight);
    this.ymaxFloat = this.yScale.invert(this.topMargin);
    this.xmin = Math.ceil(this.xminFloat);
    this.xmax = Math.floor(this.xmaxFloat);
    this.ymin = Math.ceil(this.yminFloat);
    this.ymax = Math.floor(this.ymaxFloat);
    this.zoom.on("zoom", this.updateBatch);
  }
  dxScale(x) {
    return this.xScale(x) - this.xScale(0);
  }
  dyScale(x) {
    return this.yScale(x) - this.yScale(0);
  }
  _updateGridAndTickStep() {
    this.xTicks = this.xScale.ticks(this.canvasWidth / 70);
    this.yTicks = this.yScale.ticks(this.canvasHeight / 70);
    this.xTickStep = Math.ceil(this.xTicks[1] - this.xTicks[0]);
    this.yTickStep = Math.ceil(this.yTicks[1] - this.yTicks[0]);
    this.xTicks[0] -= this.xTickStep;
    this.yTicks[0] -= this.yTickStep;
    this.xTicks.push(this.xTicks[this.xTicks.length - 1] + this.xTickStep);
    this.yTicks.push(this.yTicks[this.yTicks.length - 1] + this.yTickStep);
    this.xGridStep = Math.floor(this.xTickStep / 5) === 0 ? 1 : Math.floor(this.xTickStep / 5);
    this.yGridStep = Math.floor(this.yTickStep / 5) === 0 ? 1 : Math.floor(this.yTickStep / 5);
    if (this.sseq.squareAspectRatio) {
      this.xGridStep = 1;
      this.yGridStep = this.xGridStep;
    }
  }
  _drawTicks(context) {
    context.save();
    context.textBaseline = "middle";
    context.font = "15px Arial";
    context.textAlign = "center";
    for (let i = Math.floor(this.xTicks[0]); i <= this.xTicks[this.xTicks.length - 1]; i += this.xTickStep) {
      context.fillText(i, this.xScale(i), this.clipHeight + 20);
    }
    context.textAlign = "right";
    for (let i = Math.floor(this.yTicks[0]); i <= this.yTicks[this.yTicks.length - 1]; i += this.yTickStep) {
      context.fillText(i, this.leftMargin - 10, this.yScale(i));
    }
    context.restore();
  }
  _drawGrid(context) {
    context.save();
    context.strokeStyle = this.gridColor;
    context.lineWidth = this.gridStrokeWidth;
    switch (this.gridStyle) {
      case gridGo:
        this._drawGoGrid(context);
        break;
      case gridChess:
        this._drawChessGrid(context);
        break;
      default:
        break;
    }
    context.restore();
  }
  _drawGoGrid(context) {
    this._drawGridWithOffset(context, 0, 0);
  }
  _drawChessGrid(context) {
    this._drawGridWithOffset(context, 0.5, 0.5);
  }
  _drawGridWithOffset(context, xoffset, yoffset) {
    context.beginPath();
    for (let col = Math.floor(this.xmin / this.xGridStep) * this.xGridStep - xoffset; col <= this.xmax; col += this.xGridStep) {
      context.moveTo(this.xScale(col), 0);
      context.lineTo(this.xScale(col), this.clipHeight);
    }
    context.stroke();
    context.beginPath();
    for (let row = Math.floor(this.ymin / this.yGridStep) * this.yGridStep - yoffset; row <= this.ymax; row += this.yGridStep) {
      context.moveTo(this.leftMargin, this.yScale(row));
      context.lineTo(this.canvasWidth - this.rightMargin, this.yScale(row));
    }
    context.stroke();
  }
  _drawAxes(context) {
    context.save();
    context.fillStyle = "#FFF";
    context.rect(0, this.clipHeight, this.leftMargin, this.bottomMargin);
    context.rect(0, 0, this.leftMargin, this.topMargin);
    context.fill();
    context.fillStyle = "#000";
    context.beginPath();
    context.moveTo(this.leftMargin, this.topMargin);
    context.lineTo(this.leftMargin, this.clipHeight);
    context.lineTo(this.canvasWidth - this.rightMargin, this.clipHeight);
    context.stroke();
    context.restore();
  }
  _updateNodes(nodes) {
    let size = Math.max(
      Math.min(this.dxScale(1), -this.dyScale(1), this.sseq.max_class_size),
      this.sseq.min_class_size
    ) * this.sseq.class_scale;
    this.nodes = nodes;
    for (let node of nodes) {
      node.setPosition(
        this.xScale(node.x + this.sseq._getXOffset(node)),
        this.yScale(node.y + this.sseq._getYOffset(node)),
        size
      );
    }
  }
  _drawNodes(context) {
    for (let n of this.nodes) {
      n.draw(context);
    }
  }
  _drawEdges(context, edges) {
    for (let e of edges) {
      if (!e || e.invalid || !e.visible) {
        continue;
      }
      if (e.type == "Structline" && this.hiddenStructlines.has(e.mult)) {
        continue;
      }
      let source_node = e.source_node;
      let target_node = e.target_node;
      if (!source_node || !target_node) {
        continue;
      }
      if (!e.sourceOffset || e.sourceOffset.x === 0 && e.sourceOffset.y === 0) {
        e.sourceOffset = { x: 0, y: 0 };
        e.targetOffset = { x: 0, y: 0 };
      }
      context.save();
      context.strokeStyle = e.color;
      if (e.lineWidth) {
        context.lineWidth = e.lineWidth;
      }
      if (e.opacity) {
        context.globalAlpha = e.opacity;
      }
      if (e.dash) {
        context.setLineDash(e.dash);
      }
      let sourceX = source_node.canvas_x + e.sourceOffset.x;
      let sourceY = source_node.canvas_y + e.sourceOffset.y;
      let targetX = target_node.canvas_x + e.targetOffset.x;
      let targetY = target_node.canvas_y + e.targetOffset.y;
      context.beginPath();
      if (e.bend) {
        let distance = Math.sqrt(
          (targetX - sourceX) * (targetX - sourceX) + (targetY - sourceY) * (targetY - sourceY)
        );
        let looseness = 0.4;
        if (e.looseness) {
          looseness = e.looseness;
        }
        let angle = Math.atan((targetY - sourceY) / (targetX - sourceX));
        let bendAngle = -e.bend * Math.PI / 180;
        let control1X = sourceX + Math.cos(angle + bendAngle) * looseness * distance;
        let control1Y = sourceY + Math.sin(angle + bendAngle) * looseness * distance;
        let control2X = targetX - Math.cos(angle - bendAngle) * looseness * distance;
        let control2Y = targetY - Math.sin(angle - bendAngle) * looseness * distance;
        context.moveTo(sourceX, sourceY);
        context.bezierCurveTo(
          control1X,
          control1Y,
          control2X,
          control2Y,
          targetX,
          targetY
        );
      } else {
        context.moveTo(sourceX, sourceY);
        context.lineTo(targetX, targetY);
      }
      context.stroke();
      context.restore();
    }
  }
  _onClick(e) {
    this.emit("click", this.mouseover_node, e);
  }
  _onMousemove(e) {
    if (!this.nodes) return;
    let redraw = false;
    let rect = this.canvas.getBoundingClientRect();
    if (e) {
      this.x = e.clientX - rect.x;
      this.y = e.clientY - rect.y;
    }
    if (this.mouseover_node) {
      if (this.nodes.includes(this.mouseover_node) && this.context.isPointInPath(this.mouseover_node.path, this.x, this.y)) {
        return;
      } else {
        this.mouseover_node.highlight = false;
        this.mouseover_node = null;
        this.mouseover_class = null;
        redraw = true;
        this.emit("mouseout");
      }
    }
    let node = this.nodes.find(
      (n) => this.context.isPointInPath(n.path, this.x, this.y)
    );
    if (node) {
      redraw = true;
      node.highlight = true;
      this.mouseover_node = node;
      this.mouseover_class = node.c;
      this.emit("mouseover", node);
    }
    if (redraw) this._drawSseq(this.context);
  }
  /**
   * Draw an svg onto the canvas.
   * @param context html5 canvas context
   * @param xml An svg string
   */
  drawSVG(context, xml) {
    let svg64 = btoa(xml);
    let b64Start = "data:image/svg+xml;base64,";
    let image64 = b64Start + svg64;
    let img = new Image();
    img.src = image64;
    context.drawImage(
      img,
      this.xScale(this.sseq.xRange[0]) - this.xMinOffset,
      this.yScale(this.sseq.yRange[1] + 1),
      this.canvasWidth / (this.xmaxFloat - this.xminFloat) * (this.sseq.xRange[1] - this.sseq.xRange[0] + 1),
      this.canvasHeight / (this.ymaxFloat - this.yminFloat) * (this.sseq.yRange[1] - this.sseq.yRange[0] + 1)
    );
  }
  toSVG() {
    let ctx = new C2S(this.canvasWidth, this.canvasHeight);
    this._drawSseq(ctx);
    return ctx.getSerializedSvg(true);
  }
  downloadSVG(filename) {
    if (filename === void 0) {
      filename = `${this.sseq.name}_x-${this.xmin}-${this.xmax}_y-${this.ymin}-${this.ymax}.svg`;
    }
    IO.download(filename, this.toSVG(), "image/svg+xml");
  }
  /**
   * Move the canvas to contain (x,y)
   * TODO: control speed, control acceptable range of target positions, maybe zoom out if display is super zoomed in?
   * @param x
   * @param y
   */
  seek(x, y) {
    return new Promise((resolve) => {
      let dx = 0;
      let dy = 0;
      if (x > this.xmaxFloat - 1) {
        dx = this.xmaxFloat - 1 - x;
      } else if (x < this.xminFloat + 1) {
        dx = this.xminFloat + 1 - x;
      }
      if (y > this.ymaxFloat - 1) {
        dy = this.ymaxFloat - 1 - y;
      } else if (y < this.xminFloat + 1) {
        dy = this.yminFloat + 1 - y;
      }
      if (dx === 0 && dy === 0) {
        return;
      }
      let dxActual = this.dxScale(dx);
      let dyActual = this.dyScale(dy);
      let dist = Math.sqrt(dxActual * dxActual + dyActual * dyActual);
      let steps = Math.ceil(dist / 10);
      let xstep = dxActual / steps;
      let ystep = dyActual / steps;
      let i = 0;
      let t = d3.interval(() => {
        i++;
        this.translateBy(xstep, ystep);
        if (i >= steps) {
          t.stop();
          resolve();
        }
      }, 5);
    });
  }
  translateBy(xstep, ystep) {
    this.zoom.on("zoom", null);
    this.zoom.translateBy(
      this.zoomD3Element,
      xstep / this.scale,
      ystep / this.scale
    );
    this.update();
    this.zoom.on("zoom", this.updateBatch);
  }
  getPageDescriptor(pageRange) {
    if (!this.sseq) return;
    let basePage = 2;
    if (this.sseq.page_list.includes(1)) {
      basePage = 1;
    }
    if (pageRange === infinity) {
      return "Page \u221E";
    }
    if (pageRange === 0) {
      return `Page ${basePage} with all differentials`;
    }
    if (pageRange === 1 && basePage === 2) {
      return `Page ${basePage} with no differentials`;
    }
    if (pageRange.length) {
      if (pageRange[1] === infinity) {
        return `Page ${pageRange[0]} with all differentials`;
      }
      if (pageRange[1] === -1) {
        return `Page ${pageRange[0]} with no differentials`;
      }
      if (pageRange[0] === pageRange[1]) {
        return `Page ${pageRange[0]}`;
      }
      return `Pages ${pageRange[0]} \u2013 ${pageRange[1]}`.replace(infinity, "\u221E");
    }
    return `Page ${pageRange}`;
  }
  // TODO: Fix the selection
  //    /**
  //     * This is a click event handler to update the selected cell when the user clicks.
  //     * @param event A click event.
  //     */
  //    updateSelection(event){
  //        event.mouseover_class = this.mouseover_class;
  //        this.selectedX = Math.floor(display.xScale.invert(event.layerX) + 0.5);
  //        this.selectedY = Math.floor(display.yScale.invert(event.layerY) + 0.5);
  //        this.update();
  //    }
  //
  //    /**
  //     * Enable selection. This changes the grid style to a chess grid and attaches event handlers for clicking
  //     * @param arrowNavigate
  //     */
  //    enableSelection(arrowNavigate){
  //        this.gridStyle = gridChess;
  //        this.addEventHandler("onclick",this.updateSelection.bind(this));
  //        if(arrowNavigate){
  //            this.addEventHandler('left',  () => {
  //                if(this.selectedX !== undefined){
  //                    this.selectedX --;
  //                    this.update();
  //                }
  //            });
  //            this.addEventHandler('right', () => {
  //                if(this.selectedX !== undefined){
  //                    this.selectedX ++;
  //                    this.update();
  //                }
  //            });
  //            this.addEventHandler('down',  () => {
  //                if(this.selectedY !== undefined){
  //                    this.selectedY --;
  //                    this.update();
  //                }
  //            });
  //            this.addEventHandler('up', () => {
  //                if(this.selectedY !== undefined){
  //                    this.selectedY ++;
  //                    this.update();
  //                }
  //            });
  //        }
  //        this.update();
  //    }
  //
  //    disableSelection(){
  //        this.selectedX = undefined;
  //        this.gridStyle = gridGo;
  //        Mousetrap.bind('left',  this.previousPage);
  //        Mousetrap.bind('right', this.nextPage);
  //        this.eventHandlerLayer["onclick"] = (event) => {};
  //        this.update();
  //    }
  //
  //    _drawSelection(context){
  //        let x = this.selectedX;
  //        let y = this.selectedY;
  //        if(x !== undefined && y !== undefined){
  //            context.fillStyle = this.gridColor;
  //            context.rect(
  //                display.xScale(x - 0.5),
  //                display.yScale(y - 0.5),
  //                display.dxScale(1),
  //                display.dyScale(1)
  //            );
  //            context.fill();
  //        }
  //    }
};

// src/Tooltip.js
var MARGIN = 10;
var Tooltip = class {
  constructor(display) {
    this.display = display;
    this.div = document.createElement("div");
    this.div.style.opacity = 0;
    this.div.style.position = "absolute";
    this.div.style["z-index"] = 999999;
    this.div.className = "tooltip";
    document.body.appendChild(this.div);
  }
  setHTML(html) {
    this.div.innerHTML = html;
  }
  show(x, y) {
    this.div.style.left = "0px";
    this.div.style.top = "0px";
    let rect = this.div.getBoundingClientRect();
    let canvasRect = this.display.canvas.getBoundingClientRect();
    x = x + canvasRect.x;
    y = y + canvasRect.y;
    if (x + MARGIN + rect.width < window.innerWidth) x = x + MARGIN;
    else x = x - rect.width - MARGIN;
    if (y - rect.height - MARGIN > 0) y = y - rect.height - MARGIN;
    else y = y + MARGIN;
    this.div.style.left = `${x}px`;
    this.div.style.top = `${y}px`;
    this.div.style.transition = "opacity 200ms";
    this.div.style.opacity = 0.9;
  }
  hide() {
    this.div.style.transition = "opacity 500ms";
    this.div.style.opacity = 0;
  }
};

// src/BasicDisplay.js
var Mousetrap = __toESM(require_mousetrap());
var BasicDisplay = class _BasicDisplay extends Display {
  constructor(container, sseq2) {
    super(container, sseq2);
    document.body.style.overflow = "hidden";
    this.page_indicator_div = this.container.append("div").attr("id", "page_indicator").style("position", "absolute").style("left", "20px").style("top", "10px").style("font-family", "Arial").style("font-size", "15px");
    this.tooltip = new Tooltip(this);
    this.on("mouseover", (node) => {
      this.tooltip.setHTML(this.getClassTooltipHTML(node.c, this.page));
      this.tooltip.show(node.canvas_x, node.canvas_y);
    });
    this.on("mouseout", () => this.tooltip.hide());
    Mousetrap.bind("left", this.previousPage);
    Mousetrap.bind("right", this.nextPage);
    Mousetrap.bind("x", () => {
      if (this.mouseover_node) {
        console.log(this.mouseover_node.c);
      }
    });
    this.on(
      "page-change",
      (r) => this.page_indicator_div.html(this.getPageDescriptor(r))
    );
    this.setPage();
    this.status_div = this.container.append("div").attr("id", "status").style("position", "absolute").style("left", `20px`).style("bottom", `20px`).style("z-index", 1e3);
  }
  setStatus(html) {
    if (this.status_div_timer) {
      clearTimeout(this.status_div_timer);
    }
    this.status_div.html(html);
  }
  delayedSetStatus(html, delay) {
    this.status_div_timer = setTimeout(() => setStatus(html), delay);
  }
  /**
   * Gets the tooltip for the current class on the given page (currently ignores the page).
   * @param c
   * @param page
   * @returns {string}
   */
  getClassTooltip(c, page) {
    let tooltip = c.getNameCoord();
    let extra_info = _BasicDisplay.toTooltipString(c.extra_info, page);
    if (extra_info) tooltip += extra_info;
    return tooltip;
  }
  getClassTooltipHTML(c, page) {
    return renderLatex(this.getClassTooltip(c, page));
  }
  static toTooltipString(obj, page) {
    if (!obj) {
      return false;
    }
    if (obj.constructor === String) {
      return obj;
    }
    if (obj.constructor === Array) {
      return obj.map((x) => Tooltip.toTooltipString(x, page)).filter((x) => x).join("\n");
    }
    if (obj.constructor === Map) {
      let lastkey;
      for (let k of obj.keys()) {
        if (k > page) {
          break;
        }
        lastkey = k;
      }
      return _BasicDisplay.toTooltipString(obj.get(lastkey));
    }
    return false;
  }
};

// src/Panel.js
var Panel_exports = {};
__export(Panel_exports, {
  DifferentialPanel: () => DifferentialPanel,
  Panel: () => Panel,
  StructlinePanel: () => StructlinePanel,
  TabbedPanel: () => TabbedPanel
});
var import_events2 = __toESM(require_events());
var Mousetrap2 = __toESM(require_mousetrap());
var STATE_ADD_DIFFERENTIAL = 1;
var STATE_RM_DIFFERENTIAL = 2;
var STATE_ADD_STRUCTLINE = 3;
var STATE_RM_STRUCTLINE = 4;
var Panel = class _Panel extends import_events2.EventEmitter {
  /**
   * Constructs a panel.
   *
   * @param {Node} parentContainer - The node to add the panel to
   * @param {Display:Display} - The Display object the panel is about.
   * This is used by the helper functions to know where to track mutations,
   * update the display when properties change, etc.
   */
  constructor(parentContainer, display) {
    super();
    this.display = display;
    this.container = document.createElement("div");
    parentContainer.appendChild(this.container);
    this.links = [];
    this.currentGroup = this.container;
  }
  /**
   * This hides the panel. It does nothing but set the display property to
   * none.
   */
  hide() {
    this.container.style.display = "none";
  }
  /**
   * This clears everything in the panel. This currently does not unbind the
   * shortcuts.
   */
  clear() {
    while (this.container.firstChild)
      this.container.removeChild(this.container.firstChild);
    this.links = [];
  }
  /**
   * This shows the panel, and populates the values of the children.  This
   * correctly populates the children added by the helper functions, and no
   * extra work has to be done for them. If custom children are added, one
   * will want to customize the show() function to ensure the children are
   * correctly displayed. This can be done by overwriting the show() function
   * or by listening to the Panel#show event.
   *
   * This function may be called when the panel is already shown. In this
   * case, the correct behaviour is to refresh the display (e.g. update the
   * values of the fields)
   */
  show() {
    this.container.style.removeProperty("display");
    for (let link of this.links) {
      let t = this.display;
      for (let attr of link[0].split(".")) {
        t = t[attr];
        if (t === void 0 || t === null) {
          return;
        }
      }
      link[1].value = t;
    }
    this.emit("show");
  }
  /**
   * This creates a new div and adds it to the container. This new div is
   * then set as currentGroup and has class card-body.
   *
   * This should be used if one wishes to add a collection of children that
   * are to be grouped together. The procedure for using this is as follows:
   * (1) Run Panel#addGroup
   * (2) Add the children using the helper functions (addButton, addObject, etc.)
   * (3) Run Panel#endGroup to set currentGroup back to this.container.
   */
  newGroup() {
    this.currentGroup = document.createElement("div");
    this.currentGroup.className = "card-body";
    this.container.appendChild(this.currentGroup);
  }
  /**
   * See newGroup().
   */
  endGroup() {
    this.currentGroup = this.container;
  }
  /**
   * Does nothing but this.currentGroup.appendChild(obj);
   *
   * @param {Node} obj - The object to be added.
   */
  addObject(obj) {
    this.currentGroup.appendChild(obj);
  }
  /**
   * This adds a button to currentGroup.
   *
   * @param {string} text - Text to appear on the button.
   * @param {function} callback - Function to call when button is clicked.
   * @param {Object} extra - Extra (optional) properties to supply.
   * @param {string} extra.tooltip - Tooltip text to display
   * @param {string[]} shortcuts - A list of shortcuts that will be bound to callback
   */
  addButton(text, callback, extra = {}) {
    let o = document.createElement("button");
    if (extra.style) o.className = `btn btn-${extra.style} mb-2`;
    else o.className = "btn btn-primary mb-2";
    o.style.width = "100%";
    o.innerHTML = text;
    o.addEventListener("click", callback);
    if (extra.tooltip) o.setAttribute("title", extra.tooltip);
    if (extra.shortcuts)
      for (let k of extra.shortcuts) Mousetrap2.bind(k, callback);
    this.currentGroup.appendChild(o);
  }
  /**
   * This adds several buttons placed side-by-side on a row.
   *
   * @param {Array[]} buttons - An array of arguments specifying the buttons
   * to be added. Each entry in the array should itself be an array, which
   * consists of the arguments to Panel#addButton for the corresponding
   * button.
   */
  addButtonRow(buttons) {
    let group = this.currentGroup;
    let o = document.createElement("div");
    o.className = "form-row";
    for (let button of buttons) {
      let c = document.createElement("div");
      c.className = "col";
      this.currentGroup = c;
      this.addButton(...button);
      o.appendChild(c);
    }
    this.currentGroup = group;
    this.currentGroup.appendChild(o);
  }
  /**
   * This adds a header.
   * @param {String} header - The header text.
   */
  addHeader(header) {
    let node = document.createElement("h5");
    node.className = "card-title";
    node.innerHTML = header;
    this.addObject(node);
  }
  /**
   * This adds a linked input. A linked input is an entry that looks like
   *
   *       +-----+
   * Label |     |
   *       +-----+
   *
   * The input field is linked to a certain property of display. When the
   * panel is shown, the initial value of the input field is set to the value
   * of the corresponding property, and when the input field is changed, the
   * property is changed accordingly.
   *
   * @param {string} label - The label displayed next to the input field
   * @param {string} target - The property the input field is linked to.
   * This is specified by a string of the from "foo.bar.xyz", which says the
   * field is linked to this.display.foo.bar.xyz.
   * @param {string} type - The type of the input field. This is "text" or
   * "number" would usually be sensible choices.
   * @param {Object=} mementoObject - By default, the undo/redo functions
   * will simply set the value of target to what it was. Here the target
   * is remembered as an *object*, not as a property of this.display via
   * target (for example, if the input is about the currently active node
   * (this.display.selected), the undo function should undo the change on the
   * node that was affected, not the node that is active when the undo button
   * is pressed). It turns out this is problematic when dealing with nodes of
   * classes, since when classes are restored via undo/redo, the set of nodes
   * is copied and all references are lost.
   *
   * If mementoObject is defined, then instead of tracking individual changes
   * of the properties, the mutation tracker remembers the previous and after
   * states of mementoObject and writes that into the undo stack instead.
   * c.f. the node color/size inputs in EditorDisplay.
   */
  addLinkedInput(label, target, type, mementoObject) {
    let o = document.createElement("div");
    o.className = "form-row mb-2";
    o.style.width = "100%";
    this.currentGroup.appendChild(o);
    let l = document.createElement("label");
    l.className = "col-form-label mr-sm-2";
    l.innerHTML = label;
    o.appendChild(l);
    let i = document.createElement("input");
    i.style["flex-grow"] = 1;
    i.setAttribute("type", type);
    o.appendChild(i);
    switch (type) {
      case "text":
        i.setAttribute("size", "1");
        break;
      default:
        i.style.width = "1px";
        break;
    }
    this.links.push([target, i]);
    i.addEventListener("change", (e) => {
      let target_pre;
      if (mementoObject) {
        mementoObject = _Panel.unwrapProperty(
          this.display,
          mementoObject.split(".")
        );
        target_pre = mementoObject.getMemento();
      }
      let l2 = target.split(".");
      let prop = l2.pop();
      let t = _Panel.unwrapProperty(this.display, l2);
      let old_val = t[prop];
      let new_val = e.target.value;
      t[prop] = new_val;
      if (this.display.sseq.undo) {
        if (mementoObject) {
          this.display.sseq.undo.startMutationTracking();
          this.display.sseq.undo.addMutation(
            mementoObject,
            target_pre,
            mementoObject.getMemento()
          );
          this.display.sseq.undo.addMutationsToUndoStack();
        } else {
          this.display.sseq.undo.addValueChange(
            t,
            prop,
            old_val,
            new_val,
            () => this.display.sidebar.showPanel()
          );
        }
      }
      this.display.sseq.emit("update");
    });
  }
  static unwrapProperty(start2, list) {
    let t = start2;
    for (let i of list) t = t[i];
    return t;
  }
};
var TabbedPanel = class extends Panel {
  constructor(parentContainer, display) {
    super(parentContainer, display);
    let head = document.createElement("div");
    head.className = "card-header";
    this.container.appendChild(head);
    this.header = document.createElement("ul");
    this.header.className = "nav nav-tabs card-header-tabs";
    head.appendChild(this.header);
    this.tabs = [];
    this.currentTab = null;
  }
  /**
   * This adds a tab to TabbedPanel.
   *
   * @param {string} name - The name of the tab, to be displayed in the
   * header. Avoid making this too long.
   * @param {Panel} tab - The tab to be added.
   */
  addTab(name2, tab) {
    let li = document.createElement("li");
    li.className = "nav-item";
    this.header.appendChild(li);
    let a = document.createElement("a");
    a.className = "nav-link";
    a.href = "#";
    a.innerHTML = name2;
    li.appendChild(a);
    a.addEventListener("click", () => this.showTab(tab));
    this.tabs[this.tabs.length] = [tab, a];
    if (!this.currentTab) this.currentTab = tab;
  }
  show() {
    super.show();
    this.showTab(this.currentTab);
  }
  nextTab() {
    let n = this.tabs.findIndex((t) => t[0] == this.currentTab);
    n = (n + 1) % this.tabs.length;
    this.showTab(this.tabs[n][0]);
  }
  prevTab() {
    let n = this.tabs.findIndex((t) => t[0] == this.currentTab);
    n = (n + this.tabs.length - 1) % this.tabs.length;
    this.showTab(this.tabs[n][0]);
  }
  /**
   * Sets the corresponding tab to be the active tab and shows it (of course,
   * the tab will not be actually shown if the panel itself is hidden).
   *
   * @param {Panel} tab - Tab to be shown.
   */
  showTab(tab) {
    this.currentTab = tab;
    for (let t of this.tabs) {
      if (t[0] == tab) {
        t[1].className = "nav-link active";
        t[0].show();
      } else {
        t[1].className = "nav-link";
        t[0].hide();
      }
    }
  }
};
var DifferentialPanel = class extends Panel {
  constructor(parentContainer, display) {
    super(parentContainer, display);
    this.differential_list = document.createElement("ul");
    this.differential_list.className = "list-group list-group-flush";
    this.differential_list.style["text-align"] = "center";
    this.addObject(this.differential_list);
    this.on("show", () => {
      while (this.differential_list.firstChild)
        this.differential_list.removeChild(this.differential_list.firstChild);
      let edges = this.display.selected.c.edges.filter((e) => e.type === "Differential").sort((a, b) => a.page - b.page);
      let sname, tname;
      for (let e of edges) {
        sname = e.source.name ? e.source.name : "?";
        tname = e.target.name ? e.target.name : "?";
        if (e.source == this.display.selected.c)
          this.addLI(
            renderMath(
              `d_${e.page}({\\color{blue}${sname}}) = ${tname}`
            )
          );
        else
          this.addLI(
            renderMath(
              `d_${e.page}(${sname}) = {\\color{blue}${tname}}`
            )
          );
      }
      this.addLI(
        "<a href='#'>Add differential</a>",
        () => this.display.state = STATE_ADD_DIFFERENTIAL
      );
      this.addLI(
        "<a href='#'>Remove differential</a>",
        () => this.display.state = STATE_RM_DIFFERENTIAL
      );
    });
  }
  addLI(html, callback) {
    let node = document.createElement("li");
    node.className = "list-group-item";
    node.style = "padding: 0.75rem 0";
    node.innerHTML = html;
    if (callback) node.addEventListener("click", callback);
    this.differential_list.appendChild(node);
  }
};
var StructlinePanel = class extends Panel {
  constructor(parentContainer, display) {
    super(parentContainer, display);
    this.structline_list = document.createElement("ul");
    this.structline_list.className = "list-group list-group-flush";
    this.structline_list.style["text-align"] = "center";
    this.addObject(this.structline_list);
    this.on("show", () => {
      while (this.structline_list.firstChild)
        this.structline_list.removeChild(this.structline_list.firstChild);
      let edges = this.display.selected.c.edges.filter((e) => e.type === "Structline").sort((a, b) => a.page - b.page);
      let sname, tname;
      for (let e of edges) {
        sname = e.source.name ? e.source.name : "?";
        tname = e.target.name ? e.target.name : "?";
        if (e.source == this.display.selected.c)
          this.addLI(
            renderMath(
              `{\\color{blue}${sname}} \\text{---} ${tname}`
            )
          );
        else
          this.addLI(
            renderMath(
              `${sname} \\text{---} {\\color{blue}${tname}}`
            )
          );
      }
      this.addLI(
        "<a href='#'>Add structline</a>",
        () => this.display.state = STATE_ADD_STRUCTLINE
      );
      this.addLI(
        "<a href='#'>Remove structline</a>",
        () => this.display.state = STATE_RM_STRUCTLINE
      );
    });
  }
  addLI(html, callback) {
    let node = document.createElement("li");
    node.className = "list-group-item";
    node.style = "padding: 0.75rem 0";
    node.innerHTML = html;
    if (callback) node.addEventListener("click", callback);
    this.structline_list.appendChild(node);
  }
};

// src/SidebarDisplay.js
var Sidebar = class {
  constructor(parentContainer) {
    this.adjuster = document.createElement("div");
    this.adjuster.style.backgroundColor = "rgba(0,0,0,0.125)";
    this.adjuster.style.height = "100%";
    this.adjuster.style.cursor = "ew-resize";
    this.adjuster.style.width = "2px";
    parentContainer.appendChild(this.adjuster);
    this.resize = this.resize.bind(this);
    this.stopResize = this.stopResize.bind(this);
    this.adjuster.addEventListener(
      "mousedown",
      function(e) {
        e.preventDefault();
        window.addEventListener("mousemove", this.resize);
        window.addEventListener("mouseup", this.stopResize);
      }.bind(this)
    );
    this.sidebar = document.createElement("div");
    this.sidebar.style.height = "100%";
    this.sidebar.style.width = "240px";
    this.sidebar.style.border = "none";
    this.sidebar.style.display = "flex";
    this.sidebar.style.flexDirection = "column";
    this.sidebar.className = "card";
    parentContainer.appendChild(this.sidebar);
    this.main_div = document.createElement("div");
    this.main_div.style.overflow = "auto";
    this.sidebar.appendChild(this.main_div);
    let filler = document.createElement("div");
    filler.style.flexGrow = "1";
    this.sidebar.appendChild(filler);
    this.footer_div = document.createElement("div");
    this.sidebar.appendChild(this.footer_div);
    this.panels = [];
    this.currentPanel = null;
  }
  addPanel(panel) {
    this.panels.push(panel);
    return this.panels.length;
  }
  init(display) {
    this.display = display;
    this.footer = new Panel(this.footer_div, display);
  }
  resize(e) {
    let width = this.sidebar.getBoundingClientRect().right - e.pageX;
    this.sidebar.style.width = `${width}px`;
  }
  stopResize() {
    window.removeEventListener("mousemove", this.resize);
    window.removeEventListener("mouseup", this.stopResize);
    this.display.resize();
  }
  showPanel(panel) {
    if (!panel) panel = this.currentPanel;
    this.currentPanel = panel;
    for (let x of this.panels) {
      if (x == panel) x.show();
      else x.hide();
    }
  }
};
var SidebarDisplay = class extends Display {
  constructor(container, sseq2) {
    if (typeof container == "string")
      container = document.querySelector(container);
    container.style.display = "flex";
    container.style.displayDirection = "row";
    let child = document.createElement("div");
    child.style.height = "100%";
    child.style.minHeight = "100%";
    child.style.overflow = "hidden";
    child.style.position = "relative";
    child.style.flexGrow = "1";
    container.appendChild(child);
    let sidebar = new Sidebar(container);
    super(child, sseq2);
    this.sidebar = sidebar;
    this.sidebar.init(this);
  }
};

// src/EditorDisplay.js
var Mousetrap3 = __toESM(require_mousetrap());
var STATE_ADD_DIFFERENTIAL2 = 1;
var STATE_RM_DIFFERENTIAL2 = 2;
var STATE_ADD_STRUCTLINE2 = 3;
var STATE_RM_STRUCTLINE2 = 4;
var STATE_RM_EDGE = 5;
var STATE_ADD_CLASS = 6;
var EditorDisplay = class extends SidebarDisplay {
  constructor(container, sseq2) {
    super(container);
    this.differentialColors = {};
    this.sidebar.footer.newGroup();
    this.sidebar.footer.addButtonRow([
      ["Undo", () => this.sseq.undo.undo()],
      ["Redo", () => this.sseq.undo.redo()]
    ]);
    this.sidebar.footer.addButton(
      "Download SVG",
      () => this.downloadSVG("sseq.svg")
    );
    this.sidebar.footer.addButton(
      "Save",
      () => this.sseq.download("sseq.json")
    );
    this.generalPanel = new Panel(this.sidebar.main_div, this);
    this.generalPanel.newGroup();
    this.pageLabel = document.createElement("span");
    this.on("page-change", (r) => {
      this.pageLabel.innerHTML = this.getPageDescriptor(r);
      this._unselect();
    });
    this.generalPanel.addObject(this.pageLabel);
    this.generalPanel.newGroup();
    this.generalPanel.addButton(
      "Add class",
      () => this.state = STATE_ADD_CLASS,
      { shortcuts: ["n"] }
    );
    this.generalPanel.newGroup();
    this.generalPanel.addLinkedInput("Min X", "sseq.minX", "number");
    this.generalPanel.addLinkedInput("Max X", "sseq.maxX", "number");
    this.generalPanel.addLinkedInput("Min Y", "sseq.minY", "number");
    this.generalPanel.addLinkedInput("Max Y", "sseq.maxY", "number");
    this.sidebar.addPanel(this.generalPanel);
    this.classPanel = new TabbedPanel(this.sidebar.main_div, this);
    this.sidebar.addPanel(this.classPanel);
    this.nodeTab = new Panel(this.classPanel.container, this);
    this.nodeTab.newGroup();
    this.title_text = document.createElement("span");
    this.nodeTab.addObject(this.title_text);
    this.title_edit_link = document.createElement("a");
    this.title_edit_link.className = "card-link-body";
    this.title_edit_link.href = "#";
    this.title_edit_link.style.float = "right";
    this.title_edit_link.innerHTML = "Edit";
    this.title_edit_link.addEventListener("click", () => {
      let c = this.selected.c;
      if (this.title_edit_link.innerHTML == "OK") {
        let old_name = c.name;
        c.name = this.title_edit_input.value;
        this.sseq.undo.addValueChange(
          c,
          "name",
          old_name,
          c.name,
          () => this.sidebar.showPanel()
        );
        this.sseq.emit("update");
        this.nodeTab.show();
      } else {
        this.title_edit_link.innerHTML = "OK";
        if (c.name) this.title_edit_input.value = c.name;
        this.title_edit_input.style.removeProperty("display");
      }
    });
    this.nodeTab.addObject(this.title_edit_link);
    this.title_edit_input = document.createElement("input");
    this.title_edit_input.className = "form-control mt-2";
    this.title_edit_input.type = "text";
    this.title_edit_input.placeholder = "Enter class name";
    this.nodeTab.addObject(this.title_edit_input);
    this.nodeTab.on("show", () => {
      this.title_edit_input.style.display = "none";
      this.title_edit_input.value = "";
      this.title_edit_link.innerHTML = "Edit";
      let c = this.selected.c;
      if (c.name) {
        this.title_text.innerHTML = renderLaTeX(ensureMath(c.name)) + ` - (${c.x}, ${c.y})`;
      } else {
        this.title_text.innerHTML = `<span style='color: gray'>unnamed</span> - (${c.x}, ${c.y})`;
      }
    });
    this.nodeTab.newGroup();
    this.nodeTab.addLinkedInput(
      "Color",
      "selected.color",
      "text",
      "selected.c"
    );
    this.nodeTab.addLinkedInput(
      "Size",
      "selected.size",
      "number",
      "selected.c"
    );
    this.nodeTab.addButton(
      "Delete class",
      () => {
        this.sseq.startMutationTracking();
        this.sseq.deleteClass(this.selected.c);
        this.sseq.addMutationsToUndoStack();
        this.sidebar.showPanel(this.generalPanel);
      },
      { style: "danger" }
    );
    this.classPanel.addTab("Node", this.nodeTab);
    this.differentialTab = new DifferentialPanel(
      this.classPanel.container,
      this
    );
    Mousetrap3.bind("d", () => this.state = STATE_ADD_DIFFERENTIAL2);
    Mousetrap3.bind("r", () => this.state = STATE_RM_EDGE);
    this.classPanel.addTab("Diff", this.differentialTab);
    this.structlineTab = new StructlinePanel(
      this.classPanel.container,
      this
    );
    Mousetrap3.bind("s", () => this.state = STATE_ADD_STRUCTLINE2);
    this.classPanel.addTab("Struct", this.structlineTab);
    this.sidebar.showPanel(this.generalPanel);
    this.tooltip = new Tooltip(this);
    this.on("mouseover", (node) => {
      this.tooltip.setHTML(`(${node.c.x}, ${node.c.y})`);
      this.tooltip.show(node.canvas_x, node.canvas_y);
    });
    this.on("mouseout", this._onMouseout.bind(this));
    this.on("click", this.__onClick.bind(this));
    this._onDifferentialAdded = this._onDifferentialAdded.bind(this);
    Mousetrap3.bind("left", this.previousPage);
    Mousetrap3.bind("right", this.nextPage);
    Mousetrap3.bind("x", () => {
      if (this.selected) {
        console.log(this.selected.c);
      }
    });
    if (sseq2) this.setSseq(sseq2);
  }
  setDifferentialColor(page, color3) {
    this.differentialColors[page] = color3;
  }
  setSseq(sseq2) {
    if (this.sseq)
      this.sseq.removeListener("differential-added", this._onDifferentialAdded);
    super.setSseq(sseq2);
    this.sidebar.showPanel(this.generalPanel);
    this.sseq.on("differential-added", this._onDifferentialAdded);
  }
  _onMouseout() {
    if (this.selected) this.selected.highlight = true;
    this.tooltip.hide();
  }
  _unselect() {
    if (!this.selected) return;
    this.selected.highlight = false;
    this.selected = null;
    this.state = null;
    this.sidebar.showPanel(this.generalPanel);
    this._drawSseq(this.context);
  }
  __onClick(node, e) {
    if (this.state == STATE_ADD_CLASS) {
      let x = Math.round(this.xScale.invert(e.clientX));
      let y = Math.round(this.yScale.invert(e.clientY));
      this.sseq.undo.startMutationTracking();
      this.sseq.addClass(x, y);
      this.sseq.undo.addMutationsToUndoStack();
      this.state = null;
      return;
    }
    if (!node) {
      this._unselect();
      return;
    }
    if (!this.selected) {
      this._unselect();
      this.selected = node;
      this.sidebar.showPanel(this.classPanel);
      this.state = null;
      return;
    }
    let s = this.selected.c;
    let t = node.c;
    switch (this.state) {
      case STATE_ADD_DIFFERENTIAL2:
        if (s.x !== t.x + 1) {
          this._unselect();
          break;
        }
        let length = t.y - s.y;
        this.sseq.undo.startMutationTracking();
        this.sseq.addDifferential(s, t, length);
        this.sseq.undo.addMutationsToUndoStack();
        this.sidebar.showPanel();
        break;
      case STATE_RM_DIFFERENTIAL2:
        this.sseq.undo.startMutationTracking();
        for (let e3 of s.edges)
          if (e3.type === "Differential" && e3.target == t) sseq.deleteEdge(e3);
        this.sseq.undo.addMutationsToUndoStack();
        this.sidebar.showPanel();
        break;
      case STATE_ADD_STRUCTLINE2:
        this.sseq.undo.startMutationTracking();
        this.sseq.addStructline(s, t);
        this.sseq.undo.addMutationsToUndoStack();
        this.sidebar.showPanel();
        break;
      case STATE_RM_STRUCTLINE2:
        this.sseq.undo.startMutationTracking();
        for (let e3 of s.edges)
          if (e3.type === "Structline" && e3.target == t) sseq.deleteEdge(e3);
        this.sseq.undo.addMutationsToUndoStack();
        this.sidebar.showPanel();
        break;
      case STATE_RM_EDGE:
        this.sseq.undo.startMutationTracking();
        for (let e3 of s.edges) if (e3.target == t) sseq.deleteEdge(e3);
        this.sseq.undo.addMutationsToUndoStack();
        this.sidebar.showPanel();
        break;
      default:
        this._unselect();
        this.selected = node;
        this.sidebar.showPanel(this.classPanel);
        break;
    }
    this.state = null;
  }
  _onDifferentialAdded(d) {
    if (this.differentialColors[d.page])
      d.color = this.differentialColors[d.page];
  }
};

// src/ExportToTex.js
var ExportToTex_exports = {};
__export(ExportToTex_exports, {
  DownloadSpectralSequenceTex: () => DownloadSpectralSequenceTex,
  SpectralSequenceToTex: () => SpectralSequenceToTex
});
function SpectralSequenceToTex(sseq2, page, xmin, xmax2, ymin, ymax) {
  let [classes, edges] = sseq2.getDrawnElements(page, xmin, xmax2, ymin, ymax);
  let classStrings = [];
  let edgeStrings = [];
  let outputString = [];
  let colormap = /* @__PURE__ */ new Map();
  colormap.context = document.createElement("canvas").getContext("2d");
  for (let c of classes) {
    classStrings.push(latexClassString(c, page, colormap));
  }
  for (let edge of edges) {
    edgeStrings.push(latexEdgeString(edge, page, colormap));
  }
  outputString.push(getBeginString(page, xmin, xmax2, ymin, ymax));
  outputString.push(
    Array.from(
      colormap,
      (x) => `\\definecolor{${x[1][0]}}{RGB}{${x[1][1][0]},${x[1][1][1]},${x[1][1][2]}} % ${x[0]}`
    ).join("\n")
  );
  outputString.push(classStrings.join("\n"));
  outputString.push(edgeStrings.join("\n"));
  outputString.push("\\end{sseqpage}");
  return outputString.join("\n");
}
function DownloadSpectralSequenceTex(filename, sseq2, page, xmin, xmax2, ymin, ymax) {
  download2(
    filename,
    SpectralSequenceToTex(sseq2, page, xmin, xmax2, ymin, ymax)
  );
}
function getBeginString(page, xmin, xmax2, ymin, ymax) {
  return `\\begin{sseqpage}[degree = {-1}{#1}, x range = {${xmin}}{${xmax2}}, y range = {${ymin}}{${ymax}}]`;
}
function latexClassString(c, page, colormap) {
  let options = [];
  options.push(`name=${"id" + c.unique_id}`);
  let node = c.getNode(page);
  if (node.fill) options.push("fill");
  if (node.color) options.push(getTeXColor(node.color, colormap));
  return `\\class[${options.join(", ")}](${c.x},${c.y})`;
}
function latexEdgeString(edge, page, colormap) {
  let options = [];
  if (edge.color) options.push(getTeXColor(edge.color, colormap));
  switch (edge.type) {
    case "Structline":
      return `\\structline[${options.join(", ")}](${"id" + edge.source.unique_id})(${"id" + edge.target.unique_id})`;
      break;
    case "Differential":
      return `\\d[${options.join(", ")}]${page}(${"id" + edge.source.unique_id}, ${edge.target.idx + 1})`;
      break;
    default:
      break;
  }
}
function getTeXColor(color3, colormap) {
  if (!colormap.has(color3)) {
    colormap.context.fillStyle = "white";
    colormap.context.fillRect(0, 0, 1, 1);
    colormap.context.fillStyle = color3;
    colormap.context.fillRect(0, 0, 1, 1);
    colormap.set(color3, [
      randomString(10),
      colormap.context.getImageData(0, 0, 1, 1).data
    ]);
  }
  return colormap.get(color3)[0];
}
function randomChar() {
  return String.fromCharCode(Math.floor(Math.random() * 26) + 97);
}
function randomString(len) {
  let result = "";
  for (let i = 0; i < len; i++) result += randomChar();
  return result;
}

// src/main.js
var import_events4 = __toESM(require_events());

// src/SseqClass.js
var infinity3 = infinity2;
var Node = class _Node {
  constructor(obj) {
    this.opacity = 1;
    this.color = "black";
    this.scale = 1;
    if (obj) {
      Object.assign(this, obj);
    }
  }
  copy() {
    if (this.isDummy()) {
      return new _Node();
    }
    return Object.assign(new _Node(), this);
  }
  getShape() {
    return this.shape;
  }
  setShape(shape) {
    this.shape = shape;
    return this;
  }
  getColor() {
    return this.color;
  }
  setColor(color3) {
    this.color = color3;
    return this;
  }
  setFill(color3) {
    this.fill = color3;
    return this;
  }
  setStroke(color3) {
    this.stroke = color3;
    return this;
  }
  setOpacity(op) {
    this.opacity = op;
    return this;
  }
  isDummy() {
    return false;
  }
  setPosition(x, y, size) {
    this.canvas_x = x;
    this.canvas_y = y;
    this.size = size;
  }
  draw(context) {
    context.save();
    if (this.opacity) {
      context.opacity = this.opacity;
    }
    if (this.color) {
      context.fillStyle = this.color;
      context.strokeStyle = this.color;
    }
    if (this.stroke && this.stroke !== true) {
      context.strokeStyle = this.stroke;
    }
    if (this.fill && this.fill !== true) {
      context.fillStyle = this.fill;
    }
    if (this.highlight) {
      if (this.hcolor) {
        context.fillStyle = this.hcolor;
        context.strokeStyle = this.hcolor;
      }
      if (this.hstroke) {
        context.strokeStyle = this.hstroke;
      }
      if (this.hfill) {
        context.fillStyle = this.hfill;
      }
    }
    context.lineWidth = Math.min(3, this.size * this.scale / 20);
    this.path = this.shape.draw(
      context,
      this.canvas_x,
      this.canvas_y,
      this.size * this.scale,
      this
    );
    context.restore();
  }
  static getDummy() {
    if (_Node._dummy) {
      return _Node._dummy;
    }
    let dummy = new _Node();
    let chainableNoOp = getDummyConstantFunction(dummy);
    dummy.isDummy = function() {
      return true;
    };
    dummy.setShape = chainableNoOp;
    dummy.setColor = chainableNoOp;
  }
  /**
   * @param {...Node} nodes -- a list of nodes to merge. Merges them into a new object.
   * @returns {Node} -- a new node formed by merging the list of nodes passed as arguments. Later arguments have
   *    priority over earlier ones.
   */
  static merge(...nodes) {
    let root2 = new _Node();
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].isDummy && nodes[i].isDummy()) {
        continue;
      }
      for (var key in nodes[i]) {
        root2[key] = nodes[i][key];
      }
    }
    return root2;
  }
};
var unique_id = 0;
var SseqClass2 = class _SseqClass {
  /**
   * @param sseq The parent spectral sequence.
   * @package
   */
  constructor(sseq2, degree) {
    this.sseq = sseq2;
    this.degree = degree;
    this.projection = sseq2.projection(this);
    this.x = this.projection[0];
    this.y = this.projection[1];
    this.x_offset = false;
    this.y_offset = false;
    this.idx = 0;
    this.unique_id = unique_id++;
    this.edges = [];
    this.name = "";
    this.last_page_name = "";
    this.extra_info = "";
    this.differential_strings = [];
    this.page_list = [infinity3];
    this.node_list = [sseq2.default_node.copy()];
    this.visible = true;
    this._last_page = 0;
    this._last_page_idx = 0;
  }
  getMemento() {
    let res = copyFields({}, this);
    res.node_list = res.node_list.map((n) => new Node(n));
    res.node_list.forEach((n) => n.highlight = false);
    return res;
  }
  restoreFromMemento(memento) {
    if (memento.delete) {
      if (this.invalid) {
        return;
      }
      this.delete();
      return;
    }
    if (this.invalid) {
      this.revive();
    }
    let res = copyFields(this, memento);
    this.node_list = this.node_list.map((n) => n.copy());
    return this;
  }
  delete() {
    this.invalid = true;
    let idx = this.sseq.num_classes_by_degree.get([this.x, this.y]);
    this.sseq.num_classes_by_degree.set([this.x, this.y], idx - 1);
    this.sseq.total_classes--;
  }
  revive() {
    this.invalid = false;
    let idx = this.sseq.num_classes_by_degree.get([this.x, this.y]);
    this.sseq.num_classes_by_degree.set([this.x, this.y], idx + 1);
    this.sseq.total_classes++;
  }
  static getDummy() {
    if (_SseqClass._dummy) {
      return _SseqClass._dummy;
    }
    let dummy = Object.create(_SseqClass);
    _SseqClass._dummy = dummy;
    let chainableNoOp = getDummyConstantFunction(dummy);
    dummy.isDummy = getDummyConstantFunction(true);
    dummy.getName = getDummyConstantFunction("dummy");
    dummy.getColor = getDummyConstantFunction("black");
    dummy.getShape = getDummyConstantFunction(null);
    dummy.getTooltip = getDummyConstantFunction("");
    dummy.getPage = getDummyConstantFunction(-1);
    dummy.getNode = getDummyConstantFunction(Node.getDummy());
    dummy.toString = dummy.getName;
    dummy.constructor = _SseqClass.constructor;
    dummy.replace = chainableNoOp;
    dummy.addExtraInfo = chainableNoOp;
    dummy.isAlive = getDummyConstantFunction(false);
    for (let field of [
      "getEdges",
      "getDifferentials",
      "getIncomingDifferentials",
      "getOutgoingDifferentials",
      "getStructlines",
      "getIncomingStructlines",
      "getOutgoingStructlines",
      "getProducts",
      "getDivisors",
      "getExtensions"
    ]) {
      dummy[field] = getDummyConstantFunction([]);
    }
    dummy.getProductIfPresent = getDummyConstantFunction(dummy);
    dummy.getDivisorIfPresent = getDummyConstantFunction(dummy);
    dummy.getStringifyingMapKey = getDummyInvalidOperation(
      dummy,
      "getStringifyingMapKey"
    );
    setPrivateMethodsToInvalidOperation(dummy);
    setDummyMethods(
      dummy,
      (p) => p.startsWith("set"),
      () => chainableNoOp
    );
    checkAllCommandsDefined(dummy, _SseqClass);
    return dummy;
  }
  isDummy() {
    return false;
  }
  /* Public methods: */
  getName() {
    return this.name;
  }
  setName(name2) {
    this.name = name2;
    this.last_page_name = name2;
    return this;
  }
  getNameCoord() {
    let tooltip = "";
    if (this.name !== "") {
      tooltip = `\\(\\large ${this.name}\\)&nbsp;&mdash;&nbsp;`;
    }
    tooltip += `(${this.x}, ${this.y})`;
    return tooltip;
  }
  getNameCoordHTML() {
    return Interface.renderLatex(this.getNameCoord());
  }
  /**
   * @returns {int} The page this class dies on (or infinity if it lives forever).
   */
  getPage() {
    return this.page_list[this.page_list.length - 1];
  }
  setPage(page) {
    this.page_list[this.page_list.length - 1] = page;
    return this;
  }
  isAlive(page) {
    if (!page) {
      page = infinity3 - 1;
    }
    return this.getPage() > page;
  }
  /**
   * Get the node that controls the display of the class on the given page.
   * @param page
   * @returns {Node} The node that controls the display of this class on page `page`.
   */
  getNode(page) {
    const idx = this._getPageIndex(page);
    return this.node_list[idx];
  }
  /**
   * Sets the node that controls the display on the given page.
   * Properties that are missing from the given node are left unchanged.
   * @param {Node} node
   * @param {int} page
   * @returns {SseqClass} Chainable
   */
  setNode(node, page) {
    if (node === void 0) {
      node = {};
    }
    let pre = this.getMemento();
    const idx = this._getPageIndex(page);
    this.node_list[idx] = Node.merge(this.node_list[idx], node);
    let post = this.getMemento();
    this.sseq.addMutation(this, pre, post);
    return this;
  }
  getColor(page) {
    return this.getNode(page).getColor();
  }
  setColor(color3, page) {
    let pre = this.getMemento();
    this.getNode(page).setColor(color3);
    let post = this.getMemento();
    this.sseq.addMutation(this, pre, post);
    return this;
  }
  getShape(page) {
    return this.getNode(page).getShape();
  }
  setShape(shape, page) {
    let pre = this.getMemento();
    this.getNode(page).setShape(shape);
    let post = this.getMemento();
    this.sseq.addMutation(this, pre, post);
    return this;
  }
  /**
   * Set the page of every structline incident to this class. Structlines are not displayed on pages later than their
   * page.
   * @param page
   * @returns {SseqClass}
   */
  setStructlinePages(page) {
    let structlines = this.getStructlines();
    for (let i = 0; i < structlines.length; i++) {
      let sl = structlines[i];
      if (sl.page > page) {
        let pre = sl.getMemento();
        sl.page = page;
        let post = sl.getMemento();
        this.sseq.addMutation(sl, pre, post);
      }
    }
    return this;
  }
  /**
   * Replace a "dead" class.
   * @param node Control the way the display of the "replaced" class changes. If the node is undefined, no change
   *   in appearance will occur.
   * @returns {SseqClass}
   */
  replace(node, lastPageName) {
    let pre = this.getMemento();
    if (lastPageName) {
      if (typeof lastPageName === "string") {
        this.last_page_name = lastPageName;
      } else {
        this.last_page_name = lastPageName(this.name);
      }
    }
    this._appendPage(infinity3);
    this.setNode(node);
    let post = this.getMemento();
    this.sseq.addMutation(this, pre, post);
    return this;
  }
  /**
   * Adds a string to extra_info (in practice, this controls the tooltip for the class).
   * @param str
   * @returns {SseqClass} Chainable
   */
  addExtraInfo(str) {
    let pre = this.getMemento();
    this.extra_info += "\n" + str;
    let post = this.getMemento();
    this.sseq.addMutation(this, pre, post);
    return this;
  }
  setPermanentCycleInfo(str) {
    let pre = this.getMemento();
    this.permanent_cycle_info = str;
    this.addExtraInfo(this.permanent_cycle_info);
    let post = this.getMemento();
    this.sseq.addMutation(this, pre, post);
    return this;
  }
  getEdges() {
    return this.edges;
  }
  getDifferentials() {
    return this.edges.filter((e) => e.type === "Differential");
  }
  getOutgoingDifferentials() {
    return this.edges.filter(
      (e) => e.type === "Differential" && this === e.source
    );
  }
  getIncomingDifferentials() {
    return this.edges.filter(
      (e) => e.type === "Differential" && this === e.target
    );
  }
  getStructlines() {
    return this.edges.filter((e) => e.type === "Structline");
  }
  getOutgoingStructlines() {
    return this.edges.filter(
      (e) => e.type === "Structline" && this === e.source
    );
  }
  getIncomingStructlines() {
    return this.edges.filter(
      (e) => e.type === "Structline" && this === e.target
    );
  }
  getExtensions() {
    return this.edges.filter((e) => e.type === "Extension");
  }
  getProducts(variable) {
    let multiplications = this.edges.filter(
      (sl) => sl.type === "Structline" && sl.otherClass(this).y > this.y
    );
    if (variable) {
      multiplications = multiplications.filter((sl) => sl.mult === variable);
    }
    return multiplications;
  }
  getDivisors(variable) {
    let divisors = this.edges.filter(
      (sl) => sl.type === "Structline" && sl.otherClass(this).y < this.y
    );
    if (variable) {
      divisors = divisors.filter((sl) => sl.mult === variable);
    }
    return divisors;
  }
  getProductIfPresent(variable) {
    let products = this.getProducts(variable);
    if (products.length === 1) {
      return products[0].otherClass(this);
    } else {
      return _SseqClass.getDummy();
    }
  }
  getDivisorIfPresent(variable) {
    let products = this.getDivisors(variable);
    if (products.length === 1) {
      return products[0].otherClass(this);
    } else {
      return _SseqClass.getDummy();
    }
  }
  toString() {
    return this.name;
  }
  getStringifyingMapKey() {
    return this.x + "," + this.y + "," + this.idx;
  }
  /* Package / private methods: */
  /**
   * This gets the index of a specified page in the page list. What this means is that if the page list is of the
   * form [5, 9, infinity], this divides the pages into three intervals, [0,5], [6,9], and [10, infinity].
   * If page is in the range from 0 to 5, the pageIndex is zero, if it is in the range 6 to 9, the index is 1,
   * and in the range 10 to infinity, it is 2.
   *
   * If the page_list does not end in infinity and page is larger than the largest entry in page_list then this throws
   * an error.
   * @param {int} page
   * @returns {int} the index
   * @private
   */
  _getPageIndex(page) {
    if (page === void 0) {
      return this.page_list.length - 1;
    } else if (page === this._last_page) {
      return this._last_page_idx;
    }
    let page_idx;
    for (let i = 0; i < this.page_list.length; i++) {
      if (this.page_list[i] >= page) {
        page_idx = i;
        break;
      }
    }
    if (page_idx === void 0) {
      console.log(new Error("Page too large. This probably shouldn't happen."));
    }
    this._last_page = page;
    this._last_page_idx = page_idx;
    return page_idx;
  }
  /* Used by Sseq: */
  /**
   * Appends a page to the list of pages and sets the corresponding node to be the previous node.
   * @param {int} page The page to append. Really should always be infinity...
   * @returns {SseqClass} Chainable
   * @private
   */
  _appendPage(page) {
    this.page_list.push(page);
    this.node_list.push(this.node_list[this.node_list.length - 1].copy());
    return this;
  }
  /**
   * Add a structline to this class. Called by sseq.addStructline.
   * @param sl The
   * @package
   */
  _addStructline(sl) {
    this.edges.push(sl);
  }
  _addExtension(ext) {
    this.edges.push(ext);
  }
  /**
   * Adds an outgoing differential. Called by the sseq.addDifferential.
   * @param differential
   * @package
   */
  _addOutgoingDifferential(differential, set_page) {
    if (this.getPage() < differential.page) {
    }
    if (set_page) {
      this.setPage(differential.page);
    }
    this.edges.push(differential);
    this._updateDifferentialStrings();
  }
  /**
   * Adds an incoming differential. Called by the sseq.addDifferential.
   * @param differential
   * @package
   */
  _addIncomingDifferential(differential, set_page) {
    if (this.getPage() < differential.page) {
    }
    if (set_page) {
      this.setPage(differential.page);
    }
    this.edges.push(differential);
    this._updateDifferentialStrings();
  }
  _updateDifferentialStrings() {
    let differentials = this.getDifferentials().sort((a, b) => a.page > b.page);
    this.differential_strings = differentials.map(
      (d) => d.toString(d.source === this, d.target === this)
    );
  }
  /**
   * Determines whether this class is drawn on the given page.
   * @param page
   * @returns {boolean}
   * @package
   */
  _drawOnPageQ(page) {
    return this.page_list[this.page_list.length - 1] >= page && this.visible;
  }
  /**
   * Determines wither the class is in the given range.
   * @param xmin
   * @param xmax
   * @param ymin
   * @param ymax
   * @returns {boolean}
   * @package
   */
  _inRangeQ(xmin, xmax2, ymin, ymax) {
    return xmin <= this.x && this.x <= xmax2 && ymin <= this.y && this.y <= ymax;
  }
};

// src/Edges.js
var infinity4 = infinity2;
var Edge = class _Edge {
  /**
   * Add edge to source and target.
   * @param {SseqClass} source
   * @param {SseqClass} target
   */
  constructor(sseq2, source2, target) {
    if (source2.y > target.y) {
      let temp = source2;
      source2 = target;
      target = temp;
    }
    this.sseq = sseq2;
    this.source = source2;
    this.target = target;
    this.source_name = this.source.last_page_name;
    this.target_name = this.target.last_page_name;
    this.page = infinity4;
    this.page_min = 0;
    this.color = "#000";
    this.type = this.constructor.name;
    this.visible = true;
    this.args = [];
  }
  getMemento() {
    return copyFields({}, this);
  }
  restoreFromMemento(memento) {
    if (memento.delete) {
      if (this.invalid) {
        return;
      }
      this.delete();
      return;
    }
    if (this.invalid) {
      this.revive();
    }
    copyFields(this, memento);
    return this;
  }
  otherClass(c) {
    if (this.source === c) {
      return this.target;
    } else if (this.target === c) {
      return this.source;
    } else {
      console.log("Invalid class");
    }
  }
  setMinPage(min_page) {
    this.page_min = min_page;
    return this;
  }
  setColor(color3) {
    if (!color3) {
      return this;
    }
    this.color = color3;
    return this;
  }
  setBend(bend) {
    if (!bend) {
      return this;
    }
    this.bend = bend;
    return this;
  }
  isDummy() {
    return false;
  }
  // TODO: Should these methods even be here? I guess so....
  delete() {
    this.invalid = true;
    this.source.edges = this.source.edges.filter((e) => !e.invalid);
    this.target.edges = this.target.edges.filter((e) => !e.invalid);
  }
  revive() {
    this.invalid = false;
    this.source.edges.push(this);
    this.target.edges.push(this);
  }
  static getDummy() {
    if (_Edge._dummy) {
      return _Edge._dummy;
    }
    let dummy = Object.create(_Edge);
    _Edge._dummy = dummy;
    dummy.isDummy = () => true;
    setPrivateMethodsToInvalidOperation(dummy);
    dummy.setMinPage = getDummyConstantFunction(dummy);
    dummy.constructor = _Edge.constructor;
    dummy.otherClass = getDummyConstantFunction(SseqClass.getDummy());
    dummy.leibniz = getDummyConstantFunction(dummy);
    dummy.delete = () => true;
    dummy.setColor = getDummyConstantFunction(dummy);
    checkAllCommandsDefined(dummy);
    return dummy;
  }
  leibniz(multiplications) {
    for (let variable of multiplications) {
      let source2 = this.source.getProductIfPresent(variable);
      let target = this.target.getProductIfPresent(variable);
      this.sseq["add" + this.constructor.name](
        source2,
        target,
        ...this.args
      ).leibniz(multiplications);
    }
    return this;
  }
  /**
   * Determine whether the edge is drawn on the given page. Overridden in subclasses.
   * @param pageRange
   * @returns {boolean}
   * @package
   */
  _drawOnPageQ(pageRange) {
    return pageRange[0] <= this.page && this.page_min <= pageRange[0];
  }
};
var Structline = class extends Edge {
  setProduct(variable) {
    this.mult = variable;
    return this;
  }
};
var Extension = class extends Edge {
  _drawOnPageQ(pageRange) {
    return pageRange[0] === infinity4;
  }
  setProduct(variable) {
    this.mult = variable;
    return this;
  }
};
var Differential = class _Differential extends Edge {
  constructor(sseq2, source2, target, page) {
    super(sseq2, source2, target);
    this.page = page;
    this.color = "#00F";
    this.args = [page];
  }
  leibniz(multiplications) {
    for (let variable of multiplications) {
      let source2 = this.source.getProductIfPresent(variable);
      let target = this.target.getProductIfPresent(variable);
      if (source2.isDummy() || target.isDummy()) {
        continue;
      }
      if (source2.page_list[source2.page_list.length - 1] < infinity4 || target.page_list[target.page_list.length - 1] < infinity4) {
        continue;
      }
      this.sseq["add" + this.constructor.name](
        source2,
        target,
        ...this.args
      ).leibniz(multiplications);
    }
    return this;
  }
  static getDummy() {
    if (_Differential._dummy) {
      return _Differential._dummy;
    }
    let dummy = Object.create(_Differential);
    _Differential._dummy = dummy;
    let edgeDummy = Edge.getDummy();
    Object.assign(dummy, edgeDummy);
    let chainableNoOp = getDummyConstantFunction(dummy);
    setRemainingMethods(
      dummy,
      () => true,
      () => chainableNoOp
    );
    setPrivateMethodsToInvalidOperation(dummy);
    dummy.toString = getDummyConstantFunction("");
    return dummy;
  }
  delete() {
    let pop_pagelists = [];
    if (this.source.page_list.length !== 1 && this.source.page_list.indexOf(this.page) === this.source.page_list.length - 2 && this.source.page_list[this.source.page_list.length - 1] === infinity4) {
      pop_pagelists.push(() => this.source.page_list.pop());
    }
    if (this.target.page_list.length !== 1 && this.target.page_list.indexOf(this.page) === this.target.page_list.length - 2 && this.target.page_list[this.target.page_list.length - 1] === infinity4) {
      pop_pagelists.push(() => this.target.page_list.pop());
    }
    this.revive_source_page_list = this.source.page_list.slice();
    this.revive_target_page_list = this.target.page_list.slice();
    pop_pagelists.forEach((f) => f());
    if (this.source.page_list.indexOf(this.page) !== -1) {
      this.source.page_list[this.source.page_list.length - 1] = infinity4;
    }
    if (this.target.page_list.indexOf(this.page) !== -1) {
      this.target.page_list[this.target.page_list.length - 1] = infinity4;
    }
    Edge.prototype.delete.call(this);
    return true;
  }
  revive() {
    this.source.page_list = this.revive_source_page_list.slice();
    this.target.page_list = this.revive_target_page_list.slice();
    Edge.prototype.revive.call(this);
  }
  /**
   * @override
   * @param min_page
   */
  setMinPage(min_page) {
    throw "Unsupported operation";
  }
  /**
   * By default, source of differential disappears after the page the differential occurs on. Instead, from now on
   * display the source using `node`.
   * @param {Node} node Specifies any changes in the display of source that occur after this page.
   * @returns {Differential} Chainable
   */
  setKernel(node, lastPageName) {
    this.source.replace(node, lastPageName);
    return this;
  }
  /**
   * Synonym for setKernel.
   * @param {Node} node
   * @returns {Differential} Chainable
   */
  replaceSource(node, lastPageName) {
    this.setKernel(node, lastPageName);
    return this;
  }
  /**
   * By default, target of differential disappears after the page the differential occurs on. Instead, from now on
   * display the target using `node`.
   * @param {Node} node Specifies any changes in the display of target that occur after this page.
   * @returns {Differential} Chainable
   */
  setCokernel(node, lastPageName) {
    this.target.replace(node, lastPageName);
    return this;
  }
  /**
   * Synonym for setCokernel.
   * @param {Node} node
   * @returns {Differential} Chainable
   */
  replaceTarget(node, lastPageName) {
    this.setCokernel(node, lastPageName);
    return this;
  }
  /**
   * Sets the name of the target for use in determining the name of the differential. By default the target_name
   * is the name of the target class, but particularly if there is a cokernel it should potentially be something else
   * for instance, if the differential is multiplication by p, the target class might be named `x` but the target
   * should be `px`.
   * @param name
   * @returns {Differential} chainable
   */
  setTargetName(name2) {
    this.target_name = name2;
    return this;
  }
  /**
   * I don't know if this is useful, just included for symmetry with setTargetName.
   * @param name
   * @returns {Differential} chainable
   */
  setSourceName(name2) {
    this.source_name = name2;
    return this;
  }
  //    hitMessage(){
  //        return "hit on page %d by class %r" % (this.page, this.source);
  //    }
  //
  //    supportedMessage(){
  //        return "supported a differential on page %d hitting class %r" % (this.page, this.target);
  //    }
  addInfoToSource() {
    this.source.addExtraInfo(this.toString(true, false));
    return this;
  }
  addInfoToTarget() {
    this.target.addExtraInfo(this.toString(false, true));
    return this;
  }
  /**
   * Adds the name of this differntial to the extra_info for the source and target class (so that it gets displayed
   * in a tooltip). Maybe we should do this by default?
   * @returns {Differential} chainable
   */
  addInfoToSourceAndTarget() {
    this.source.addExtraInfo(this.toString(true, false));
    this.target.addExtraInfo(this.toString(false, true));
    return this;
  }
  /**
   * By default, if we use "replace" on the source class (or replaceSource, setKernel), any structlines will continue to be drawn.
   * If that's inappropriate, call this to kill the structlines connecting to the source after this page.
   * @returns {Differential} chainable
   */
  setSourceStructlinePages() {
    this.source.setStructlinePages(this.page);
    return this;
  }
  /**
   * By default, if we use "replace" on the target class (or replaceTarget, setCokernel), any structlines will continue to be drawn.
   * If that's inappropriate, call this to kill the structlines connecting to the target after this page.
   * @returns {Differential} chainable
   */
  setTargetStructlinePages() {
    this.target.setStructlinePages(this.page);
    return this;
  }
  /**
   * Does both setSourceStructlinePages and setTargetStructlinePages
   * @returns {Differential} chainable
   */
  setStructlinePages() {
    let res1 = this.source.setStructlinePages(this.page);
    let res2 = this.target.setStructlinePages(this.page);
    return this;
  }
  toString(highlight_source, highlight_target) {
    let source2 = this.source_name;
    if (!source2) {
      source2 = this.source.name;
    }
    let target = this.target_name;
    if (!target) {
      target = this.target.name;
    }
    if (highlight_source) {
      source2 = `{\\color{blue}{${source2}}}`;
    }
    if (highlight_target) {
      target = `{\\color{blue}{${target}}}`;
    }
    return `\\(d_{${this.page}}(${source2}) = ${target}\\)`;
  }
  /**
   * Draw the differential on "page 0" or on the page corresponding to the differential.
   * @param page
   * @returns {boolean}
   * @package
   * @override
   */
  _drawOnPageQ(pageRange) {
    return pageRange[0] === 0 || pageRange[0] <= this.page && this.page <= pageRange[1];
  }
};

// src/StringifyingMap.js
function stdCatToString(x) {
  if (x === void 0) {
    return void 0;
  }
  if ("getStringifyingMapKey" in x) {
    return x.getStringifyingMapKey();
  } else {
    return x.toString();
  }
}
var StringifyingMap2 = class {
  constructor(catToString) {
    if (catToString === void 0) {
      catToString = stdCatToString;
    }
    this.catToString = catToString;
    this.m = /* @__PURE__ */ new Map();
    this.key_string_to_key_object = /* @__PURE__ */ new Map();
  }
  set(k, v) {
    let key_string = this.catToString(k);
    if (key_string === void 0) {
      throw new Error("Key encoding undefined.");
    }
    this.key_string_to_key_object.set(key_string, k);
    let s = this.m.set(key_string, v);
    return s;
  }
  get(k) {
    let key_string = this.catToString(k);
    if (key_string === void 0) {
      return void 0;
    }
    return this.m.get(this.catToString(k));
  }
  delete(k) {
    this.key_string_to_key_object.delete(this.catToString(k));
    return this.m.delete(this.catToString(k));
  }
  has(k) {
    if (k === void 0) {
      return false;
    }
    return this.m.has(this.catToString(k));
  }
  getOrElse(key, value) {
    return this.has(key) ? this.get(key) : value;
  }
  *[Symbol.iterator]() {
    for (let k of this.m) {
      yield [this.key_string_to_key_object.get(k[0]), k[1]];
    }
  }
  keys() {
    return this.key_string_to_key_object.values();
  }
  toJSON() {
    return [...this];
  }
  get size() {
    return this.m.size;
  }
};

// src/monomial_basis.js
function range(start2, stop, step = 1) {
  if (arguments.length === 1) {
    start2 = 1;
    stop = arguments[0];
    step = 1;
  }
  return Array(Math.ceil((stop - start2 + step) / step)).fill(start2).map((x, y) => x + y * step);
}
function product() {
  const args = Array.prototype.slice.call(arguments);
  return args.reduce(
    function tl(accumulator, value) {
      const tmp = [];
      accumulator.forEach(function(a0) {
        value.forEach(function(a1) {
          tmp.push(a0.concat(a1));
        });
      });
      return tmp;
    },
    [[]]
  );
}
function convert_exponent_map_to_vector(var_list, exponent_map) {
  return var_list.map((v) => {
    if (exponent_map.hasOwnProperty(v)) {
      return exponent_map[v];
    } else {
      return 0;
    }
  });
}
function monomialString(vars, exponents, module_generator = "") {
  let out = [];
  out[0] = module_generator;
  if (!Array.isArray(exponents)) {
    exponents = convert_exponent_map_to_vector(vars, exponents);
  }
  for (let i = 0; i < vars.length; i++) {
    let exponent = exponents[i];
    if (exponent === 0) {
      out[i + 1] = "";
    } else if (exponent === 1) {
      out[i + 1] = vars[i];
    } else {
      out[i + 1] = `${vars[i]}^{${exponent}}`;
    }
  }
  let outStr = out.filter((s) => s !== "").join(" ");
  if (outStr === "") {
    outStr = "1";
  }
  return outStr;
}
function vectorSum(k) {
  let out = [];
  for (let i = 0; i < k.length; i++) {
    let entry = 0;
    for (let l of arguments) {
      entry += l[i];
    }
    out.push(entry);
  }
  return out;
}
function dictionaryVectorSum() {
  let out = {};
  for (let l of arguments) {
    for (let [k, v] of Object.entries(l)) {
      let entry = out[k] || 0;
      entry += v;
      out[k] = entry;
    }
  }
  return out;
}
function vectorScale(c, v) {
  return v.map((x) => c * x);
}
function dictionaryVectorScale(c, vector) {
  let result = {};
  for (let [k, v] of Object.entries(vector)) {
    result[k] = c * v;
  }
  return result;
}
function vectorLinearCombination(vector_list, coefficient_list) {
  let scaled_list = [];
  for (let i = 0; i < vector_list.length; i++) {
    scaled_list.push(vectorScale(coefficient_list[i], vector_list[i]));
  }
  return vectorSum(...scaled_list);
}
function dictionaryVectorLinearCombination(vector_list, coefficient_list) {
  let scaled_list = [];
  for (let i = 0; i < vector_list.length; i++) {
    scaled_list.push(
      dictionaryVectorScale(coefficient_list[i], vector_list[i])
    );
  }
  return dictionaryVectorSum(...scaled_list);
}
var monomial_ring = class {
  constructor(var_list, var_name_list, var_degree_dict, module_generators_dict) {
    this._var_degree_dict = var_degree_dict;
    this._var_list = var_list;
    this._var_name_list = var_name_list;
    this._var_degree_list = this._var_list.map((v) => this._var_degree_dict[v]);
    this._module_generators_dict = module_generators_dict;
  }
  addModuleGenerator(name2, bidegree) {
    this._module_generators_dict[name2] = bidegree;
  }
  _exponent_map_to_vector(var_powers_dict) {
    return convert_exponent_map_to_vector(this._var_list, var_powers_dict);
  }
  getElement(var_powers_dict, module_generator = "") {
    let exponent_vector;
    if (Array.isArray(var_powers_dict)) {
      exponent_vector = var_powers_dict;
    } else if (typeof var_powers_dict === "string") {
      let temp_map = new Object();
      temp_map[var_powers_dict] = 1;
      exponent_vector = convert_exponent_map_to_vector(
        this._var_name_list,
        temp_map
      );
    } else {
      let variables = Object.keys(var_powers_dict);
      for (let v of variables) {
        if (!this._var_degree_dict.hasOwnProperty(v)) {
          throw new Error(`Invalid variable ${v}`);
        }
      }
      exponent_vector = convert_exponent_map_to_vector(
        this._var_name_list,
        var_powers_dict
      );
    }
    return this.getElementFromVector(exponent_vector, module_generator);
  }
  getElementFromVector(exponent_vector, module_generator = "") {
    if (module_generator !== "" && !this._module_generators_dict.hasOwnProperty(module_generator)) {
      throw new Error(`Invalid module generator ${module_generator}`);
    }
    if (exponent_vector.length != this._var_name_list.length) {
      throw new Error(
        `Exponent vector ${exponent_vector} should have length ${this._var_name_list.length}, has length ${exponent_vector.length}`
      );
    }
    return new monomial_element(this, exponent_vector, module_generator);
  }
};
var monomial_element = class _monomial_element {
  constructor(ring, exponent_vector, module_generator = "") {
    this._ring = ring;
    this.exponent_vector = exponent_vector;
    this._module_generator = module_generator;
    for (let i = 0; i < exponent_vector.length; i++) {
      this[i] = exponent_vector[i];
    }
  }
  _initializeDegree() {
    let stem_degree = 0;
    let filtration = 0;
    if (this._module_generator !== "") {
      stem_degree += this._ring._module_generators_dict[this._module_generator][0];
      filtration += this._ring._module_generators_dict[this._module_generator][1];
    }
    for (let i = 0; i < this.exponent_vector.length; i++) {
      stem_degree += this._ring._var_degree_list[i][0] * this.exponent_vector[i];
      filtration += this._ring._var_degree_list[i][1] * this.exponent_vector[i];
    }
    this._degree = [stem_degree, filtration];
  }
  getName() {
    if (!this._name) {
      this._name = monomialString(
        this._ring._var_name_list,
        this.exponent_vector,
        this._module_generator
      );
    }
    return this._name;
  }
  getDegree() {
    if (!this._degree) {
      this._initializeDegree();
    }
    return this._degree;
  }
  multiply(elt) {
    if (this._ring !== elt._ring) {
      throw new Error("Cannot multiply elements from different rings.");
    }
    if (this._module_generator !== "" && elt._module_generator !== "") {
      throw new Error(
        "Cannot multiply two module elements, only a module element by a ring element."
      );
    }
    let module_generator = this._module_generator || elt._module_generator;
    let exponent_vector = vectorSum(this.exponent_vector, elt.exponent_vector);
    return new _monomial_element(this._ring, exponent_vector, module_generator);
  }
  getStringifyingMapKey() {
    return this._module_generator + this.exponent_vector.toString();
  }
  toJSON() {
    let result = Object.assign({}, this);
    result._ring = void 0;
    return result;
  }
  toString() {
    return this.getName();
  }
};
var monomial_basis = class _monomial_basis {
  /**
   * Construct a monomial_basis.
   * @param sseq Parent spectral sequence.
   * @param variable_list The list of variable names in the order that they are referred to by vectors.
   * @private
   */
  constructor(sseq2, var_degree_dict, var_spec_list, module_generators_dict) {
    this.sseq = sseq2;
    this._tuples_to_classes = new StringifyingMap2();
    this._tuples_to_ids = new StringifyingMap2();
    this._strings_to_classes = /* @__PURE__ */ new Map();
    this._tuples_to_strings = new StringifyingMap2();
    this._strings_to_tuples = /* @__PURE__ */ new Map();
    this._structlines = [];
    this.length = 0;
    if (!var_spec_list) {
      this._fromSerializedMonomialBasis(sseq2, var_degree_dict);
      return;
    }
    this.var_degree_dict = var_degree_dict;
    this.var_spec_list = var_spec_list;
    this.module_generators_dict = {};
    this.module_generators = [];
    let var_name_list = [];
    let stem_list = [];
    let filtration_list = [];
    let range_list = [];
    for (let i = 0; i < var_spec_list.length; i++) {
      let var_spec = var_spec_list[i];
      let var_name = var_spec[0];
      _monomial_basis._validateVarSpec(var_spec, var_degree_dict, i);
      var_name_list.push(var_name);
      stem_list.push(var_degree_dict[var_name][0]);
      filtration_list.push(var_degree_dict[var_name][1]);
      range_list.push(range(...var_spec.slice(1)));
    }
    this._stem_list = stem_list;
    this._filtration_list = filtration_list;
    this._range_list = range_list;
    this._ring = new monomial_ring(
      var_name_list,
      var_name_list,
      var_degree_dict,
      {}
    );
    for (let kv of Object.entries(module_generators_dict)) {
      let name2 = kv[0];
      let bidegree = kv[1];
      this.addModuleGenerator(name2, bidegree);
    }
    this.sseq.emit("update");
  }
  addModuleGenerator(gen_name, bidegree, callback) {
    this.module_generators_dict[gen_name] = bidegree;
    this.module_generators.push(gen_name);
    this._ring.addModuleGenerator(gen_name, bidegree);
    let l = product(...this._range_list);
    for (let i = 0; i < l.length; i++) {
      let exponent_vector = l[i];
      let elt = this._ring.getElementFromVector(exponent_vector, gen_name);
      let degree = elt.getDegree();
      let stem = degree[0];
      let filtration = degree[1];
      let name2 = elt.getName();
      if (this.sseq.xRange && this.sseq.drop_out_of_range_classes) {
        if (stem < this.sseq.xRange[0] - 10 || stem > this.sseq.xRange[1] + 10) {
          console.log("dropped");
          continue;
        }
      }
      if (this.sseq.yRange && this.sseq.drop_out_of_range_classes) {
        if (stem < this.sseq.yRange[0] - 10 || stem > this.sseq.yRange[1] + 10) {
          continue;
        }
      }
      if (this.sseq.yRange && this.sseq.max_differential_length) {
        if (filtration > this.sseq.yRange[1] + this.sseq.max_differential_length || filtration < this.sseq.yRange[0]) {
          continue;
        }
      }
      let c = this.sseq.addClass(stem, filtration).setName(name2);
      this._add_class(elt, c);
      c.module_generator = gen_name;
      if (callback) {
        callback(c);
      }
    }
    for (let sl of this._structlines) {
      for (let i = 0; i < l.length; i++) {
        let exponent_vector = l[i];
        let v = this._ring.getElementFromVector(exponent_vector, gen_name);
        let c1 = this.get(v);
        let c2 = this.get(v.multiply(sl.offset));
        if (c2 !== void 0) {
          let sline = this.sseq.addStructline(c1, c2);
          if (sl.callback) {
            sl.callback(sline);
          }
        }
      }
    }
    this.sseq.emit("update");
  }
  _fromSerializedMonomialBasis(sseq2, obj) {
    let classes_by_uid = /* @__PURE__ */ new Map();
    for (let c of sseq2.getClasses()) {
      classes_by_uid.set(c.unique_id, c);
    }
    this.var_degree_dict = obj.var_degree_dict;
    this.var_spec_list = obj.var_spec_list;
    this.module_generators_dict = obj.module_generators_dict;
    this.module_generators = Object.keys(obj.module_generators_dict);
    let var_name_list = this.var_spec_list.map((l) => l[0]);
    this._ring = new monomial_ring(
      var_name_list,
      var_name_list,
      this.var_degree_dict,
      this.module_generators_dict
    );
    for (let kv of obj._tuples_to_ids) {
      let k = kv[0];
      let c = kv[1];
      let elt = this._ring.getElementFromVector(
        k.exponent_vector,
        k._module_generator
      );
      this._add_class(elt, classes_by_uid.get(c));
    }
  }
  toJSON() {
    let o = {};
    o.var_degree_dict = this.var_degree_dict;
    o.var_spec_list = this.var_spec_list;
    o.module_generators_dict = this.module_generators_dict;
    o._tuples_to_ids = this._tuples_to_ids;
    return o;
  }
  /**
   * Add a class to the basis.
   * @param tuple The vector of powers of each variable in the monomial
   * @param name The name of the class.
   * @param the_class The class
   * @private
   */
  _add_class(elt, the_class) {
    this.length++;
    let name2 = elt.getName();
    this._tuples_to_classes.set(elt, the_class);
    this._strings_to_classes.set(name2, the_class);
    this._tuples_to_strings.set(elt, name2);
    this._strings_to_tuples.set(name2, elt);
    this._tuples_to_ids.set(elt, the_class.unique_id);
    the_class.vector = elt;
    the_class.vector.length = this.var_spec_list.length;
  }
  /**
   * If the argument is already an array, do nothing. If it's a map, apply _monomial_map_to_vect to it. If it's a
   * string look it up in _strings_to_classes.
   * @param vect
   * @returns {Array|int} The offset vector
   * @private
   */
  _ensure_vect(vect) {
    if (!Array.isArray(vect)) {
      if (typeof vect === "string") {
        if (!this._strings_to_classes.has(vect)) {
          throw new Error("Invalid variable name");
        } else {
          vect = this._strings_to_tuples.get(vect);
        }
      } else {
        vect = this._ring._exponent_map_to_vector(vect);
      }
    }
    return vect;
  }
  /*
   * Add structlines to every monomial corresponding to the given offset vector.
   * For instance, if there is a generator called
   */
  addStructline(offset_vector, callback) {
    offset_vector = this._ring.getElement(offset_vector);
    for (let k of this) {
      let c1 = k[1];
      let c2 = this.get(k[0].multiply(offset_vector));
      if (c2 !== void 0) {
        let sline = this.sseq.addStructline(c1, c2);
        if (callback) {
          callback(sline);
        }
      }
    }
    this._structlines.push({ offset: offset_vector, callback });
    this.sseq.emit("update");
    return this;
  }
  /**
   * Add differentials to monomials.
   * @param page The page of the differential
   * @param target_vect The differential is effectively of the form d(x) = r*x where r is specified by target_vect.
   *        This can either be of the form `[first_var_power, ..., last_var_power]` or of the form `{ "var_name" : var_power }`
   * @param cond A conditional used to determine whether to place a differential coming off of this particular source.
   * @param callback A callback called on each resulting differential.
   * @returns {monomial_basis} Chainable
   */
  addDifferential(page, target_vect, cond, callback) {
    target_vect = this._ring.getElement(target_vect);
    for (let key_value of this) {
      let k = key_value[0];
      let c1 = key_value[1];
      let c2 = this.get(key_value[0].multiply(target_vect));
      if (cond(k)) {
        if (c2) {
          let d = this.sseq.addDifferential(c1, c2, page);
          if (callback !== void 0) {
            callback(d, k);
          }
        } else {
          if (c1.getPage() > page) {
            c1.setPage(page);
          }
        }
      }
    }
    return this;
  }
  // These are immutable map methods.
  has(key) {
    if (this._strings_to_classes.has(key)) return true;
    key = this._ensure_vect(key);
    return this._tuples_to_classes.has(key);
  }
  get(key, default_value) {
    if (this._strings_to_classes.has(key)) {
      return this._strings_to_classes.get(key);
    }
    if (this._tuples_to_classes.has(key)) {
      return this._tuples_to_classes.get(key);
    }
    try {
      key = this._ring.getElement(key);
      if (this._tuples_to_classes.has(key)) {
        return this._tuples_to_classes.get(key);
      }
    } catch (error) {
    }
    return default_value;
  }
  static _validateVarSpec(var_spec, var_degree_dict, index) {
    let err_string = "Invalid variable specification '" + var_spec + "' at position " + index + ".";
    if (!Array.isArray(var_spec)) {
      throw err_string + " Variable specification must be a list.";
    }
    if (var_spec.length < 2 || var_spec.length > 4) {
      throw err_string + " Variable specification should be of length at least 2 and at most 4.";
    }
    if (typeof var_spec[0] !== "string") {
      throw err_string + " First entry of variable specification should be a string, the name of a variable.";
    }
    if (!var_degree_dict.hasOwnProperty(var_spec[0])) {
      throw err_string + " Variable '" + var_spec[0] + "' does not have an entry in the degree dictionary";
    }
    for (let i = 1; i < var_spec.length; i++) {
      if (!Number.isInteger(var_spec[i])) {
        throw err_string + " Expecting an integer in position '" + i + "'.";
      }
    }
  }
};
monomial_basis.prototype[Symbol.iterator] = function* () {
  for (let k of this._tuples_to_classes) {
    yield k;
  }
};
var slice_basis = class {
  constructor(sseq2, var_degree_dict, var_spec_list, make_slice) {
    this.sseq = sseq2;
    this._tuples_to_slices = new StringifyingMap2();
    this.length = 0;
    this.var_degree_dict = var_degree_dict;
    this.var_spec_list = var_spec_list;
    let var_list = [];
    let var_name_list = [];
    let stem_list = [];
    let range_list = [];
    for (let i = 0; i < var_spec_list.length; i++) {
      let var_spec = var_spec_list[i];
      let var_name = var_spec[0];
      monomial_basis._validateVarSpec(var_spec, var_degree_dict, i);
      var_list.push(var_name);
      if (var_degree_dict[var_name].name) {
        var_name_list.push(var_degree_dict[var_name].name);
      } else {
        var_name_list.push(var_name);
      }
      stem_list.push(var_degree_dict[var_name].degree);
      range_list.push(range(...var_spec.slice(1)));
    }
    this._stem_list = stem_list;
    this._range_list = range_list;
    let var_degree_dict_with_zeroes = Object.assign(
      {},
      ...Object.keys(var_degree_dict).map((k) => ({
        [k]: [var_degree_dict[k], 0]
      }))
    );
    this._ring = new monomial_ring(
      var_list,
      var_name_list,
      var_degree_dict_with_zeroes
    );
    for (let exponent_vector of product(...range_list)) {
      let elt = this._ring.getElementFromVector(exponent_vector);
      let degree = elt.getDegree()[0];
      let name2 = elt.getName();
      this._add_slice(elt, make_slice);
    }
  }
  /**
   * Add a class to the basis.
   * @param tuple The vector of powers of each variable in the monomial
   * @param name The name of the class.
   * @param the_class The class
   * @private
   */
  _add_slice(elt, make_slice) {
    this.length++;
    let tuple = elt.exponent_vector;
    let name2 = elt.getName();
    this._tuples_to_slices.set(elt, make_slice(this.sseq, elt));
  }
  /*
   * Add structlines to every monomial corresponding to the given offset vector.
   * For instance, if there is a generator called
   */
  addStructline(slice_offset_vector, stem_offset, callback) {
    slice_offset_vector = this._ring.getElement(slice_offset_vector);
    for (let k of this) {
      let s1 = k[1];
      let s2 = this.get(k[0].multiply(slice_offset_vector));
      if (s2 !== void 0) {
        for (let stem of Object.keys(s1)) {
          if (s2.hasOwnProperty(stem + stem_offset)) {
            let sline = this.sseq.addStructline(
              s1.get(stem),
              s2.get(stem + stem_offset)
            );
            if (callback) {
              callback(sline);
            }
          }
        }
      }
    }
    return this;
  }
  addDifferential(page, slice_offset_vector, cond, callback) {
    let target_vect = this._ring.getElement(slice_offset_vector);
    for (let key_value of this) {
      let k = key_value[0];
      let s1 = key_value[1];
      let s2 = this.get(k.multiply(target_vect));
      for (let key_value2 of s1) {
        let stem = key_value2[0];
        if (cond(k, stem, s1.get(stem).y)) {
          let c1 = s1.get(stem);
          if (s2 && s2.has(stem - 1)) {
            let d = this.sseq.addDifferential(c1, s2.get(stem - 1), page);
            if (callback !== void 0) {
              callback(d, k);
            }
          } else {
            if (!s2 && c1.getPage() > page) {
              c1.setPage(page);
            }
          }
        }
      }
    }
    return this;
  }
  addDifferentialLeibniz(page, source_slice, source_stem, target_slice, offset_vectors, offset_vector_ranges, callback) {
    source_slice = this._ensure_vect(source_slice);
    target_slice = this._ensure_vect(target_slice);
    for (let exponent_vector of product(
      ...offset_vector_ranges.map((r) => range(...r))
    )) {
      let offset_slice = vectorLinearCombination(
        offset_vectors,
        exponent_vector
      );
      let stem = offset_slice.pop() + source_stem;
      let cur_source_slice = vectorSum(source_slice, offset_slice);
      if (!this.has(cur_source_slice) || !this.get(cur_source_slice).has(stem)) {
        continue;
      }
      let sourceClass = this.get(cur_source_slice).get(stem);
      let cur_target_slice = vectorSum(target_slice, offset_slice);
      if (this.has(cur_target_slice) && this.get(cur_target_slice).has(stem - 1)) {
        let targetClass = this.get(cur_target_slice).get(stem - 1);
        let d = this.sseq.addDifferential(sourceClass, targetClass, page);
        if (callback !== void 0) {
          callback(d);
        }
      } else {
        if (!this.has(cur_target_slice) && sourceClass.getPage() > page) {
          sourceClass.setPage(page);
        }
      }
    }
  }
  has(key) {
    key = this._ensure_vect(key);
    return this._tuples_to_slices.has(key);
  }
  get(key, default_value) {
    if (this._tuples_to_slices.has(key)) {
      return this._tuples_to_slices.get(key);
    }
    try {
      key = this._ring.getElement(key);
      if (this._tuples_to_slices.has(key)) {
        return this._tuples_to_slices.get(key);
      }
    } catch (error) {
    }
    return default_value;
  }
};
slice_basis.prototype[Symbol.iterator] = function* () {
  for (let k of this._tuples_to_slices) {
    yield k;
  }
};
slice_basis.prototype._ensure_vect = monomial_basis.prototype._ensure_vect;

// src/Sseq.js
var import_events3 = __toESM(require_events());
var SseqClass3 = SseqClass2;
var Node2 = Node;
var Edge2 = Edge;
var Structline2 = Structline;
var Extension2 = Extension;
var Differential2 = Differential;
var monomial_basis2 = monomial_basis;
var slice_basis2 = slice_basis;
var infinity5 = infinity2;
var monomialString2 = monomialString;
var range2 = range;
var product2 = product;
var vectorSum2 = vectorSum;
var vectorScale2 = vectorScale;
var vectorLinearCombination2 = vectorLinearCombination;
var dictionaryVectorSum2 = dictionaryVectorSum;
var dictionaryVectorScale2 = dictionaryVectorScale;
var dictionaryVectorLinearCombination2 = dictionaryVectorLinearCombination;
function addToDictionaryOfLists(dictionary, key, value) {
  if (!dictionary.has(key)) {
    dictionary.set(key, []);
  }
  dictionary.get(key).push(value);
}
var Sseq = class _Sseq extends import_events3.default {
  /**
   * Make a spectral sequence object.
   * Key properties:
   *
   */
  constructor() {
    super();
    this.total_classes = 0;
    this.xRange = [0, 100];
    this.yRange = [0, 100];
    this.initialxRange = [0, 10];
    this.initialyRange = [0, 10];
    this.classes_by_degree = new StringifyingMap2();
    this.num_classes_by_degree = new StringifyingMap2();
    this.classes_by_stem = /* @__PURE__ */ new Map();
    this.classes = [];
    this.structlines = [];
    this.differentials = [];
    this.edges = [];
    this.xshift = 0;
    this.yshift = 0;
    this.offset_size = 0.3;
    this.min_class_size = 20;
    this.max_class_size = 60;
    this.class_scale = 1;
    this.min_page_idx = 0;
    this.page_list = [0, infinity5];
    this.default_node = new Node2();
    this.default_node.hcolor = "red";
    this.default_node.fill = true;
    this.default_node.stroke = true;
    this.default_node.shape = circle;
    this.default_node.size = 1;
    this.projection = (ssclass) => [ssclass.degree.x, ssclass.degree.y];
    this.stem_degree = (ssclass) => ssclass.degree.x;
    this.filtration_degree = (ssclass) => ssclass.degree.y;
    this.products = [];
    this.selectedClasses = [];
    this.serializeSseqFields = _Sseq.serializeSseqFields;
    this.serializeClassFields = _Sseq.serializeClassFields;
    this.serializeEdgeFields = _Sseq.serializeEdgeFields;
    this.serializeNodeFields = _Sseq.serializeNodeFields;
    this.undo = new Undo(this);
  }
  startMutationTracking() {
    this.undo.startMutationTracking();
  }
  addMutationsToUndoStack(event_obj) {
    this.undo.addMutationsToUndoStack(event_obj);
  }
  addMutation(obj, pre, post) {
    this.undo.addMutation(obj, pre, post);
  }
  set_shift(x, y) {
    this.xshift = x;
    this.yshift = y;
    return this;
  }
  get minX() {
    return this.xRange[0];
  }
  get minY() {
    return this.yRange[0];
  }
  get maxX() {
    return this.xRange[1];
  }
  get maxY() {
    return this.yRange[1];
  }
  set minX(x) {
    this.xRange[0] = parseInt(x);
  }
  set minY(y) {
    this.yRange[0] = parseInt(y);
  }
  set maxX(x) {
    this.xRange[1] = parseInt(x);
  }
  set maxY(y) {
    this.yRange[1] = parseInt(y);
  }
  add_to_shift(x, y) {
    this.xshift += x;
    this.yshift += y;
    return this;
  }
  getClasses() {
    return this.classes;
  }
  getEdges() {
    return this.edges;
  }
  getStructlines() {
    return this.structlines;
  }
  getDifferentials() {
    return this.differentials;
  }
  getStructlineTypes() {
    return new Set(this.structlines.map((x) => x.mult));
  }
  getSelection() {
  }
  clearSelection() {
    for (let c of this.classes) {
      c.selected = false;
    }
    this.emit("update");
    return this;
  }
  selectClass(c, selectOrUnselect = true) {
    if (!c) {
      return this;
    }
    c.selected = selectOrUnselect;
    return this;
  }
  unselectClass(c) {
    this.selectClass(c, false);
  }
  unselectAll() {
    for (let c of this.getClasses()) {
      c.selected = false;
    }
    this.emit("update");
  }
  getPotentialTargets(c) {
    let x = c.x - 1;
    return sseq.getClasses().filter((cl) => cl.x === x);
  }
  getClassesInDegree(x, y) {
    return this.classes.filter((c) => c.x === x && c.y === y);
  }
  getClassesByName(name2) {
    return this.classes.filter((c) => c.name === name2);
  }
  getOccupiedStems() {
    return Array.from(this.classes_by_degree.keys());
  }
  getStem(stem) {
    return this.classes_by_stem.get(stem) || [];
  }
  /**
   * Add a class in position (x,y) and return the class. Uses sseq.default_node for display.
   *
   * @param x The x position
   * @param y
   * @returns {SseqClass} The new class
   */
  addClass(x, y) {
    if (x === void 0) {
      return SseqClass3.getDummy();
    }
    let degree;
    if (y === void 0) {
      degree = x;
    } else {
      x = x + this.xshift;
      y = y + this.yshift;
      degree = { x, y };
    }
    let c = new SseqClass3(this, degree);
    let idx = this.num_classes_by_degree.getOrElse([c.x, c.y], 0);
    this.num_classes_by_degree.set([c.x, c.y], idx + 1);
    c.idx = idx;
    c.class_list_index = this.classes.length;
    this.classes.push(c);
    addToDictionaryOfLists(this.classes_by_degree, degree, c);
    addToDictionaryOfLists(this.classes_by_stem, c.x, c);
    this.total_classes++;
    this.emit("class-added", c);
    this.emit("update");
    this.addMutation(c, { delete: true }, c.getMemento());
    return c;
  }
  deleteClass(c) {
    this.addMutation(c, c.getMemento(), { delete: true });
    c.delete();
    for (let e of c.edges) if (!e.invalid) this.deleteEdge(e, true);
    this.emit("update");
  }
  deleteEdge(e, noupdate = false) {
    this.addMutation(e, e.getMemento(), { delete: true });
    let source_pre = e.source.getMemento();
    let target_pre = e.target.getMemento();
    e.delete();
    this.addMutation(e.source, source_pre, e.source.getMemento());
    this.addMutation(e.target, target_pre, e.target.getMemento());
    if (!noupdate) this.emit("update");
  }
  /**
   * Adds a structline from source to target.
   * @param source
   * @param target
   * @param mult
   * @returns {Structline} the structline object
   */
  addStructline(source2, target, mult) {
    if (this.duplicateEdge(Structline2, source2, target).length > 0) {
      return Structline2.getDummy();
    }
    if (!source2 || !target || source2.isDummy() || target.isDummy()) {
      return Structline2.getDummy();
    }
    let struct = new Structline2(this, source2, target);
    if (mult) struct.setProduct(mult);
    let source_pre = source2.getMemento();
    let target_pre = target.getMemento();
    source2._addStructline(struct);
    target._addStructline(struct);
    this.structlines.push(struct);
    struct.edge_list_index = this.edges.length;
    this.edges.push(struct);
    this.emit("edge-added", struct);
    this.emit("structline-added", struct);
    this.emit("update");
    this.addMutation(struct, { delete: true }, struct.getMemento());
    this.addMutation(source2, source_pre, source2.getMemento());
    this.addMutation(target, target_pre, target.getMemento());
    return struct;
  }
  /**
   * Adds a differential.
   * @param source
   * @param target
   * @param page
   * @returns {Differential}
   */
  addDifferential(source2, target, page, set_pages = true) {
    if (typeof source2 === "number") {
      console.log(
        "addDifferential a SseqClass in position 1, got a number. Probably the arguments are in the wrong order."
      );
      return Differential2.getDummy();
    }
    if (typeof page !== "number") {
      console.log(`Invalid page ${page} for differential.`);
      return Differential2.getDummy();
    }
    if (!source2 || !target) {
      return Differential2.getDummy();
    }
    if (source2.isDummy() || target.isDummy()) {
      console.log("source or target is dummy");
      return Differential2.getDummy();
    }
    let possible_duplicate_edges = this.duplicateEdge(
      Differential2,
      source2,
      target,
      page
    );
    if (possible_duplicate_edges.length > 0) {
      console.log("duplicate edge");
      console.log(possible_duplicate_edges);
      return possible_duplicate_edges[0];
    }
    if (page <= 0) {
      console.log([source2, target, page]);
      console.log("No page <= 0 differentials allowed.");
      return Differential2.getDummy();
    }
    let differential = new Differential2(this, source2, target, page);
    let source_pre = source2.getMemento();
    let target_pre = target.getMemento();
    source2._addOutgoingDifferential(differential, set_pages);
    target._addIncomingDifferential(differential, set_pages);
    differential.edge_list_index = this.edges.length;
    this.differentials.push(differential);
    this.edges.push(differential);
    this.addPageToPageList(page);
    this.emit("edge-added", differential);
    this.emit("differential-added", differential);
    this.emit("update");
    this.addMutation(differential, { delete: true }, differential.getMemento());
    this.addMutation(source2, source_pre, source2.getMemento());
    this.addMutation(target, target_pre, target.getMemento());
    return differential;
  }
  /**
   * Adds an extension.
   * @param source
   * @param target
   * @returns {Extension}
   */
  addExtension(source2, target) {
    if (!source2 || !target || source2.isDummy() || target.isDummy()) {
      return Extension2.getDummy();
    }
    if (this.duplicateEdge(Extension2, source2, target).length) {
      return Extension2.getDummy();
    }
    let ext = new Extension2(this, source2, target);
    ext.edge_list_index = this.edges.length;
    this.edges.push(ext);
    let source_pre = source2.getMemento();
    let target_pre = target.getMemento();
    source2._addExtension(ext);
    target._addExtension(ext);
    this.emit("edge-added", ext);
    this.emit("extension-added", ext);
    this.emit("update");
    this.addMutation(ext, { delete: true }, ext.getMemento());
    this.addMutation(source2, source_pre, source2.getMemento());
    this.addMutation(target, target_pre, target.getMemento());
    return ext;
  }
  duplicateEdge(type, source2, target, page) {
    return this.edges.filter(
      (e) => e.constructor === type && e.source === source2 && e.target === target && (!page || e.page === page) && !e.invalid
    );
  }
  /**
   * This doesn't work very well right now...
   * @param source
   * @param targets
   * @param page
   * @returns {Array}
   */
  addSumDifferential(source2, targets, page) {
    let target_name = targets.map((t) => t.name).join("+");
    let differentialList = [];
    for (let t of targets) {
      let d = this.addDifferential(source2, t, page);
      d.target_name = target_name;
      differentialList.push(d);
    }
    for (let i = 0; i < differentialList.length - 1; i++) {
      differentialList[i].replaceTarget();
    }
    return differentialList;
  }
  getClassString(c) {
    let name2 = c.name ? `[${c.name}]` : "";
    return `(${c.x}, ${c.y})${name2}`;
  }
  /**
   * Makes a query to determine if the user wants to add a differential.
   */
  getDifferentialQuery(source2, target, page) {
    if (page === void 0) {
      return `Add differential from ${this.getClassString(source2)} to ${this.getClassString(target)}?`;
    }
    return `Add d${page} differential from ${this.getClassString(source2)} to ${this.getClassString(target)}?`;
  }
  /**
   * Makes a query to determine if the user wants to add a Structline.
   */
  getStructlineQuery(source2, target, name2) {
    name2 = name2 ? " *" + name2 : "";
    return `Add${name2} structline from ${this.getClassString(source2)} to ${this.getClassString(target)}?`;
  }
  getExtensionQuery(source2, target, name2) {
    name2 = name2 ? " *" + name2 : "";
    return `Add${name2} extension from ${this.getClassString(source2)} to ${this.getClassString(target)}?`;
  }
  // Returns either falsey or a pair [description of edge to add, callback to add edge].
  // The idea is to query to user with description and run the callback if they agree.
  getPossibleEdgesToAdd(c1, c2) {
    if (this.stem_degree(c1) > this.stem_degree(c2)) {
      let temp = c2;
      c2 = c1;
      c1 = temp;
    }
    let s1 = this.stem_degree(c1);
    let s2 = this.stem_degree(c2);
    let f1 = this.filtration_degree(c1);
    let f2 = this.filtration_degree(c2);
    let ds = s2 - s1;
    let df = f2 - f1;
    if (ds === 1) {
      if (df < 0) {
        return {
          query: this.getDifferentialQuery(c2, c1, -df),
          callback: () => this.addDifferential(c2, c1, -df)
        };
      }
    }
    for (let prod of this.products) {
      if (prod.stem === ds && prod.filtration === df) {
        return {
          query: this.getStructlineQuery(c1, c2, prod.name),
          callback: () => this.addStructline(c1, c2).setProduct(prod.name).setColor(prod.color)
        };
      }
      if (prod.stem === -ds && prod.filtration === df) {
        return {
          query: this.getStructlineQuery(c2, c1, prod.name),
          callback: () => this.addStructline(c2, c1).setProduct(prod.name).setColor(prod.color)
        };
      }
    }
    for (let prod of this.products) {
      if (prod.stem === ds && prod.filtration < df) {
        return {
          query: this.getExtensionQuery(c1, c2, prod.name),
          callback: () => this.addExtension(c1, c2).setProduct(prod.name).setColor(prod.color)
        };
      }
      if (prod.stem === -ds && prod.filtration < df) {
        return {
          query: this.getExtensionQuery(c2, c1, prod.name),
          callback: () => this.addExtension(c2, c1).setProduct(prod.name).setColor(prod.color)
        };
      }
    }
    return false;
  }
  decrementClassIndex(c) {
    let classes = this.getClassesInDegree(c.x, c.y);
    let idx = c.idx;
    if (idx === 0) {
      return;
    }
    for (let c2 of classes) {
      if (c2.idx === idx - 1) {
        c.idx--;
        c2.idx++;
        return;
      }
    }
  }
  incrementClassIndex(c) {
    let classes = this.getClassesInDegree(c.x, c.y);
    let idx = c.idx;
    if (idx === classes.length) {
      return;
    }
    for (let c2 of classes) {
      if (c2.idx === idx + 1) {
        c.idx++;
        c2.idx--;
        return;
      }
    }
  }
  /**
   * For display purposes, a Sseq object maintains a list of pages on which something changes in the spectral sequence.
   * Currently this list always contains 0, infinity, and the set of pages on which differentials live.
   * @param page
   * @returns {Sseq} chainable
   */
  addPageToPageList(page) {
    for (let i = 0; i < this.page_list.length; i++) {
      let compare_page;
      if (Array.isArray(this.page_list[i])) {
        compare_page = this.page_list[i][0];
      } else {
        compare_page = this.page_list[i];
      }
      if (compare_page > page) {
        this.page_list.splice(i, 0, page);
      }
      if (compare_page >= page && !Array.isArray(this.page_list[i])) {
        return this;
      }
    }
  }
  addPageRangeToPageList(pageRange) {
    let page = pageRange[0];
    for (let i = 0; i < this.page_list.length; i++) {
      let compare_page;
      if (Array.isArray(this.page_list[i])) {
        compare_page = this.page_list[i][0];
      } else {
        compare_page = this.page_list[i];
      }
      if (compare_page > page) {
        this.page_list.splice(i, 0, pageRange);
        return this;
      } else if (compare_page == page) {
        if (!Array.isArray(this.page_list[i])) {
          this.page_list.splice(i, 0, pageRange);
          return this;
        } else {
          if (this.page_list[i][1] > pageRange[1]) {
            this.page_list.splice(i, 0, pageRange);
            return this;
          } else if (this.page_list[i][1] == pageRange[1]) {
            return this;
          }
        }
      }
    }
  }
  /**
   *
   * @param var_degree_dict -- Object with bidegrees of the generators, of the form `"var_name" : [stem, filtration]`
   * @param var_spec_list -- List of range specifications. Each range specification is a list of the form
   *  `["var_name", min, max, step]` where `min` defaults to 0 and `step` defaults to 1.
   * @param cond
   * @returns {monomial_basis} A monomial_basis object containing the set of classes so generated.
   */
  addPolynomialClasses(var_degree_dict, var_spec_list, module_generators = { "": [0, 0] }) {
    if (!Array.isArray(var_spec_list)) {
      throw "Second argument of addPolynomialClasses should be an array";
    }
    return new monomial_basis2(
      this,
      var_degree_dict,
      var_spec_list,
      module_generators
    );
  }
  deserializePolynomialClasses(serialized_basis) {
    return new monomial_basis2(this, serialized_basis);
  }
  addSliceClasses(var_degree_dict, var_spec_list, make_slice) {
    if (!Array.isArray(var_spec_list)) {
      throw "Second argument of addPolynomialClasses should be an array";
    }
    return new slice_basis2(this, var_degree_dict, var_spec_list, make_slice);
  }
  getSurvivingClasses(page) {
    if (page === void 0) {
      page = infinity5 - 1;
    }
    return this.classes.filter(
      (c) => c.page_list[c.page_list.length - 1] >= page
    );
  }
  /**
   * This returns the classes and edges that should be displayed on the current page and view range.
   *
   * @param page
   * @param xmin
   * @param xmax
   * @param ymin
   * @param ymax
   * @package
   */
  getDrawnElements(page, xmin, xmax2, ymin, ymax) {
    checkArgumentsDefined(_Sseq.prototype.getDrawnElements, arguments);
    let pageRange;
    if (Array.isArray(page)) {
      pageRange = page;
      page = page[0];
    } else {
      pageRange = [page, page];
    }
    let display_classes = this.classes.filter((c) => {
      if (!c || c.invalid) {
        return false;
      }
      c.in_range = _Sseq._classInRangeQ(c, xmin, xmax2, ymin, ymax);
      return c.in_range && _Sseq._drawClassOnPageQ(c, page);
    });
    let display_edges = this.edges.filter(
      (e) => e && !e.invalid && _Sseq._drawEdgeOnPageQ(e, pageRange) && _Sseq._drawClassOnPageQ(e.source, page) && _Sseq._drawClassOnPageQ(e.target, page) && (e.source.in_range || e.target.in_range)
    );
    for (let e of display_edges) {
      if (!e.source.in_range) {
        display_classes.push(e.source);
        e.source.in_range = true;
      }
      if (!e.target.in_range) {
        e.target.in_range = true;
        display_classes.push(e.target);
      }
    }
    let display_nodes = display_classes.map((c) => {
      let node = this.getClassNode(c, page);
      if (node === void 0) {
        console.log(c);
        console.log(page);
        throw `Undefined node for class`;
      }
      node.c = c;
      node.x = c.x;
      node.y = c.y;
      c.node = node;
      return node;
    });
    display_nodes = display_nodes.filter((n) => n);
    for (let e of display_edges) {
      e.source_node = e.source.node;
      e.target_node = e.target.node;
    }
    return [display_nodes, display_edges];
  }
  /**
   * For c a class, check if `xmin <= c.x <= xmax` and `ymin <= c.y <= ymax`
   * @param c
   * @param xmin
   * @param xmax
   * @param ymin
   * @param ymax
   * @returns {boolean}
   * @private
   */
  static _classInRangeQ(c, xmin, xmax2, ymin, ymax) {
    return xmin <= c.x && c.x <= xmax2 && ymin <= c.y && c.y <= ymax;
  }
  /**
   * Check whether `page` is less than the maximum draw page for the `c`.
   * @param c
   * @param page
   * @returns {boolean}
   * @private
   */
  static _drawClassOnPageQ(c, page) {
    if (c._drawOnPageQ) {
      return c._drawOnPageQ(page);
    } else {
      return SseqClass3.prototype._drawOnPageQ.call(c, page);
    }
  }
  /**
   * Check whether the edge should be drawn on the given page / pageRange. The behavior depends on whether the edge is a
   * Differential, Structline, or Extension.
   * @param edge
   * @param pageRange
   * @returns {boolean}
   * @private
   */
  static _drawEdgeOnPageQ(edge, pageRange) {
    if (edge._drawOnPageQ) {
      return edge._drawOnPageQ(pageRange);
    } else {
      switch (edge.type) {
        case "Differential":
          return Differential2.prototype._drawOnPageQ.call(edge, pageRange);
        case "Extension":
          return Extension2.prototype._drawOnPageQ.call(edge, pageRange);
        case "Structline":
          return Structline2.prototype._drawOnPageQ.call(edge, pageRange);
        default:
          return Edge2.prototype._drawOnPageQ.call(edge, pageRange);
      }
    }
  }
  /**
   * If multiple classes are in the same (x,y) location, we offset their position a bit to avoid clashes.
   * Gets called by display code.
   * @returns {number} The x offset
   * @package
   */
  _getXOffset(node, page) {
    let c = node.c;
    if (c.x_offset !== false) {
      return c.x_offset * this.offset_size;
    }
    let total_classes = this.num_classes_by_degree.get([c.x, c.y]);
    let idx = c.idx;
    let out = (idx - (total_classes - 1) / 2) * this.offset_size;
    if (isNaN(out)) {
      console.log("Invalid offset for class:", c);
      return 0;
    }
    return out;
  }
  /**
   * If multiple classes are in the same (x,y) location, we offset their position a bit to avoid clashes.
   * Gets called by display code.
   * @returns {number} The y offset
   * @package
   */
  _getYOffset(node, page) {
    let c = node.c;
    if (c.y_offset !== false) {
      return c.y_offset * this.offset_size;
    }
    let total_classes = this.num_classes_by_degree.get([c.x, c.y]);
    let idx = c.idx;
    let out = -(idx - (total_classes - 1) / 2) * this.offset_size;
    if (isNaN(out)) {
      console.log("Invalid offset for class:", c);
      return 0;
    }
    return out;
  }
  /**
   * Gets the node to be drawn for the class on the given page. Used primarily by display.
   * @param c
   * @param page
   * @returns {*}
   */
  getClassNode(c, page) {
    return c.node_list[SseqClass3.prototype._getPageIndex.call(c, page)];
  }
  exportToTex(filename, page, xmin, xmax2, ymin, ymax) {
    ExportToTex.DownloadSpectralSequenceTex(
      filename,
      this,
      page,
      xmin,
      xmax2,
      ymin,
      ymax
    );
  }
  static fromJSONObject(json) {
    let sseq2 = new _Sseq();
    let serializeSseqFields;
    if (json.serializeSseqFields)
      serializeSseqFields = json.serializeSseqFields;
    else serializeSseqFields = _Sseq.serializeSseqFields;
    for (let field of serializeSseqFields) {
      if (json[field]) sseq2[field] = json[field];
    }
    sseq2.default_node = new Node2(sseq2.default_node);
    sseq2.default_node.shape = Shape_exports[sseq2.default_node.shape.name];
    let class_idx = [];
    let mnl = json.master_node_list;
    for (let c of json.classes) {
      let rc = sseq2.addClass(c.x, c.y);
      Object.assign(rc, c);
      rc.node_list = rc.node_list.map((x) => new Node2(mnl[x]));
      for (let n of rc.node_list) {
        n.shape = Shape_exports[n.shape.name];
      }
      class_idx.push(rc);
    }
    for (let e of json.edges) {
      let source2 = class_idx[e.source];
      let target = class_idx[e.target];
      if (source2.y > target.y) {
        [source2, target] = [target, source2];
      }
      let re2;
      switch (e.type) {
        case "Differential":
          let source_page_list = source2.page_list.slice();
          let target_page_list = target.page_list.slice();
          re2 = sseq2.addDifferential(source2, target, e.page);
          source2.page_list = source_page_list;
          target.page_list = target_page_list;
          break;
        case "Structline":
          re2 = sseq2.addStructline(source2, target);
          break;
        case "Extension":
          re2 = sseq2.addExtension(source2, target);
          break;
      }
      Object.assign(re2, e);
      re2.source = source2;
      re2.target = target;
    }
    return sseq2;
  }
  deleteDuplicateEdges() {
    for (let c of this.getClasses()) {
      let targets = [];
      for (let e of c.getEdges()) {
        if (targets.includes(e.otherClass(c))) {
          e.delete();
        } else {
          targets.push(e.otherClass(c));
        }
      }
    }
  }
  addSseqFieldToSerialize(field) {
    if (Array.isArray(field)) {
      field.forEach((f) => this.addSseqFieldToSerialize(f));
      return;
    }
    if (!this.serializeSseqFields.includes(field)) {
      this.serializeSseqFields.push(field);
    }
  }
  addClassFieldToSerialize(field) {
    if (Array.isArray(field)) {
      field.forEach((f) => this.addClassFieldToSerialize(f));
      return;
    }
    if (!this.serializeClassFields.includes(field)) {
      this.serializeClassFields.push(field);
    }
  }
  addEdgeFieldToSerialize(field) {
    if (Array.isArray(field)) {
      field.forEach((f) => this.addEdgeFieldToSerialize(f));
      return;
    }
    if (!this.serializeEdgeFields.includes(field)) {
      this.serializeEdgeFields.push(field);
    }
  }
  download(filename) {
    download2(filename, JSON.stringify(this));
  }
  static upload() {
    return upload().then((json) => {
      return _Sseq.fromJSONObject(JSON.parse(json));
    });
  }
  save() {
    if (!this.save_name) {
      this.saveAs();
    } else {
      this.saveToLocalStore(name);
    }
  }
  saveAs() {
    let name2 = prompt("Save as:", this.save_name || "");
    if (name2) {
      this.save_name = name2;
      this.saveToLocalStore(name2);
    }
  }
  saveToLocalStore(key) {
    return saveToLocalStore(key, this);
  }
  static async loadFromDataStoreOrServer(path) {
    let json;
    json = await loadFromLocalStore(path);
    if (!json) {
      json = await loadFromServer(path);
    }
    let sseq2 = _Sseq.fromJSONObject(json);
    sseq2.path = path;
    return sseq2;
  }
  static async loadFromServer(path) {
    let json = await loadFromServer(path);
    return _Sseq.fromJSONObject(json);
  }
  static async loadFromLocalStore(key) {
    let json = await loadFromLocalStore(key);
    console.log(json);
    return _Sseq.fromJSONObject(json);
  }
  // This is hacky. Need to choose which properties to keep.
  static _serializeNode(node) {
    let n = {};
    for (let field of this.serializeNodeFields) {
      if (node[field]) n[field] = node[field];
    }
    return n;
  }
  toJSON() {
    let json = {};
    for (let field of this.serializeSseqFields) {
      json[field] = this[field];
    }
    let node_map = new StringifyingMap2(
      (n) => JSON.stringify(_Sseq._serializeNode(n))
    );
    json.master_node_list = [];
    json.classes = [];
    json.edges = [];
    for (let c of this.classes) {
      if (c.invalid) {
        continue;
      }
      let cs = {};
      for (let field of this.serializeClassFields) {
        cs[field] = c[field];
      }
      cs.node_list = [];
      for (let cur_node of c.node_list) {
        if (!node_map.has(cur_node)) {
          node_map.set(cur_node, json.master_node_list.length);
          json.master_node_list.push(_Sseq._serializeNode(cur_node));
        }
        cs.node_list.push(node_map.get(cur_node));
      }
      c.list_index = json.classes.length;
      json.classes.push(cs);
    }
    for (let e of this.edges) {
      if (e.invalid) {
        continue;
      }
      let es = {};
      for (let field of this.serializeEdgeFields) {
        es[field] = e[field];
      }
      es.source = e.source.list_index;
      es.target = e.target.list_index;
      json.edges.push(es);
    }
    return json;
  }
};
Sseq.serializeSseqFields = [
  "min_page_idx",
  "page_list",
  "xRange",
  "yRange",
  "initialxRange",
  "initialyRange",
  "default_node",
  "class_scale",
  "offset_size",
  "min_class_size",
  "max_class_size",
  "serializeSseqFields",
  "serializeClassFields",
  "serializeEdgeFields",
  "serializeNodeFields"
];
Sseq.serializeClassFields = [
  "x",
  "y",
  "name",
  "extra_info",
  "unique_id",
  "idx",
  "x_offset",
  "y_offset",
  "page_list",
  "visible"
];
Sseq.serializeEdgeFields = [
  "color",
  "bend",
  "dash",
  "lineWidth",
  "opacity",
  "page_min",
  "page",
  "type",
  "mult",
  "source_name",
  "target_name"
];
Sseq.serializeNodeFields = [
  "opacity",
  "color",
  "fill",
  "stroke",
  "hcolor",
  "hfill",
  "hstroke",
  "shape",
  "scale"
];

// src/ass_tools.js
var ass_tools_exports = {};
__export(ass_tools_exports, {
  addProductNames: () => addProductNames,
  fixed_tower_xOffset: () => fixed_tower_xOffset,
  getClassExpression: () => getClassExpression,
  install_edit_handlers: () => install_edit_handlers,
  markTowers: () => markTowers,
  minimizeCrossings: () => minimizeCrossings,
  multiply_monomial: () => multiply_monomial,
  straightenTowers: () => straightenTowers
});
var Mousetrap4 = __toESM(require_mousetrap());
function getClassExpression(c) {
  let out = `(${c.x}, ${c.y})`;
  if (c.name) {
    out += ` [${c.name}]`;
  }
  return out;
}
function variablePowerString(variable, power) {
  if (power === 1) {
    return variable;
  }
  return `${variable}^{${power}}`;
}
function multiply_monomial(variable, power, monomial) {
  let power_regex = new RegExp(
    `${variable}(\\^{?(.)}?)?`.replace("\\", "\\\\").replace(/\{/g, "\\{").replace(/\}/g, "\\}")
  );
  let matcher = power_regex.exec(monomial);
  if (!power_regex.test(monomial)) {
    console.log(monomial);
    return variablePowerString(variable, power) + monomial;
  }
  console.log(power_regex);
  console.log(matcher[2]);
  let old_power = Number.parseInt(matcher[2] || 1);
  let new_power = old_power + power;
  return monomial.replace(power_regex, `${variable}^{${new_power}}`);
}
function straightenTowers(sseq2) {
  markTowers(sseq2);
  for (let x = 1; x < xmax; x++) {
    if (!sseq2.longest_tower_map.has(x)) {
      continue;
    }
    let longest_tower = sseq2.longest_tower_map.get(x);
    if (longest_tower.length > 3) {
      for (let c = longest_tower.base; c; c = c.h0mult[0]) {
        c.x_offset = 0;
        for (let oc of sseq2.getClassesInDegree(c.x, c.y)) {
          oc.has_fixed_class = true;
        }
      }
    }
  }
}
function markTowers(sseq2) {
  let column_maps = /* @__PURE__ */ new Map();
  for (let c of sseq2.classes) {
    c.h0div = [];
    c.h0mult = [];
    c.tower = { length: 0, base: c };
  }
  for (let structline of sseq2.getStructlines()) {
    if (structline.source.x !== structline.target.x) {
      continue;
    }
    let source2, target;
    if (structline.source.y < structline.target.y) {
      source2 = structline.source;
      target = structline.target;
    } else {
      source2 = structline.target;
      target = structline.source;
    }
    source2.h0mult.push(target);
    target.h0div.push(source2);
  }
  let columns = /* @__PURE__ */ new Map();
  let longest_towers = /* @__PURE__ */ new Map();
  let xmax2 = 0;
  let ymax = 0;
  for (let c of sseq2.classes) {
    if (!columns.has(c.x)) {
      columns.set(c.x, /* @__PURE__ */ new Map());
    }
    if (!columns.get(c.x).has(c.y)) {
      columns.get(c.x).set(c.y, []);
    }
    columns.get(c.x).get(c.y).push(c);
    if (c.x > 0 && c.y > ymax) {
      ymax = c.y;
    }
    if (c.x > xmax2) {
      xmax2 = c.x;
    }
  }
  let longest_tower_map = /* @__PURE__ */ new Map();
  for (let x = 1; x < xmax2; x++) {
    if (!columns.has(x)) {
      continue;
    }
    let col = columns.get(x);
    let longest_tower = {};
    let longest_tower_length = -1;
    for (let y = 1; y < ymax; y++) {
      if (!col.has(y)) {
        continue;
      }
      for (let c of col.get(y)) {
        let tower = c.tower;
        for (let div of c.h0div) {
          if (div.tower.length > tower.length) {
            tower = div.tower;
          }
        }
        tower.length++;
        c.tower = tower;
        if (tower.length > longest_tower_length) {
          longest_tower_length = tower.length;
          longest_tower = tower;
        }
      }
    }
    longest_tower_map.set(x, longest_tower);
  }
  sseq2.columns = columns;
  sseq2.longest_tower_map = longest_tower_map;
}
function minimizeCrossings(sseq2) {
  let cell_class_list = new StringifyingMap();
  for (let stem of sseq2.getOccupiedStems()) {
    let classes = sseq2.getStem(stem);
    let column = /* @__PURE__ */ new Map();
    for (let c of sseq2.getClasses()) {
      if (!column.has(c.y)) {
        column.set(c.y, []);
      }
      column.get(c.y).push(c);
    }
    for (let cell of column.values()) {
      if (cell.length === 1) {
        continue;
      }
      for (let c of cell) {
        c.crossing_score = 0;
        for (let sl of c.structlines) {
          let t = otherClass(sl, c);
          if (t.x < c.x) {
            c.crossing_score--;
          } else if (t.x > c.x) {
            c.crossing_score++;
          }
        }
      }
      cell.sort((c) => c.crossing_score);
      for (let i = 0; i < cell.length; i++) {
        cell[i].idx = i;
      }
    }
  }
}
function fixed_tower_xOffset(node, page) {
  let c = node.c;
  if (c.x_offset !== false) {
    return c.x_offset * this.offset_size;
  }
  let total_classes = this.num_classes_by_degree.get([c.x, c.y]);
  let idx = c.idx;
  let out = idx - (total_classes - 1) / 2;
  if (c.has_fixed_class) {
    let out_old = out;
    if (total_classes % 2 === 0) {
      if (out >= 0) {
        out += 1 / 2;
      } else {
        out -= 1 / 2;
      }
    } else {
      if (out >= 0) {
        out += 1;
      }
    }
  }
  return out * this.offset_size;
}
function install_edit_handlers(display, download_filename) {
  Mousetrap4.bind("q", () => {
    if (!display.mouseover_node) {
      return;
    }
    display.sseq.incrementClassIndex(display.mouseover_node.c);
  });
  Mousetrap4.bind("w", () => {
    if (!display.mouseover_node) {
      return;
    }
    display.sseq.decrementClassIndex(display.mouseover_node.c);
  });
  Mousetrap4.bind("d", () => {
    display.sseq.download(download_filename + ".json");
  });
  Mousetrap4.bind("s", () => {
    if (display.mouseover_node) {
      display.temp_source_class = display.mouseover_node.c;
    }
  });
  Mousetrap4.bind("t", () => {
    if (display.mouseover_node && display.temp_source_class) {
      console.log("t");
      let s = display.temp_source_class;
      let t = display.mouseover_node.c;
      console.log(s);
      console.log(t);
      if (s.x !== t.x + 1) {
        return;
      }
      let length = t.y - s.y;
      if (confirm(
        `Add d${length} differential from ${getClassExpression(s)} to ${getClassExpression(t)}`
      )) {
        let d = display.sseq.addDifferential(s, t, length);
        display.sseq.emit("update");
      }
    }
  });
  Mousetrap4.bind("n", () => {
    if (display.mouseover_node && display.temp_source_class) {
      let s = display.temp_source_class;
      let t = display.mouseover_node.c;
      if (confirm(
        `Delete edges ${getClassExpression(s)} to ${getClassExpression(t)}`
      )) {
        source.getEdges().filter((e) => e.otherClass(s) === t).forEach((e) => e.delete());
        display.sseq.emit("update");
      }
    }
  });
  display.on("click", (node) => {
    if (!node) {
      return;
    }
    let c = node.c;
    let default_text = "";
    if (c.name) {
      default_text = c.name;
    }
    let name2 = prompt(
      `Enter new name for class at position (${c.x},${c.y})`,
      default_text
    );
    if (name2 || name2 === "") {
      c.name = name2;
      c.setColor("black");
      display.sseq.emit("update");
    }
    c.tooltip_html = void 0;
  });
  Mousetrap4.bind("p", () => {
    if (display.mouseover_node) {
      display.mouseover_node.c.problem = true;
    }
  });
}
function addProductNames(sseq2, variable) {
  let indecomposable_classes = sseq2.classes.filter(
    (c) => !c.structlines.some((sl) => otherClass(sl, c).y < c.y && sl.visible)
  );
  for (let c of indecomposable_classes) {
    let name2 = c.name;
    if (!name2) {
      continue;
    }
    let power = 1;
    while (c) {
      let h0mult = c.getProducts(variable);
      if (h0mult.length !== 1) {
        break;
      }
      c = otherClass(h0mult[0], c);
      if (c.name) {
        break;
      }
      c.name = tools.multiply_monomial(variable, power, name2);
      sseq2.emit("update");
      power++;
    }
  }
}

// src/main.js
var Mousetrap5 = __toESM(require_mousetrap());
var C2S2 = __toESM(require_canvas2svg());
var infinity6 = 1e4;
function mod(n, d) {
  return (n % d + d) % d;
}
var sseqDatabase2 = sseqDatabase;
window.on_public_website = new URL(document.location).hostname === "math.mit.edu";
window.getJSONFilename = function(file_name) {
  file_name = `json/${file_name}.json`;
  if (on_public_website) {
    file_name = "js_spectralsequences/" + file_name;
  }
  return file_name;
};
var export_EventEmitter = import_events4.EventEmitter;
export {
  BasicDisplay,
  C2S2 as C2S,
  Differential2 as Differential,
  Display,
  Edge2 as Edge,
  EditorDisplay,
  export_EventEmitter as EventEmitter,
  ExportToTex_exports as ExportToTex,
  Extension2 as Extension,
  SaveLoad_exports as IO,
  Interface_exports as Interface,
  Mousetrap5 as Mousetrap,
  Node2 as Node,
  Panel_exports as Panel,
  Shape_exports as Shapes,
  SidebarDisplay,
  Sseq,
  SseqClass3 as SseqClass,
  StringifyingMap2 as StringifyingMap,
  Structline2 as Structline,
  Tooltip,
  Util_exports as Util,
  src_exports as d3,
  dictionaryVectorLinearCombination2 as dictionaryVectorLinearCombination,
  dictionaryVectorScale2 as dictionaryVectorScale,
  dictionaryVectorSum2 as dictionaryVectorSum,
  infinity6 as infinity,
  mod,
  monomialString2 as monomialString,
  product2 as product,
  range2 as range,
  sseqDatabase2 as sseqDatabase,
  ass_tools_exports as tools,
  vectorLinearCombination2 as vectorLinearCombination,
  vectorScale2 as vectorScale,
  vectorSum2 as vectorSum
};
/*! Bundled license information:

canvas2svg/canvas2svg.js:
  (*!!
   *  Canvas 2 Svg v1.0.15
   *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
   *
   *  Licensed under the MIT license:
   *  http://www.opensource.org/licenses/mit-license.php
   *
   *  Author:
   *  Kerry Liu
   *
   *  Copyright (c) 2014 Gliffy Inc.
   *)
*/
